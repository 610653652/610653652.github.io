<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一些学到的算法分享</title>
      <link href="/2023/03/17/yi-xie-xue-dao-de-suan-fa-fen-xiang/"/>
      <url>/2023/03/17/yi-xie-xue-dao-de-suan-fa-fen-xiang/</url>
      
        <content type="html"><![CDATA[<h4 id="寻找出现奇数次的一个数">1.寻找出现奇数次的一个数</h4><p>在一个数组中，有一个数出现了奇数次，其他数都出现了偶数次，如何找出出现奇数次的数。</p><p>令eor=0，令eor和数组中全部数异或（^）一遍，eor等于几，那个数就是几</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printOddTimesNum1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> eor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        eor <span class="token operator">=</span> eor <span class="token operator">^</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>eor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="寻找出现奇数次的两个数">2.寻找出现奇数次的两个数</h4><p>在一个数组中，有两个数出现了奇数次，其他数都出现了偶数次，如何找出出现奇数次的两个数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printOddTimesNum2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> eor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> curNum <span class="token operator">:</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        eor <span class="token operator">^=</span> curNum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//eor = a ^ b</span>    <span class="token comment">//eor != 0</span>    <span class="token comment">//eor二进制在某一个位置必定为1</span>    <span class="token keyword">int</span> rightOne <span class="token operator">=</span> eor <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>eor <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//提取最右侧的1</span>        <span class="token keyword">int</span> eor1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> cur <span class="token operator">:</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cur <span class="token operator">&amp;</span> rightOne<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//只和rightOne位为1的进行异或,找出a或b其中一个值</span>            eor1 <span class="token operator">^=</span> cur<span class="token punctuation">;</span> <span class="token comment">//eor1是a或b其中的一个</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>eor1 <span class="token operator">+</span><span class="token char">' '</span><span class="token operator">+</span> <span class="token punctuation">(</span>eor1<span class="token operator">^</span>eor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="冒泡排序">3.冒泡排序</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="选择排序">4.选择排序</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">SelectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                minIndex <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">?</span> j <span class="token operator">:</span> minIndex<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> minIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="插入排序">5.插入排序</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">InsertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//0-0 有序</span>        <span class="token comment">//0-i 想有序</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//0-i 做到有序</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二分法">6.二分法</h4><p>1）在一个有序数组中，找某个数是否存在</p><p>2）在一个有序数组中，找&gt;=某个数最左侧的位置</p><p>3）局部最小值问题：无序数组中，任何两个相邻的数一定不相等，找到至少一个局部最小。</p><h4 id="递归">7.递归</h4><p>1）求数组最大值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//arr[L..R]范围求最大值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">L</span><span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">L</span><span class="token operator">==</span><span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//arr[L..R]范围上只有一个数,直接返回</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token class-name">L</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token class-name">L</span> <span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token operator">-</span><span class="token class-name">L</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//中点</span>    <span class="token keyword">int</span> leftMax <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token class-name">L</span><span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rightMax <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftMax<span class="token punctuation">,</span>rightMax<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="归并排序">8.归并排序</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">L</span><span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">L</span><span class="token operator">==</span><span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//arr[L..R]范围上只有一个数,直接返回</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token class-name">L</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token class-name">L</span> <span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token operator">-</span><span class="token class-name">L</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//中点</span>    <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token class-name">L</span><span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token class-name">L</span><span class="token punctuation">,</span>mid<span class="token punctuation">,</span><span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">L</span><span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">M</span><span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> help <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">R</span><span class="token operator">-</span><span class="token class-name">L</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token class-name">L</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p2 <span class="token operator">=</span> <span class="token class-name">M</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1<span class="token operator">&lt;=</span><span class="token class-name">M</span> <span class="token operator">&amp;&amp;</span> p2<span class="token operator">&lt;=</span><span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//都不越界的情况下</span>        help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//比较p1位置的值和p2位置的值,谁小谁拷贝到help[]的i位置,然后被拷贝那侧指针右移</span>    <span class="token punctuation">}</span>    <span class="token comment">//一侧指针到头以后,将另一侧指针剩下的数直接拷贝到help[]中</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1<span class="token operator">&lt;=</span><span class="token class-name">M</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p2<span class="token operator">&lt;=</span><span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//将help[]中的东西拷贝回arr中</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> help<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        arr<span class="token punctuation">[</span><span class="token class-name">L</span> <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> help<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="小和问题">9.小和问题</h4><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。</p><p>例子：[1,3,4,2,5]1左边比1小的数，没有；3左边比3小的数，1；4左边比4小的数，1、3；2左边比2小的数，1；5左边比5小的数，1、3、4、2；所以小和为1+1+3+1+1+3+4+2=16</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">smallSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//arr[L..R]既要排好序,也要求小和</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token class-name">L</span> <span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token operator">-</span><span class="token class-name">L</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//中点</span>    <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>l<span class="token punctuation">,</span>mid<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>l<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> m<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> help <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p1 <span class="token operator">=</span> l<span class="token punctuation">;</span>    <span class="token keyword">int</span> p2 <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1<span class="token operator">&lt;=</span>m <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//当左侧指针(p1)位置值小于右侧指针位置时,增加当前右组比p1大的数量(r - p2 + 1)的小和</span>        res <span class="token operator">+=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> p2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//左组比右组小的时候拷贝左组,否则拷贝右组(等于时先拷贝右组)</span>        help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1<span class="token operator">&lt;=</span>m<span class="token punctuation">)</span><span class="token punctuation">{</span>        help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p2<span class="token operator">&lt;=</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>        help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> help<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>l <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> help<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="逆序对问题hard">10.逆序对问题（hard）</h4><p>在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请找到逆序对的数量并打印所有逆序对。</p><h4 id="快速排序">11.快速排序</h4><h4 id="堆理解为一种特殊的完全二叉树">12.堆（理解为一种特殊的完全二叉树）</h4><ul><li><p>完全二叉树</p><p>从位置0开始的连续一段数组理解为完全二叉树</p><p>索引 i 位置左孩子：2 * i + 1，右孩子：2 * i + 2，父节点：(i - 1) /2</p></li><li><p>大根堆，小根堆</p><ul><li>大根堆：以i节点为头的整棵树，节点i是最大值（每个子树的最大值是头节点的值）</li><li>小根堆：以i节点为头的整棵树，节点i是最小值（每个子树的最小值是头节点的值）</li></ul></li><li><p><strong>heapInsert</strong>：将输入的节点排成大根堆</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span><span class="token punctuation">(</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//和父节点比较大小</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>index<span class="token punctuation">,</span><span class="token punctuation">(</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        index <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>heapify</strong>：把大根堆中最大的数拿掉，并让剩余的数变成大根堆</p></li></ul><p>先将0位置上的数用临时变量记住，将最后一个数拷贝到0位置，heapSize--，然后从头节点开始，在其左孩子和右孩子中找到最大的，头节点和其比较大小。若头节点小于最大的孩子，则孩子变到头节点位置，头节点到该孩子位置。直到两个孩子的最大值都没有头节点大或头节点没有孩子时停止</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span><span class="token keyword">int</span> heapSize<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//左孩子的下标</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> heapSize<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//如果左孩子没有越界(判断下方有没有孩子)</span>        <span class="token comment">//如果右孩子没有越界且右比左大,则把下标给largest(寻找两个孩子中的最大值)</span>        <span class="token keyword">int</span> largest <span class="token operator">=</span> right <span class="token operator">&lt;</span> heapSize <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">?</span> right <span class="token operator">:</span> left<span class="token punctuation">;</span>        <span class="token comment">//比较父节点和较大孩子谁大</span>        largest <span class="token operator">=</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">?</span> index <span class="token operator">:</span> largest<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>largest <span class="token operator">==</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>largest<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将父节点交换到最大(在孩子和当前父节点中最大)</span>        index <span class="token operator">=</span> largest<span class="token punctuation">;</span> <span class="token comment">//接着往下走</span>        left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>将i位置的值a变成b，让新的数组重新变成大根堆</p><p>判断b和i位置原来值(a)的大小，如果a&gt;b（换来的数变小了），则向下进行heapify（把孩子中最大的数顶到替换位置）；如果a&lt;b（变大了），则向上进行heapInsert（将这个变大后的数和父节点比较）</p><p>如果不告诉b的大小，则先进行heapify，再进行heapInsert（只能中一个，先做谁无所谓）</p></li><li><p><strong>堆排序</strong>（时间复杂度O(N *logN)，空间复杂度O(1)）</p><p>先用heapInsert把数组排成大根堆，然后将0位置和最后一位交换，heapsize--（最大值断开联系，排到正确位置），做heapify；重复将0位置和最后一位交换，heapsize--，直到heapsize=0</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//排成大根堆</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">heapInsert</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> heapSize <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">//将0位置和最后一位交换，heapsize--</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">--</span>heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//重复heapify和交换直到heapsize=0</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>heapSize <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">--</span>heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="堆排序扩展">13.堆排序扩展</h4><p>已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SortArrayDistanceLessK</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortedArrDistanceLessK</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//生成小根堆</span>        <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> heap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//把前k个数放到小根堆中</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>index <span class="token operator">&lt;=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>index<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            heap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//再加一个数,此时heap中有k+1个数,将第一个数弹出,再次添加</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>index <span class="token operator">&lt;=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>index<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            heap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//当数组中数字加完时(heap中仍有剩余),将heap按顺序弹出</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>heap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="桶排序">14.桶排序</h4><ul><li><p>计数排序</p></li><li><p>基数排序</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RadixSort</span> <span class="token punctuation">{</span><span class="token comment">// only for no-negative value</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token function">radixSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">maxbits</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//求最大值有几个十进制位</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">maxbits</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>max <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token operator">++</span><span class="token punctuation">;</span>            max <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//arr[begin..end]排序,digit表示最大的数有几个十进制位</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">L</span><span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">,</span><span class="token keyword">int</span> digit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> radix <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//有多少个数准备多少个辅助空间</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">R</span> <span class="token operator">-</span> <span class="token class-name">L</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> d <span class="token operator">&lt;=</span> digit<span class="token punctuation">;</span> d<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//有多少位就进出几次(发生多少次入桶出桶)</span>           <span class="token comment">//10个空间</span>           <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>radix<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//count[0..9]</span>            <span class="token comment">//统计词频,每个位置的词频为≤这个位置数字的数量多少</span>            <span class="token comment">//count[0] 当前位(d位)是0的数字有多少个</span>           <span class="token comment">//count[1] 当前位(d位)是(0和1)的数字有多少个</span>           <span class="token comment">//count[2] 当前位(d位)是(0、1和2)的数字有多少个</span>           <span class="token comment">//count[i] 当前位(d位)是(0~i)的数字有多少个</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token class-name">L</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> <span class="token class-name">R</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                j<span class="token operator">=</span> <span class="token function">getDigit</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>                count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//统计≤的数量</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> radix <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> count<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//分片,把第digit位的数按照之前统计的词频分片</span>            <span class="token comment">//比如个位≤3的数共有16个,则从右向左遍历第一次遇见个位为3的数(比如63),将其放到15号位</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token class-name">R</span><span class="token punctuation">;</span> i<span class="token operator">&gt;=</span> <span class="token class-name">L</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j <span class="token operator">=</span> <span class="token function">getDigit</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>                bucket<span class="token punctuation">[</span>count<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//出桶,放到数组中</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token class-name">L</span><span class="token punctuation">,</span> j<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span> <span class="token class-name">R</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> d <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="排序算法稳定性及其汇总">15.排序算法稳定性及其汇总</h4><ul><li>不具备稳定性的排序：选择排序、快速排序、堆排序</li><li>具备稳定性的排序：冒泡排序、插入排序、归并排序、一切桶排序思想下的排序</li></ul><table><thead><tr class="header"><th></th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr class="odd"><td>选择排序</td><td><span class="math inline">\(O(N^2)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>×</td></tr><tr class="even"><td>冒泡排序</td><td><span class="math inline">\(O(N^2)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>√</td></tr><tr class="odd"><td>插入排序</td><td><span class="math inline">\(O(N^2)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>√</td></tr><tr class="even"><td>归并排序</td><td><span class="math inline">\(O(N*logN)\)</span></td><td><span class="math inline">\(O(N)\)</span></td><td>√</td></tr><tr class="odd"><td>快速排序</td><td><span class="math inline">\(O(N*logN)\)</span></td><td><span class="math inline">\(O(logN)\)</span></td><td>×</td></tr><tr class="even"><td>堆排序</td><td><span class="math inline">\(O(N*logN)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>×</td></tr></tbody></table><h4 id="哈希表">16.哈希表</h4><ul><li><p>如果只有key，没有伴随数据value，可以使用HashSet结构</p></li><li><p>如果既有key，又有伴随数据value，可以使用HashMap结构</p></li><li><p>使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为0(1)，但是常数时间比较大</p></li><li><p>放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小</p></li><li><p>放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小</p></li></ul><h4 id="有序表">17.有序表</h4><p>TreeSet、TreeMap</p><ul><li>有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织</li><li>红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同</li><li>放入有序表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小</li><li>放入有序表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占用是这个东西内存地址的大小</li><li>不管是什么底层具体实现，只要是有序表，都有固定的基本功能和固定的时间复杂度</li><li>有序表的固定操作：所有时间复杂度都是<span class="math inline">\(O(logN)\)</span></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> treeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"我是1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        treeMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//treeMap是否包含key为1的数据</span>        treeMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//treeMap中key为1对应的value</span>        treeMap<span class="token punctuation">.</span><span class="token function">firstKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//treeMap中key最小的数</span>        treeMap<span class="token punctuation">.</span><span class="token function">lastKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//treeMap中key最大的数</span>        treeMap<span class="token punctuation">.</span><span class="token function">ceilingKey</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在表中所有&gt;=1的数中，离1最近的数</span>        treeMap<span class="token punctuation">.</span><span class="token function">floorKey</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在表中所有&lt;=1的数中，离1最近的数</span>        treeMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="反转单向和双向链表">18.反转单向和双向链表</h4><ul><li>分别实现反转单向链表和反转双向链表的函数</li><li>如果链表长度为N，时间复杂度要求为<span class="math inline">\(O(N)\)</span>，额外空间复杂度要求为<span class="math inline">\(O(1)\)</span></li></ul><h4 id="打印两个有序链表的公共部分">19.打印两个有序链表的公共部分</h4><ul><li><p>给定两个有序链表的头指针head1和head2，打印两个链表的公共部分</p></li><li><p>如果两个链表的长度之和为N，时间复杂度要求为0(N)，额外空间复杂度要求为0(1)</p></li></ul><h4 id="面试时链表解题的方法论">20.面试时链表解题的方法论</h4><p>对于笔试，不用太在乎空间复杂度，一切为了时间复杂度</p><p>对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法</p><p>重要技巧： (1) 额外数据结构记录（哈希表等） (2) 快慢指针</p><h4 id="判断一个链表是否为回文结构">21.判断一个链表是否为回文结构</h4><ul><li><p>题目：给定一个单链表的头节点head，请判断该链表是否为回文结构。</p></li><li><p>例子：1-&gt;2-&gt;1，返回true；1-&gt;2-&gt;2-&gt;1，返回true；15-&gt;6-&gt;15，返回true；1-&gt;2-&gt;3，返回false。</p></li><li><p>要求：如果链表长度为N，时间复杂度达到0(N)，额外空间复杂度达到O(1)。</p></li></ul><p>笔试：放到栈中，弹出以后和原来是否一样</p><p>优化：把右侧的东西放到栈里，栈弹出的内容和左面进行比对。（快慢指针：快指针走2，慢指针走1，快指针走完了，慢指针就会到中点了）（coding练熟）</p><p>面试：(1)先快慢指针，中点遍历时(2)将中点指空，(3)右侧往回指。左右两侧用引用标记，(4)两个标记往中间走，并进行比对。直到走到空，(5)如果每一步都一样，则是回文。返回之前需要把(6)右侧恢复原来的样子。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> reverseList<span class="token punctuation">{</span>    <span class="token comment">//造链表</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> data<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment">//笔试</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome1</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//栈</span>        <span class="token class-name">Node</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment">//指针</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//压栈</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">//弹栈,逐个对比</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>value <span class="token operator">!=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//面试</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome3</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Node</span> n1 <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment">//慢指针</span>        <span class="token class-name">Node</span> n2 <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment">//快指针</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n2<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//(1)快慢指针寻找中间节点</span>            n1 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            n2 <span class="token operator">=</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        n2 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>   <span class="token comment">//n2指向右侧第一个节点</span>        n1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">//(2)中节点指向null</span>        <span class="token class-name">Node</span> n3 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//(3)反转右半部分</span>            n3 <span class="token operator">=</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            n2<span class="token punctuation">.</span>next <span class="token operator">=</span> n1<span class="token punctuation">;</span>            n1 <span class="token operator">=</span> n2<span class="token punctuation">;</span>            n2 <span class="token operator">=</span> n3<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        n3 <span class="token operator">=</span> n1<span class="token punctuation">;</span>        n2 <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> res <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">//(4)往中间节点走,(5)如果每一步都一样,则是回文。</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> n2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n1<span class="token punctuation">.</span>value <span class="token operator">!=</span> n2<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>                res <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            n1 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            n2 <span class="token operator">=</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//(6)恢复右侧</span>        n1 <span class="token operator">=</span> n3<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        n3<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n1 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            n2 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            n1<span class="token punctuation">.</span>next <span class="token operator">=</span> n3<span class="token punctuation">;</span>            n3 <span class="token operator">=</span> n1<span class="token punctuation">;</span>            n1 <span class="token operator">=</span> n2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="将单向链表按某值划分成左边小中间相等右边大的形式">22.将单向链表按某值划分成左边小、中间相等、右边大的形式</h4><ul><li>题目：给定一个单链表的头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。</li><li>进阶：在实现原问题功能的基础上增加如下的要求</li><li>要求：<ul><li>调整后所有小于pivot的节点之间的相对顺序和调整前一样</li><li>调整后所有等于pivot的节点之间的相对顺序和调整前一样</li><li>调整后所有大于pivot的节点之间的相对顺序和调整前一样</li><li>时间复杂度达到O(N)，额外空间复杂度达到O(1)。</li></ul></li></ul><p>笔试：(1)把节点放到列表中，(2)对列表做partation，(3)再把数组中的node串起来。</p><p>面试：(1)申请6个变量，小于pivot的头（SH），小于pivot的的尾（ST），等于pivot的头（EH），等于pivot的的尾（ET），大于pivot的头（BH），大于pivot的的尾（BT），(2)遍历单链表，将每个位置按照大小归到位置，第一个小于pivot放入SH，ST；第二个小于pivot放入ST，并用上一个小于的指向它，其他同理。(3)最后先讨论边界（哪块是否为null），最后用ST指向EH，ET指向BH。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListPartation</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> data<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//笔试</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">listPartation1</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Node</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//看链表有几个元素</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//创建列表</span>        <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nodeArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">//(1)把节点node放到列表中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> nodeArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nodeArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//(2)对列表做Partition(其中比较的是node的value)</span>        <span class="token function">arrPartition</span><span class="token punctuation">(</span>nodeArr<span class="token punctuation">,</span> pivot<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//(3)把达成要求的列表变成链表</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> nodeArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nodeArr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>next <span class="token operator">=</span> nodeArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        nodeArr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nodeArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">arrPartition</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nodeArr<span class="token punctuation">,</span> <span class="token keyword">int</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> small <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> big <span class="token operator">=</span> nodeArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">!=</span> big<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeArr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nodeArr<span class="token punctuation">,</span> <span class="token operator">++</span>small<span class="token punctuation">,</span> index<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeArr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">==</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nodeArr<span class="token punctuation">,</span> <span class="token operator">--</span>big<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nodeArr<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span> tmp <span class="token operator">=</span> nodeArr<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>        nodeArr<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> nodeArr<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>        nodeArr<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//面试</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">listPartition2</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//(1)</span>        <span class="token class-name">Node</span> sH <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span> sT <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span> eH <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span> eT <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span> bH <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span> bT <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span> next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">//用于向后移动链表</span>        <span class="token comment">//(2)</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>value <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sH <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    sH <span class="token operator">=</span> head<span class="token punctuation">;</span>                    sT <span class="token operator">=</span> head<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    sT<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>                    sT <span class="token operator">=</span> head<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>value <span class="token operator">==</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>eH <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    eH <span class="token operator">=</span> head<span class="token punctuation">;</span>                    eT <span class="token operator">=</span> head<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    eT<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>                    eT <span class="token operator">=</span> head<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>bH <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    bH <span class="token operator">=</span> head<span class="token punctuation">;</span>                    bT <span class="token operator">=</span> head<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    bT<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>                    bT <span class="token operator">=</span> head<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">//链表每次前移一步</span>            head <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//(3)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sT <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sT<span class="token punctuation">.</span>next <span class="token operator">=</span> eH<span class="token punctuation">;</span>            eT <span class="token operator">=</span> eT <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> sT <span class="token operator">:</span> eT<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eT <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            eT<span class="token punctuation">.</span>next <span class="token operator">=</span> bH<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//从小到大用头判断,哪个不为空传出哪个</span>        <span class="token keyword">return</span> sH <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> sH <span class="token operator">:</span> <span class="token punctuation">(</span>eH <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> eH <span class="token operator">:</span> bH<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复制含有随机指针节点的链表">23.复制含有随机指针节点的链表</h4><ul><li><p>题目：一种特殊的单链表节点类描述如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token class-name">Node</span> next<span class="token punctuation">;</span>    <span class="token class-name">Node</span> rand<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。</p></li><li><p>要求：时间复杂度O(N)，额外空间复杂度O(1)</p></li><li><p>笔试：利用哈希表</p></li><li><p>面试：利用克隆节点的位置关系</p><p>(1)将链表克隆，但克隆形式：1→1‘→2→2‘→3→3‘→null</p><p>(2)一对一对拿出，但仅考虑克隆体rand指针的设置，1的rand指针指向3，3的克隆为3的next，所以只需1‘指向3的next</p><p>(3)在next上把链表进行分离</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> copyListWithRand <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> value<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span> rand<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//笔试</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">copyListWithRand1</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">//遍历链表,复制每一个结点到哈希表的value中</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// cur:老链表, map.get(cur):新链表</span>            <span class="token comment">// 把新链表当前next指向的值指向老链表next指向的复制体</span>            map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">.</span>rand <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>rand<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//面试</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">copyListWithRand2</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Node</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">Node</span> next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">//(1)链表克隆, 1→1‘→2</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            cur <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token class-name">Node</span> curCopy <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">//(2)找rand指针</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">//next为原链表cur指向的下一个节点</span>            curCopy <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">//存放新的链表</span>            curCopy<span class="token punctuation">.</span>rand <span class="token operator">=</span> cur<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> cur<span class="token punctuation">.</span>rand<span class="token punctuation">.</span>next <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Node</span> res <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">//(3)将两个链表分离</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            curCopy <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            curCopy<span class="token punctuation">.</span>next <span class="token operator">=</span> next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> next<span class="token punctuation">.</span>next <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="两个单链表相交的一系列问题">24.两个单链表相交的一系列问题</h4><ul><li>题目：给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null</li><li>要求：如果两个链表长度之和为N，时间复杂度达到O(N)，额外空间复杂度请达到O(1)。</li></ul><p>(1)判断一个链表是否有环</p><p>额外空间：HashSet，将链表从head开始放到HashSet中，判断每个节点是否在HashSet中出现过</p><p>不用额外空间：快慢指针，第一次相遇会在环内，然后快指针回到head，重新开始快慢指针每次<strong>走一步</strong>，快慢指针会在入环节点相遇。</p><p>(2)得到两个链表的入环节点（loop1与loop2），分类讨论：</p><ul><li><code>loop1 == null,loop2 == null</code>（两个单链表都是无环的情况）<ul><li>先遍历两个链表，得到链表尾end1和end2以及长度len1与len2</li><li>然后判断end1和end2地址是否一致，不一致则没有相交，一致则长链表先走差值步，然后短链表跟着走，最后两个链表一定会在第一个相交节点处相遇</li></ul></li><li>loop1和loop2有一个为null，有一个不为null，此时两个链表不可能相交</li><li>loop1和loop2都有环<ul><li>两个链表先相交再共同入环（<code>loop1==loop2</code>），则把入环节点当成end，再按两个节点都无环讨论</li><li>loop1继续走，如果在转回自己的过程中：<ul><li>没有遇到loop2，则没有相交</li><li>遇到loop2，则有相交，则返回loop1或loop2都可以</li></ul></li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FindFirstIntersectNode</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> data<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断是否有环,并返回入环的第一个节点</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">getLoopNode</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">==</span>  <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span>  <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Node</span> n1 <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment">//慢指针</span>        <span class="token class-name">Node</span> n2 <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>   <span class="token comment">//快指针</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n1 <span class="token operator">!=</span> n2<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//无环</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>n2<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            n2 <span class="token operator">=</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            n1 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        n2 <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n1 <span class="token operator">!=</span> n2<span class="token punctuation">)</span><span class="token punctuation">{</span>            n1 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            n2 <span class="token operator">=</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> n1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">//两个单链表都是无环的情况</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">noLoop</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head1<span class="token punctuation">,</span><span class="token class-name">Node</span> head2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Node</span> cur1 <span class="token operator">=</span> head1<span class="token punctuation">;</span>        <span class="token class-name">Node</span> cur2 <span class="token operator">=</span> head2<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur1<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            n<span class="token operator">++</span><span class="token punctuation">;</span>            cur1 <span class="token operator">=</span> cur1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur2<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            n<span class="token operator">--</span><span class="token punctuation">;</span>            cur2 <span class="token operator">=</span> cur2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur1 <span class="token operator">!=</span> cur2<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cur1 <span class="token operator">=</span> n <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> head1 <span class="token operator">:</span> head2<span class="token punctuation">;</span> <span class="token comment">//找到长链表</span>        cur2 <span class="token operator">=</span> cur1 <span class="token operator">==</span> head1 <span class="token operator">?</span> head2 <span class="token operator">:</span> head1<span class="token punctuation">;</span> <span class="token comment">//找到短链表</span>        n <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            n<span class="token operator">--</span><span class="token punctuation">;</span>            cur1 <span class="token operator">=</span> cur1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur1 <span class="token operator">!=</span> cur2<span class="token punctuation">)</span><span class="token punctuation">{</span>            cur1 <span class="token operator">=</span> cur1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur2 <span class="token operator">=</span> cur2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cur1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//loop1和loop2都有环</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">bothLoop</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head1<span class="token punctuation">,</span><span class="token class-name">Node</span> loop1<span class="token punctuation">,</span><span class="token class-name">Node</span> head2<span class="token punctuation">,</span><span class="token class-name">Node</span> loop2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Node</span> cur1 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span> cur2 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">//两个链表先相交再共同入环</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loop1 <span class="token operator">==</span> loop2<span class="token punctuation">)</span><span class="token punctuation">{</span>            cur1 <span class="token operator">=</span> head1<span class="token punctuation">;</span>            cur2 <span class="token operator">=</span> head2<span class="token punctuation">;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>cur1 <span class="token operator">!=</span> loop1<span class="token punctuation">)</span><span class="token punctuation">{</span>                n<span class="token operator">++</span><span class="token punctuation">;</span>                cur1 <span class="token operator">=</span> cur1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>cur2 <span class="token operator">!=</span> loop2<span class="token punctuation">)</span><span class="token punctuation">{</span>                n<span class="token operator">--</span><span class="token punctuation">;</span>                cur2 <span class="token operator">=</span> cur2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur1 <span class="token operator">=</span> n <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> head1 <span class="token operator">:</span> head2<span class="token punctuation">;</span>            cur2 <span class="token operator">=</span> cur1 <span class="token operator">==</span> head1 <span class="token operator">?</span> head2 <span class="token operator">:</span> head1<span class="token punctuation">;</span>            n <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                cur1 <span class="token operator">=</span> cur1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>cur1 <span class="token operator">!=</span> cur2<span class="token punctuation">)</span><span class="token punctuation">{</span>                cur1 <span class="token operator">=</span> cur1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                cur2 <span class="token operator">=</span> cur2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> cur1<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">//loop1继续走,如果在转回自己的过程中</span>            cur1 <span class="token operator">=</span> loop1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">!=</span> loop1<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">//遇到loop2,则有相交,则返回loop1或loop2都可以</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cur1 <span class="token operator">==</span> loop2<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> loop1<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                cur1 <span class="token operator">=</span> cur1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//主函数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">getIntersectNode</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head1<span class="token punctuation">,</span><span class="token class-name">Node</span> head2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Node</span> loop1 <span class="token operator">=</span> <span class="token function">getLoopNode</span><span class="token punctuation">(</span>head1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span> loop2 <span class="token operator">=</span> <span class="token function">getLoopNode</span><span class="token punctuation">(</span>head2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loop1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> loop2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">noLoop</span><span class="token punctuation">(</span>head1<span class="token punctuation">,</span> head2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loop1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> loop2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">bothLoop</span><span class="token punctuation">(</span>head1<span class="token punctuation">,</span> loop1<span class="token punctuation">,</span> head2<span class="token punctuation">,</span> loop2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二叉树">25.二叉树</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>    <span class="token class-name">V</span> value<span class="token punctuation">;</span>    <span class="token class-name">Node</span> left<span class="token punctuation">;</span>    <span class="token class-name">Node</span> right<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>用递归和非递归两种方式实现二叉树的先序、中序、后序遍历</p><ul><li><p>递归序</p><ul><li><p>先序（头左右）：递归序里第一次出现的</p></li><li><p>中序（左头右）：递归序里第二次出现的</p></li><li><p>后序（左右头）：递归序里第三次出现的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//先序</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">preOrderRecur</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preOrderRecur</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preOrderRecur</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//中序</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">inOrderRecur</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">inOrderRecur</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inOrderRecur</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//后序</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">posOrderRecur</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">posOrderRecur</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">posOrderRecur</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>非递归序</p><ul><li><p>先序（深度优先遍历）</p><ol type="1"><li><p>先将头节点弹入栈</p></li><li><p>每次：</p><ol type="1"><li><p>从栈中弹出一个节点cur</p></li><li><p>打印（处理）cur</p></li><li><p>先右孩子，再左孩子压入栈（如果有）</p></li><li><p>循环</p></li></ol></li></ol></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">preOrderUnRecur</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//头节点弹入栈</span>        stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//从栈中弹出一个节点cur</span>            head <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//打印cur</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//先右孩子,再左孩子压入栈</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>中序：把整棵子树的<strong>左边界</strong>都压入栈中，在依次弹出每一个节点的过程中，打印，然后对弹出节点的右树也这么做</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">inOrderUnRecur</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">// 把整棵子树的左边界都压入栈中</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>                head <span class="token operator">=</span> head<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                head <span class="token operator">=</span> head<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>后序<ul><li>先序的基础上，先左后右压入栈，并创建一个收集栈，每次栈弹出时，将cur放入收集栈，等全部结束弹出收集栈</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">posOrderUnRecur</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//头节点弹入栈</span>        s1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>s1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            head <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            s2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//先左孩子,再右孩子压入栈</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                s1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                s1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>s2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>如何直观的打印一颗二叉树</p></li><li><p>如何完成二叉树的宽度优先遍历</p><ul><li>队列：先放进头节点，然后先放左后放右</li></ul></li><li><p>求一棵二叉树的宽度</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">w</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> levelMap <span class="token operator">=</span> <span class="token keyword">new</span> hashMap<span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    levelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>head，<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> curLevel <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> curLevelNodes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Node</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> curNodeLevel <span class="token operator">=</span> levelMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>curNodeLevel <span class="token operator">==</span> curLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>            curLevelNodes<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span>curLevelNodes<span class="token punctuation">)</span><span class="token punctuation">;</span>            curLevel<span class="token operator">++</span><span class="token punctuation">;</span>            curLevelNodes <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            levelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span>curNodeLevel<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            levelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span>curNodeLevel<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span>curLevelNodes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="如何判断一棵树是否是搜索二叉树">26.如何判断一棵树是否是搜索二叉树？</h4><p>搜索二叉树：对于任何一棵子树，其左树都比他小，右树都比他大</p><p>判断方式：中序遍历，如果总是在升序，则为搜索二叉树</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> preValue <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isBST</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> isLeftBst <span class="token operator">=</span> <span class="token function">isBST</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>isLeftBst<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> preValue<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        preValue <span class="token operator">=</span> head<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">isBST</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isBST</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> preValue <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span>                <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">// 把整棵子树的左边界都压入栈中</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>                head <span class="token operator">=</span> head<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> preValue<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    preValue <span class="token operator">=</span> head<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                head <span class="token operator">=</span> head<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//递归套路</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isBST</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">processBST</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">.</span>isBST<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ReturnTypeBST</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> isBST<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> maxValue<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> minValue<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">ReturnTypeBST</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isB<span class="token punctuation">,</span><span class="token keyword">int</span> max<span class="token punctuation">,</span><span class="token keyword">int</span> min<span class="token punctuation">)</span><span class="token punctuation">{</span>            isBST <span class="token operator">=</span> isB<span class="token punctuation">;</span>            maxValue <span class="token operator">=</span> max<span class="token punctuation">;</span>            minValue <span class="token operator">=</span> min<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ReturnTypeBST</span> <span class="token function">processBST</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">ReturnTypeBST</span> leftData <span class="token operator">=</span> <span class="token function">processBST</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ReturnTypeBST</span> rightData <span class="token operator">=</span> <span class="token function">processBST</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> x<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token keyword">int</span> minValue <span class="token operator">=</span> x<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftData <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            minValue <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minValue<span class="token punctuation">,</span> leftData<span class="token punctuation">.</span>minValue<span class="token punctuation">)</span><span class="token punctuation">;</span>            maxValue <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxValue<span class="token punctuation">,</span> leftData<span class="token punctuation">.</span>maxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rightData <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            minValue <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minValue<span class="token punctuation">,</span> rightData<span class="token punctuation">.</span>minValue<span class="token punctuation">)</span><span class="token punctuation">;</span>            maxValue <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxValue<span class="token punctuation">,</span> rightData<span class="token punctuation">.</span>maxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">boolean</span> isBST <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>leftData <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>leftData<span class="token punctuation">.</span>isBST <span class="token operator">||</span> leftData<span class="token punctuation">.</span>maxValue <span class="token operator">&gt;=</span> x<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            isBST <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rightData <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>rightData<span class="token punctuation">.</span>isBST <span class="token operator">||</span> rightData<span class="token punctuation">.</span>minValue <span class="token operator">&lt;=</span> x<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            isBST <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ReturnTypeBST</span><span class="token punctuation">(</span>isBST<span class="token punctuation">,</span> maxValue<span class="token punctuation">,</span> minValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="如何判断一棵树是否是完全二叉树">27.如何判断一棵树是否是完全二叉树？</h4><p>完全二叉树：每一层都是满的，最后一层即使不满也是从左向右填充的</p><p>判断方式：按宽度遍历，分以下情况：</p><p>（1）任意节点没左孩子，有右孩子——返回false；</p><p>（2）在满足（1）的情况下，第一次遇到左右两个孩子不双全的情况，那么接下来遇到的所有节点都必须是叶节点。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isCBT</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//用于判断是否遇到过两个孩子不双全的节点</span>        <span class="token keyword">boolean</span> leaf <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span> l <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span> r <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            head <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            l <span class="token operator">=</span> head<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            r <span class="token operator">=</span> head<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token comment">//发现左右孩子不双全的节点后,又发现当前节点还有孩子节点 || 有右无左,返回false</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>                    <span class="token punctuation">(</span>leaf <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>l <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//找到第一个左右孩子不双全的节点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> r <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                leaf <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="如何判断一棵树是否是满二叉树">28.如何判断一棵树是否是满二叉树？</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isF</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">ReturnTypeF</span> data <span class="token operator">=</span> <span class="token function">processF</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> data<span class="token punctuation">.</span>nodes <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> data<span class="token punctuation">.</span>height <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ReturnTypeF</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> height<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> nodes<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ReturnTypeF</span><span class="token punctuation">(</span><span class="token keyword">int</span> hei<span class="token punctuation">,</span><span class="token keyword">int</span> nod<span class="token punctuation">)</span><span class="token punctuation">{</span>        height <span class="token operator">=</span> hei<span class="token punctuation">;</span>        nodes <span class="token operator">=</span> nod<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ReturnTypeF</span> <span class="token function">processF</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ReturnTypeF</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">ReturnTypeF</span> leftData <span class="token operator">=</span> <span class="token function">processF</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ReturnTypeF</span> rightData <span class="token operator">=</span> <span class="token function">processF</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> height <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftData<span class="token punctuation">.</span>height<span class="token punctuation">,</span> rightData<span class="token punctuation">.</span>height<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> nodes <span class="token operator">=</span> leftData<span class="token punctuation">.</span>nodes <span class="token operator">+</span> rightData<span class="token punctuation">.</span>nodes <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ReturnTypeF</span><span class="token punctuation">(</span>height<span class="token punctuation">,</span> nodes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="如何判断一棵树是否是平衡二叉树">29.如何判断一棵树是否是平衡二叉树？</h4><p>平衡二叉树：对于任意一棵子树，左树的高度和右树的高度差都不超过1</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">.</span>isBalanced<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ReturnType</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> isBalanced<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> height<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">ReturnType</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isB<span class="token punctuation">,</span> <span class="token keyword">int</span> hei<span class="token punctuation">)</span><span class="token punctuation">{</span>            isBalanced <span class="token operator">=</span> isB<span class="token punctuation">;</span>            height <span class="token operator">=</span> hei<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ReturnType</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ReturnType</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">ReturnType</span> leftData <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ReturnType</span> rightData <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> height <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftData<span class="token punctuation">.</span>height<span class="token punctuation">,</span> rightData<span class="token punctuation">.</span>height<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> isBalanced <span class="token operator">=</span> leftData<span class="token punctuation">.</span>isBalanced <span class="token operator">&amp;&amp;</span> rightData<span class="token punctuation">.</span>isBalanced <span class="token operator">&amp;&amp;</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>leftData<span class="token punctuation">.</span>height <span class="token operator">-</span> rightData<span class="token punctuation">.</span>height<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ReturnType</span><span class="token punctuation">(</span>isBalanced<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="给定两个二叉树的节点node1和node2找到他们的最低公共祖先节点">30.给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">lowestCommonAncestor1</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">,</span><span class="token class-name">Node</span> o1<span class="token punctuation">,</span><span class="token class-name">Node</span> o2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> fatherMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fatherMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> fatherMap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> set1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Node</span> cur <span class="token operator">=</span> o1<span class="token punctuation">;</span>        <span class="token comment">//当节点不等于自己的父节点,o1直接向上蹿</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> fatherMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            set1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> fatherMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        set1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//o2每蹿一步判断一下</span>        <span class="token class-name">Node</span> cur2 <span class="token operator">=</span> o2<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur2 <span class="token operator">!=</span> fatherMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>set1<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>cur2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> cur2<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur2 <span class="token operator">=</span> fatherMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">,</span><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> fatherMap<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        fatherMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>        fatherMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">,</span> fatherMap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">,</span>fatherMap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">lowestAncestor</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">,</span> <span class="token class-name">Node</span> o1<span class="token punctuation">,</span> <span class="token class-name">Node</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head <span class="token operator">==</span> o1 <span class="token operator">||</span> head <span class="token operator">==</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// base case</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token class-name">Node</span> left <span class="token operator">=</span> <span class="token class-name">LowestAncestor</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">,</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Node</span> right <span class="token operator">=</span> <span class="token class-name">LowestAncestor</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">,</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//o1和o2不互相为最低公共祖先,需要向上才能找到</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//两棵树里并不是都有返回值</span><span class="token keyword">return</span> left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> left <span class="token operator">:</span> right<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="在二叉树中找到一个节点的后继节点">31.在二叉树中找到一个节点的后继节点</h4><p>现在有一种新的二叉树节点类型如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Node</span> left<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Node</span> parent<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    value <span class="token operator">=</span> val<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该结构比普通二叉树节点结构多了一个指向父节点的parent指针。</p><p>假设有一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向自己的父节点，头节点的parent指向null。</p><p>只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。</p><p>在二叉树的中序遍历的序列中，node的下一个节点叫作node的后继节点。</p><ul><li>如果x有右树，则其后继节点为x右树上的最左节点</li><li>x无右树，则其后继节点为x向上找的父节点中是左孩子的节点</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">getSuccessorNode</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//x有右树,则其后继节点为x右树上的最左节点</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getLeftMost</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment">//x无右树,则其后继节点为x向上找的父节点中是左孩子的节点</span>        <span class="token class-name">Node</span> parent <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>left <span class="token operator">!=</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>            node <span class="token operator">=</span> parent<span class="token punctuation">;</span>            parent <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">getLeftMost</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二叉树的序列化和反序列化">32.二叉树的序列化和反序列化</h4><p>内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的树</p><p>如何判断一颗二叉树是不是另一棵二叉树的子树？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">serialByPre</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"#_"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">String</span> res <span class="token operator">=</span> head<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">"_"</span><span class="token punctuation">;</span>    res <span class="token operator">+=</span> <span class="token function">serialByPre</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    res <span class="token operator">+=</span> <span class="token function">serialByPre</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">reconByPreString</span><span class="token punctuation">(</span><span class="token class-name">String</span> preStr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span>preStr<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">!=</span> values<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">reconPreOrder</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">reconPreOrder</span><span class="token punctuation">(</span><span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> queue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">String</span> value <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">Node</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">reconPreOrder</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    head<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">reconPreOrder</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="图的表达">33.图的表达</h4><p>图的存储方式</p><p>1.邻接表</p><p>2.邻接矩阵</p><p>如何表达图？生成图？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Graph</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> nodes<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> edges<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        edges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> in<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> out<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> nexts<span class="token punctuation">;</span>   <span class="token comment">//由Node发散出去的边</span>    <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> edges<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        in <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        out <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        nexts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        edges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Edge</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> weight<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> from<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token keyword">to</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> weight<span class="token punctuation">,</span><span class="token class-name">Node</span> from<span class="token punctuation">,</span><span class="token class-name">Node</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">=</span> from<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">to</span> <span class="token operator">=</span> <span class="token keyword">to</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="图的宽度优先遍历">34.图的宽度优先遍历</h4><p>1.利用队列实现</p><p>2.从源节点开始依次按照宽度进队列，然后弹出</p><p>3.每弹出一个点，把该节点所有没有进过队列的邻接点放入队列</p><p>4.直到队列变空</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//防止重复加入</span>    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//出发点加入</span>    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Node</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Node</span> next <span class="token operator">:</span> cur<span class="token punctuation">.</span>nexts<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="图的广度优先遍历">35.图的广度优先遍历</h4><p>1.利用栈实现</p><p>2.从源节点开始把节点按照深度放入栈，然后弹出</p><p>3.每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈</p><p>4.直到栈变空</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//防止重复加入</span>        stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">Node</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Node</span> next<span class="token operator">:</span> cur<span class="token punctuation">.</span>nexts<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>                    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="图的拓扑排序算法">36.图的拓扑排序算法</h4><p>适用范围：要求有向图，且有入度为0的节点，且没有环</p><p>以此找入度为0的点，然后把和他有关的影响都删掉</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> <span class="token function">sortedTopology</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> graph<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> inMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//key:Node,value:剩余的入度</span>       <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> zeroInQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node <span class="token operator">:</span> graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           inMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> node<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//找到第一批入度为0的点</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>in <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               zeroInQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span>       <span class="token comment">//结果</span>       <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>zeroInQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token comment">//弹出入度为0的点,加到result中</span>           <span class="token class-name">Node</span> cur <span class="token operator">=</span> zeroInQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//擦掉影响,把和cur有关的所有节点入度-1</span>           <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Node</span> next <span class="token operator">:</span> cur<span class="token punctuation">.</span>nexts<span class="token punctuation">)</span><span class="token punctuation">{</span>               inMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> inMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//发现有节点入度减少为0了,加入zeroInQueue中</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>inMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                   zeroInQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> result<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="kruskal算法最小生成树">37.kruskal算法（最小生成树）</h4><p>适用范围：无向图</p><p>每次取权重最小的边，看是否生成环（开始时每个点放到一个集合里，每次加边的时候看新加入的节点和原来节点是否在一个集合中，没在一个集合就说明没有环，就把两个点合成一个集合）。生成环了就不要了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">EdgeComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Edge</span> o1<span class="token punctuation">,</span><span class="token class-name">Edge</span> o2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> o1<span class="token punctuation">.</span>weight <span class="token operator">-</span> o2<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> <span class="token function">kruskalMST</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> graph<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">UnionFind</span> unionFind <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnionFind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    unionFind<span class="token punctuation">.</span><span class="token function">makeSets</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//通过比较器实现每次选择最小权重的边</span>    <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> priorityQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EdgeComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> edge <span class="token operator">:</span> graph<span class="token punctuation">.</span>edges<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//M条边</span>        priorityQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// O(logM)</span>    <span class="token punctuation">}</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>priorityQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//M条边</span>        <span class="token class-name">Edge</span> edge <span class="token operator">=</span> priorityQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//O(logM)</span>        <span class="token comment">//每次弹出时判断from和to是不是在一个集合里</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>unionFind<span class="token punctuation">.</span><span class="token function">isSameSet</span><span class="token punctuation">(</span>edge<span class="token punctuation">,</span>from<span class="token punctuation">,</span> edge<span class="token punctuation">,</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//O(1)</span>            <span class="token comment">//不在一起,把边加入集合,并把两个集合合并</span>            result<span class="token punctuation">,</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">)</span><span class="token punctuation">;</span>            unionFind<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>from<span class="token punctuation">,</span> edge<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="prim算法最小生成树">38.prim算法（最小生成树）</h4><p>适用范围：无向图</p><p>任选一个起始点，解锁他对应的边，选择权重最小的边，拽进对应的点，然后再解锁相应的边，再从<strong>所有</strong>被解锁的边中选择最小的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">EdgeComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Edge</span> o1<span class="token punctuation">,</span><span class="token class-name">Edge</span> o2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> o1<span class="token punctuation">.</span>weight <span class="token operator">-</span> o2<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> <span class="token function">primMST</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> graph<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//解锁的边进入小根堆</span>    <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> priorityQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EdgeComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//依次挑选的边在result中</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node <span class="token operator">:</span> graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//随机挑点,node为开始点</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> edge <span class="token operator">:</span> node<span class="token punctuation">.</span>edges<span class="token punctuation">)</span><span class="token punctuation">{</span>                    priorityQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//选择node对应边中按照从小到大的顺序加入</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>priorityQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token class-name">Edge</span> edge <span class="token operator">=</span> priorityQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//弹出解锁的边中最小的边</span>                <span class="token class-name">Node</span> toNode <span class="token operator">=</span> edge<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">;</span> <span class="token comment">//边对应一些点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>toNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//这个点是新的点</span>                    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>toNode<span class="token punctuation">)</span><span class="token punctuation">;</span>                    result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> nextEdge <span class="token operator">:</span> toNode<span class="token punctuation">.</span>edges<span class="token punctuation">)</span><span class="token punctuation">{</span>                        priorityQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nextEdge<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="dijkstra算法单元最短路径算法">39.Dijkstra算法（单元最短路径算法）</h4><p>适用范围：可以有为负数的边，但是不能有累加和为负数的环</p><p>规定一个出发点，计算从这个点到其余所有点的距离最小</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">getMinDistanceAndUnselectedNode</span><span class="token punctuation">(</span><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> distanceMap<span class="token punctuation">,</span><span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> torchedNodes<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">Node</span> minNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> minDistance <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> distanceMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Node</span> node <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> distance <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果距离比最小距离小,且这个点不是已经使用过的点,则让最小距离变成当前距离,并把node对应上</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>torchedNodes<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> distance <span class="token operator">&lt;</span>minDistance<span class="token punctuation">)</span><span class="token punctuation">{</span>            minNode <span class="token operator">=</span> node<span class="token punctuation">;</span>            minDistance <span class="token operator">=</span> distance<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> minNode<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">diskstra</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 从head出发到所有点的最小距离</span>    <span class="token comment">// key:从head出发到达key</span>    <span class="token comment">// value:从head出发到达key的最小距离</span>    <span class="token comment">// 如果在表中,没有T的记录,含义是从head出发到T这个点的距离为正无穷</span>    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> distanceMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//把当前节点到自己的距离为0加入</span>    distanceMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//已经求过距离的节点放入selectedNodes中,以后再也不碰</span>    <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> selectedNodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//从distanceMap中找到最小的记录,但是这个记录不能是selectedNodes中的</span>    <span class="token class-name">Node</span> minNode <span class="token operator">=</span> <span class="token function">getMinDistanceAndUnselectedNode</span><span class="token punctuation">(</span>distanceMap<span class="token punctuation">,</span>selectedNodes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//直到都在selectedNodes中,导致distanceMap无节点可选了,就停止循环</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>minNode <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> distance <span class="token operator">=</span> distanceMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>minNode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//原节点到当前minNode的距离</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Edge</span> edge <span class="token operator">:</span> minNode<span class="token punctuation">.</span>edges<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">Node</span> toNode <span class="token operator">=</span> edge<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">;</span>            <span class="token comment">//如果toNode(当前minNode连接的点)在distanceMap中没找到记录,则更新每个边和minNode连接的权重</span>            <span class="token comment">//没路加路</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>distanceMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>toNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                distanceMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>toNode<span class="token punctuation">,</span> distance <span class="token operator">+</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//新增后需要判断toNode的点之前的距离和现在的距离哪个小</span>            <span class="token comment">//有路更新</span>            distanceMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>distanceMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>toNode<span class="token punctuation">)</span><span class="token punctuation">,</span> distance <span class="token operator">+</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//处理完当前节点,把他锁入selectedNodes</span>        selectedNodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>minNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//再从没被锁的里面找到最小距离的点</span>        minNode <span class="token operator">=</span> <span class="token function">getMinDistanceAndUnselectedNode</span><span class="token punctuation">(</span>distanceMap<span class="token punctuation">,</span> selectedNodes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> distanceMap<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Dijkstra算法改进：手动改写堆</p><h4 id="前缀树trie树">40.前缀树（Trie树）</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> pass<span class="token punctuation">;</span> <span class="token comment">//节点被走过几次</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span> <span class="token comment">//以该节点为字符串终点的次数</span>    <span class="token keyword">public</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nexts<span class="token punctuation">;</span>    <span class="token comment">//走向每个字母的路</span>    <span class="token comment">//如果不是字母表示字符,可以创建HashMap&lt;Char,Node&gt; nexts;</span>    <span class="token comment">//如果希望下级的路是有序的方式,可以创建TreeMap&lt;Char,Node&gt; nexts;</span>    <span class="token keyword">public</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pass <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        nexts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">{</span>    <span class="token comment">//头节点</span>    <span class="token keyword">private</span> <span class="token class-name">TrieNode</span> root<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//加入一个字符串</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TrieNode</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>pass<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//遍历字符串</span>            index <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span> <span class="token comment">//判断走哪个字母的路</span>            <span class="token comment">//查询是否有走向当前字母的路,如果路不存在,则新建节点连上路</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//否则走到字符串字母对应的节点,pass+</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>pass<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//把终止节点的end+</span>        node<span class="token punctuation">.</span>end<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//查询word这个单词之前加入了几次</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TrieNode</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            index <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token comment">//如果这个边没有能找到的节点,则说明这个word没有被加入过</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//如果有节点就走到头,结尾的end值就是word出现的次数</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> node<span class="token punctuation">.</span>end<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//所有加入的字符串中,有几个是以pre这个字符串作为前缀的</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">prefixNumber</span><span class="token punctuation">(</span><span class="token class-name">String</span> pre<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> pre<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">TrieNode</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            index <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> node<span class="token punctuation">.</span>pass<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">search</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">TrieNode</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span>            node<span class="token punctuation">.</span>pass<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                index <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>                <span class="token comment">//把沿途每个node对应的pass--</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>pass <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token comment">//如果pass减到0说明这个节点没有用了,则把节点所有内容都释放掉</span>                    node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                node <span class="token operator">=</span> node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//把最后一个node的end--</span>            node<span class="token punctuation">.</span>end<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="贪心算法">41.贪心算法</h4><p>在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的算法，叫作贪心算法。也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解。</p><p>局部最优 -?-&gt; 整体最优</p><p><strong>贪心算法的在笔试时的解题套路：</strong></p><p>1.实现一个不依靠贪心策略的解法X，可以用最暴力的尝试</p><p>2.脑补出贪心策略A、贪心策略B、贪心策略C...</p><p>3.用解法X和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确</p><p>4.不要去纠结贪心策略的证明</p><p><strong>贪心策略在实现时，经常使用到的技巧：</strong></p><p>1.根据某标准建立一个比较器来排序</p><p>2.根据某标准建立一个比较器来组成堆</p><h4 id="会议室问题">42.会议室问题</h4><p>一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间(给你一个数组，里面是一个个具体的项目)，你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。返回这个最多的宣讲场次</p><p>思路：看哪个项目结束时间最早</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ProgramComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Program</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Program</span> o1<span class="token punctuation">,</span><span class="token class-name">Program</span> o2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> o1<span class="token punctuation">.</span>end <span class="token operator">-</span> o2<span class="token punctuation">.</span>end<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">bestArrange</span><span class="token punctuation">(</span><span class="token class-name">Program</span><span class="token punctuation">[</span><span class="token punctuation">]</span> programs<span class="token punctuation">,</span><span class="token keyword">int</span> timePoint<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>programs<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ProgramComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//从左往右依次遍历所有会议</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>programs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>timePoint <span class="token operator">&lt;=</span> programs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>start<span class="token punctuation">)</span><span class="token punctuation">{</span>            result<span class="token operator">++</span><span class="token punctuation">;</span>            timePoint <span class="token operator">=</span> programs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>end<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="切金条问题">43.切金条问题</h4><p>一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管切成长度多大的两半，都要花费20个铜板。</p><p>一群人想整分整块金条，怎么分最省铜板？例如,给定数组[10,20,30]，代表一共三个人，整块金条长度为10+20+30=60。金条要分成10,20,30三个部分。<br>如果先把长度60的金条分成10和50，花费60；再把长度50的金条分成20和30，花费50；一共花费110铜板。<br>但是如果先把长度60的金条分成30和30，花费60；再把长度30金条分成10和20花费30；一共花费90铜板。</p><p>输入一个数组，返回分割的最小代价。</p><p>思路：把所有的数放到小根堆里，每一次弹出两个数做结合，再将结合的数字放到小根堆中；重复这个过程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">lessMemory</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> pQ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        pQ<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>pQ<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cur <span class="token operator">=</span> pQ<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> pQ<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">+=</span> cur<span class="token punctuation">;</span>        pQ<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="项目利润问题">44.项目利润问题</h4><ul><li><p>输入：</p><ul><li>正数数组costs</li><li>正数数组profits</li><li>正数k</li><li>正数m</li></ul></li><li><p>含义：</p><ul><li><p>costs[i]表示i号项目的花费</p></li><li><p>profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润)</p></li><li><p>k表示你只能串行的最多做k个项目</p></li><li><p>m表示你初始的资金</p></li></ul></li><li><p>说明：你每做完一个项目，马上获得的收益，可以支持你去做下一个项目</p></li><li><p>输出：你最后获得的最大钱数。</p></li></ul><p>思路：把所有项目按照花费放进小根堆，每次把小于自己的资金的项目从小根堆弹出，按利润放入大根堆，然后弹出一个，就做这个项目。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MinCostComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Node</span> o1<span class="token punctuation">,</span><span class="token class-name">Node</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> o1<span class="token punctuation">.</span>p <span class="token operator">-</span> o2<span class="token punctuation">.</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MaxProfitComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Node</span> o1<span class="token punctuation">,</span><span class="token class-name">Node</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> o2<span class="token punctuation">.</span>p <span class="token operator">-</span> o1<span class="token punctuation">.</span>p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">findMaximizedCapital</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">W</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">Profits</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">Capital</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> minCostQ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MinCostComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> maxProfitQ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MaxProfitComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 所有项目扔到被锁池中，花费组织的小根堆</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token class-name">Profits</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        minCostQ<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Profits</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token class-name">Capital</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//进行K轮</span>        <span class="token comment">//能力所及的项目,全解锁</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>minCostQ<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> minCostQ<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>c <span class="token operator">&lt;=</span> <span class="token class-name">W</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            maxProfitQ<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>minCostQ<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxProfitQ<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token class-name">W</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">W</span> <span class="token operator">+=</span> maxProfitQ<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token class-name">W</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="一个数据流中随时可以取得中位数">45.一个数据流中，随时可以取得中位数</h4><p>准备一个大根堆和一个小根堆</p><p>先看当前给的数字是否是&lt;=大根堆的堆顶的，如果是，当前数字入大根堆；否则入小根堆；</p><p>看看大根堆和小根堆大小，如果较大的堆个数 比 较小堆的个数超过了2，较大堆顶弹出进入较小的当中</p><h4 id="n皇后问题">46.N皇后问题</h4><p>N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列，也不在同一条斜线上。给定一个整数n，返回n皇后的摆法有多少种。</p><p>n=1，返回1。 n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0。n=8，返回92。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NQueens</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">num1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//每行的皇后放在了哪一列</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> record <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//record[i]:第i行的皇后,放在了第几列</span>        <span class="token keyword">return</span> <span class="token function">process1</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> record<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//record[0..i-1]的皇后一定不共行,不共列,不共斜线</span>    <span class="token comment">//i:目前来到了第几行,record[0..i-1]:之前的行放过哪些皇后,n:整体一共多少行,返回值:摆完合法的皇后,合理的摆法有多少种</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> record<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//终止行</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">//说明找到了一种合法的</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//当前行永远在i行,尝试i行所有的列 -&gt; j</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>record<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//检查是否冲突</span>                record<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>  <span class="token comment">//如果没有冲突,则说明本行找到了,转到下一行接着找</span>                res <span class="token operator">+=</span> <span class="token function">process1</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> record<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//找遍所有行,如果有一个满足条件的则res++</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//检查record[0..i-1]</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> record<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> k<span class="token operator">&lt;</span> i <span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//之前k行的某个皇后</span>            <span class="token comment">//和之前的某个皇后:列共值 || 斜率45°(当前要放皇后的点列坐标绝对值和行坐标绝对值一致)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span>record<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>record<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-</span> j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>i<span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常数优化版本（使用位运算）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NQueens</span> <span class="token punctuation">{</span>    <span class="token comment">//不能超过32皇后问题,超过需要把int -&gt; long</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">num2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">&gt;</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//申请一个后n位为1,前面都是0的数</span>        <span class="token keyword">int</span> limit <span class="token operator">=</span> n <span class="token operator">==</span> <span class="token number">32</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">process2</span><span class="token punctuation">(</span>limit<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//colLim:列限制,1的位置不能放皇后,0可以</span>    <span class="token comment">//leftDiaLim:左斜线限制,1的位置不能放皇后,0可以</span>    <span class="token comment">//rightDiaLim:右斜线限制,1的位置不能放皇后,0可以</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process2</span><span class="token punctuation">(</span><span class="token keyword">int</span> limit<span class="token punctuation">,</span> <span class="token keyword">int</span> colLim<span class="token punctuation">,</span> <span class="token keyword">int</span> leftDiaLim<span class="token punctuation">,</span> <span class="token keyword">int</span> rightDiaLim <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>colLim <span class="token operator">==</span> limit<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//相当于所有列都有皇后了</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//所有可以填皇后的位置(pos上为1的表示可以放皇后的位置).或运算,找到总限制</span>        <span class="token keyword">int</span> pos <span class="token operator">=</span> limit <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>colLim <span class="token operator">|</span> leftDiaLim <span class="token operator">|</span> rightDiaLim<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mostRightOne <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            mostRightOne <span class="token operator">=</span> pos <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//提取出候选皇后中最右侧的1</span>            pos <span class="token operator">=</span> pos <span class="token operator">-</span> mostRightOne<span class="token punctuation">;</span> <span class="token comment">//把他从候选皇后中减掉</span>            <span class="token comment">//更新下一行的列限制与左右皇后限制</span>            res <span class="token operator">+=</span> <span class="token function">process2</span><span class="token punctuation">(</span>limit<span class="token punctuation">,</span> colLim <span class="token operator">|</span> mostRightOne <span class="token punctuation">,</span> <span class="token punctuation">(</span>leftDiaLim <span class="token operator">|</span> mostRightOne<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span>rightDiaLim <span class="token operator">|</span> mostRightOne<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="暴力递归">47.暴力递归</h4><ul><li>把问题转化为规模缩小了的同类问题的子问题</li><li>有明确的不需要继续进行递归的条件(base case)</li><li>有当得到了子问题的结果之后的决策过程</li><li>不记录每一个子问题的解</li></ul><h4 id="汉诺塔问题">48.汉诺塔问题</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">String</span> start<span class="token punctuation">,</span> <span class="token class-name">String</span> end<span class="token punctuation">,</span> <span class="token class-name">String</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Move 1 from "</span> <span class="token operator">+</span> start <span class="token operator">+</span> <span class="token string">" to "</span> <span class="token operator">+</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>           <span class="token comment">// i~i-1:从start移动到other</span>           <span class="token function">func</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> other<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//i:从start移到end</span>           <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Move "</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">" from "</span> <span class="token operator">+</span> start <span class="token operator">+</span> <span class="token string">" to "</span> <span class="token operator">+</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// i~i-1:从other移到end</span>           <span class="token function">func</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> other<span class="token punctuation">,</span> end<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="打印一个字符串的全部子序列包括空字符串">49.打印一个字符串的全部子序列，包括空字符串</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printAllSubsquence</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">process1</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">process2</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">process1</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>chs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">process1</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//要的路</span>    <span class="token keyword">char</span> tmp <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//要以后,记录下当前字符</span>    chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//先变成0,保证不会选这条路</span>    <span class="token function">process1</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//不要的路</span>    chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>   <span class="token comment">//再塞回去</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">process2</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span> str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> resKeep <span class="token operator">=</span> <span class="token function">copyList</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    resKeep<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">process2</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>resKeep<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//要当前字符的路</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> resNoInclude <span class="token operator">=</span> <span class="token function">copyList</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//没有add()过程</span>    <span class="token function">process2</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> resNoInclude<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//不要当前字符的路</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="打印一个字符串的全部排列要求不要出现重复的排列">50.打印一个字符串的全部排列，要求不要出现重复的排列</h4><p>对每一个字符，比如从i位置开始，则前面i-1位置已经固定了，则第i位置元素可以是后面还没固定的任意一个元素，则把他们分别换到i位置构成一种选择，每种选择都做了以后就可以去i+1位置继续全部递归了，最后需要把字符串回溯到原来的情况，否则字符串就变了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//str[i..]范围上,所有的字符都可以在i位置上,后续去进行尝试</span>    <span class="token comment">//str[0..i-1]:之前做出的选择</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//visit[0]:表示'a'是否被试过</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>str<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visit<span class="token punctuation">[</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//分支限界:当前位置的字符没有被试过,才去试</span>            visit<span class="token punctuation">[</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//回溯到之前的位置,否则字符串就变了</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="纸牌问题">51.纸牌问题</h4><p>给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明<em>（会把最差的牌留给对方，他们决定自己拿到最差的牌）</em>。请返回最后获胜者的分数。</p><p>举例：arr=[1,2,100,4]。开始时，玩家A只能拿走1或4。如果开始时玩家A拿走1，则排列变为[2,100,4]，接下来玩家B可以拿走2或4，然后继续轮到玩家A..如果开始时玩家A拿走4，则排列变为[1,2,100]，接下来玩家B可以拿走1或100，然后继续轮到玩家A...玩家A作为绝顶聪明的人不会先拿4，因为拿4之后，玩家B将拿走100。所以玩家A会先拿1让排列变为[2，100,4]，接下来玩家B不管怎么选，100都会被玩家A拿走。玩家A会获胜分数为101。所以返回101。</p><p>arr=[1,100,2]。开始时，玩家A不管拿1还是2，玩家B作为绝顶聪明的人，都会把100拿走。玩家B会获胜分数为100。所以返回100。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">win</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">s</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">s</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">s</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="给你一个栈请你逆序这个栈不能申请额外的数据结构只能使用递归函数">52.给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数。</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//栈底元素</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//保持栈的顺序不变,拿到栈底元素</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> last<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串转化问题">53.字符串转化问题</h4><p>规定1和A对应、2和B对应、3和C对应。</p><p>那么一个数字字符串比如"111”，就可以转化为"AAA"、"KA"和"AK"</p><p>给定一个只有数字字符组成的字符串str，返回有多少种转化结果。</p><p>思路：0~i-1：确定好了已经，找i位置以后有多少种方式。</p><ul><li>i位置为0，不存在，直接return 0；</li><li>i位置为3-9，则不能和i+1位置结合，只有一种决定，只能将当前的字符做转换；</li><li>i位置为1，总可以和i+1结合，让i+2自由转换</li><li>i位置为2，i+1位置为0-6，可以结合，i+1位置为7-9，不能结合</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//到达了最后一位(终止位置),将之前做的决定整体构成一种结果</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'1'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//i单独作为一部分,看后续有多少种</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            res <span class="token operator">+=</span> <span class="token function">process</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//i和i+1看作一部分,看i+2以后有多少种</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'2'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//i单独作为一部分,看后续有多少种</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>chs<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> chs<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'6'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            res <span class="token operator">+=</span> <span class="token function">process</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//chs[i] == '3~9'只能把当前位置做决定</span>    <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>chs<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="袋装物品价值问题">54.袋装物品价值问题</h4><p>给定两个长度都为N的数组weights和values，weights[i] 和 values[i]分别代表i号物品的重量和价值。给定一个正数bag，表示一个载重bag的袋子，你装的物品不能超过这个重量。返回你能装下最多的价值是多少?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//0~i-1的货物已经决定,i往后的货物自由选择,形成最大价值返回</span><span class="token comment">//重量不要超过bag</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> weight<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> alreadyweight<span class="token punctuation">,</span><span class="token keyword">int</span> bag<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//当前的超重了就得把最后一次货物给去掉了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>alreadyweight <span class="token operator">&gt;</span> bag<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>values<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> weights<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//选择</span>    <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>        <span class="token comment">//不要i号货物</span>        <span class="token function">process1</span><span class="token punctuation">(</span>weight<span class="token punctuation">,</span>values<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>alreadyweight<span class="token punctuation">,</span>bag<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//要i号货物</span>        values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">process1</span><span class="token punctuation">(</span>weight<span class="token punctuation">,</span>values<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>alreadyweight <span class="token operator">+</span> weights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>bag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="认识哈希函数和哈希表的实现">55.认识哈希函数和哈希表的实现</h4><p>设计RandomPool结构</p><p>设计一种结构，在该结构中有如下三个功能</p><p>insert(key)：将某个key加入到该结构，做到不重复加入</p><p>delete(key)：将原本在结构中的某个key移除</p><p>getRandom()：等概率随机返回结构中的任何一个key。</p><p>Insert、delete和getRandom方法的时间复杂度都是O(1)</p><h4 id="岛屿数量问题">56.岛屿数量问题</h4><p>题目：一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛?</p><p>举例：</p><p>001010<br>111010<br>100100<br>000000</p><p>这个矩阵中有三个岛</p><p>进阶：如何设计一个并行算法解决这个问题<em>（并查集）</em></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">countIslands</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> m<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token class-name">M</span> <span class="token operator">=</span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token class-name">M</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token function">infect</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token class-name">N</span><span class="token punctuation">,</span> <span class="token class-name">M</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">infect</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">M</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">&gt;=</span> <span class="token class-name">N</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">&gt;=</span> <span class="token class-name">M</span> <span class="token operator">||</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//i,j没越界,并且当前位置值是1</span>        m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">infect</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token class-name">N</span><span class="token punctuation">,</span> <span class="token class-name">M</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">infect</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token class-name">N</span><span class="token punctuation">,</span> <span class="token class-name">M</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">infect</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">N</span><span class="token punctuation">,</span> <span class="token class-name">M</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">infect</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">N</span><span class="token punctuation">,</span> <span class="token class-name">M</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="kmp算法">57.KMP算法</h4><p>字符串str1和str2，str1是否包含str2，如果包含返回str2在str11中开始的位置。如何做到时间复杂度O(N)完成？</p><h4 id="回溯法">58.回溯法</h4><p>回溯法的本质是暴力穷举，解决回溯问题即是一个决策树的遍历过程。<strong>无论是哪种形式，本质都是穷举所有解，并且这些解呈树状结构，所以利用回溯算法框架，稍改代码即可求解。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>选择列表<span class="token punctuation">,</span>路径<span class="token punctuation">,</span>start<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>结束语句<span class="token punctuation">)</span><span class="token punctuation">{</span>        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>路径<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">for</span> 选择 in 选择列表<span class="token operator">:</span>    <span class="token comment">//做选择</span>    路径<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>选择<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将该选择从选择列表移除</span>    <span class="token function">backtrack</span><span class="token punctuation">(</span>选择列表<span class="token punctuation">,</span> 路径<span class="token punctuation">,</span>start<span class="token operator">/</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//想要重复→start,想要不重复→start+1</span>    <span class="token comment">//撤销选择,将该选择再加入选择列表</span>    路径<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>选择<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="lru缓存手写双向链表">59.LRU缓存（手写双向链表）</h4><p>请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。</p><p>实现 LRUCache 类：</p><ul><li><code>LRUCache(int capacity)</code>以<strong>正整数</strong>作为容量 capacity 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 key存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li><code>void put(int key, int value)</code> 如果关键字 key已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组key-value 。如果插入操作导致关键字数量超过 capacity，则应该逐出<strong>最久未使用</strong>的关键字。</li><li>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>    <span class="token comment">//创建一个双向链表</span>    <span class="token keyword">class</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> key<span class="token punctuation">;</span>        <span class="token keyword">int</span> value<span class="token punctuation">;</span>        <span class="token class-name">DLinkedNode</span> prev<span class="token punctuation">;</span>        <span class="token class-name">DLinkedNode</span> next<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>            key <span class="token operator">=</span> k<span class="token punctuation">;</span>            value <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//创建哈希表,用于存储缓存</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">DLinkedNode</span><span class="token punctuation">&gt;</span></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>   <span class="token comment">//判断当前长度是否超过capacity</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">DLinkedNode</span> head<span class="token punctuation">,</span>tail<span class="token punctuation">;</span>  <span class="token comment">//伪头部和伪尾部</span>    <span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>        head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>        tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//从缓存中查找</span>        <span class="token class-name">DLinkedNode</span> node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//找到了移到双向链表头(代表最近被使用)</span>        <span class="token function">moveToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//从缓存中找</span>        <span class="token class-name">DLinkedNode</span> node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//没找到</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//加入双向链表</span>            <span class="token class-name">DLinkedNode</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//加入缓存</span>            cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//加到双向链表头</span>            <span class="token function">addToHead</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>size<span class="token punctuation">;</span> <span class="token comment">//缓存数+1</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> capacity<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//超过了最大缓存数</span>                <span class="token class-name">DLinkedNode</span> tail <span class="token operator">=</span> <span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除尾部(最久未使用)</span>                cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tail<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在缓存中删掉最久未使用的</span>                <span class="token operator">--</span>size<span class="token punctuation">;</span><span class="token comment">//缓存数-1</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">//缓存中有</span>            node<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token comment">//更新链表中的值</span>            <span class="token function">moveToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//移到链表头</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addToHead</span><span class="token punctuation">(</span><span class="token class-name">DLinkedNode</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token class-name">DLinkedNode</span> <span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">DLinkedNode</span> res <span class="token operator">=</span> tail<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token class-name">DLinkedNode</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">moveToHead</span><span class="token punctuation">(</span><span class="token class-name">DLinkedNode</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="动态规划">60.动态规划</h4><p>解题步骤：</p><ul><li>定义子问题</li><li>写出子问题的递推关系</li><li>确定 DP 数组的计算顺序</li><li>空间优化（可选）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式面试题</title>
      <link href="/2023/03/17/fen-bu-shi/"/>
      <url>/2023/03/17/fen-bu-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式">分布式</h2><h4 id="分布式幂等性如何设计">1.分布式幂等性如何设计？</h4><p>在高并发场景的架构里，幂等性是必须得保证的。比如说支付功能，用户发起支付，如果后台没有做幂等校验，刚好用户手抖多点了几下，于是后台就可能多次受到同一个订单请求，不做幂等很容易就让用户重复支付了，这样用户是肯定不能忍的。<strong>（保证数据在同一个操作下只做一次有效的更改）</strong></p><p><strong>解决方案</strong>：</p><p>1.建唯一索引：唯一索引或唯一组合索引来防止新增数据存在脏数据(当表存在唯一索引，并发时新增异常时，再查询一次就可以了，数据应该已经存在了，返回结果即可)。</p><p>2.<code>token</code>机制：由于重复点击或者网络重发，或者<code>nginx</code>重发等情况会导致数据被重复提交。前端在数据提交前要向后端服务的申请<code>token</code>，<code>token</code>放到<code>Redis</code>或<code>JVM</code>内存，<code>token</code>有效时间。提交后后台校验<code>token</code>，同时删除<code>token</code>，生成新的<code>token</code>返回。<code>redis</code>要用删除操作来判断<code>token</code>，删除成功代表<code>token</code>校验通过，如果用<code>select+delete</code>来校验<code>token</code>，存在并发问题，不建议使用。</p><p>3.悲观锁：悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用(另外还要考虑id是否为主键，如果id不是主键或者不是<strong>InnoDB</strong>存储引擎，那么就会出现锁全表)</p><p>4.乐观锁：给数据库表增加一个<strong>version</strong>字段，可以通过这个字段来判断是否已经被修改了</p><p>5.分布式锁：比如<strong>Redis</strong>、<strong>Zookeeper</strong>的分布式锁。单号为<strong>key</strong>，然后给<strong>Key</strong>设置有效期（防止支付失败后，锁一直不释放），来一个请求使用订单号生成一把锁，业务代码执行完成后再释放锁。</p><p>6.保底方案：先查询是否存在此单，不存在进行支付，存在就直接返回支付结果（仍存在一些问题）。</p><h4 id="说说你对分布式事务的了解">2.说说你对分布式事务的了解？</h4><p>分布式事务：多个服务或者多个库，要保持在一个事务中</p><p>场景：分布式事务是企业集成中的一个技术难点，也是每一个<strong>分布式系统架构</strong>中都会涉及到，特别是在<strong>微服务架构</strong>中，几乎可以说是无法避免。</p><p>理论：ACID、CAP、BASE</p><ul><li>ACID：指数据库事务正确执行的四个基本要素：原子性(Atomicity)、一致性(Consistency)、隔离性(lsolation)、持久性(Durability)</li><li>CAP：指的是在一个分布式系统中，一致性(Consistency)、可用性(Availability) 、分区容忍性 (Partition tolerance)。CAP原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。<ul><li>一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。</li><li>可用性：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。</li><li>分区容忍性：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li><li>实际场景中，只会选择CP或AP</li></ul></li><li>BASE：Basically Available (基本可用)、Soft state(软状态)、Eventually consistent（最终一致性）<ul><li>BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</li></ul></li></ul><p>实际解决方案：seata、消息队列+本地事件表、事务消息、最大努力通知方案、tcc</p><h4 id="什么是两阶段提交协议2pc">3.什么是两阶段提交协议（2PC）？</h4><p><strong>定义：</strong></p><p>两段提交就是分两个阶段提交：</p><p><strong>第一阶段</strong>询问各个事务数据源是否准备好，投票阶段<br><strong>第二阶段</strong>才真正将数据提交给事务数据源。</p><p>为了保证该事务可以满足ACID，就要引入一个协调者(Cooradinator)。其他的节点被称为参与者(Participant)。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务进行提交。</p><p><strong>处理流程：</strong></p><ul><li>阶段一<ul><li>协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复</li><li>各参与者执行事务操作，将 undo 和 redo信息记入事务日志中（但不提交事务）</li><li>如参与者执行成功，给协调者反馈yes，否则反馈no</li></ul></li><li>阶段二<ul><li>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(rollback)消息；否则发送提交(commit)消息。两种情况外理如下：</li><li>情况1：当所有参与者均反馈 yes，提交事务<ul><li>协调者向所有参与者发出正式提交事务的请求 (即 commit 请求)</li><li>参与者执行 commit 请求，并释放整个事务期间占用的资源</li><li>各参与者向协调者反馈 ack(应答)完成的消息</li><li>协调者收到所有参与者反馈的 ack 消息后，即完成事务提交</li></ul></li><li>情况2: 当有一个参与者反馈 no，回滚事务<ul><li>协调者向所有参与者发出回滚请求 (即rollback请求) 。</li><li>参与者使用阶段 1 中的 undo信息执行回滚操作，并释放整个事务期间占用的资源</li><li>各参与者向协调者反馈 ack 完成的消息</li><li>协调者收到所有参与者反馈的 ack 消息后，即完成事务</li></ul></li></ul></li></ul><p><strong>问题：</strong></p><ul><li>性能问题：所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li><li>可靠性问题：如果协调者存在单点故障问题，或出现故障，提供者将一直处于锁定状态。</li><li>数据一致性问题：在阶段2中，当一条提交指令到达某个参与者时（不是第一个参与者）失败了，有可能导致数据不一致。</li></ul><p><strong>优化：</strong></p><ul><li>性能问题：第一阶段参与者提交业务，并记录提交数据前数据状态（记录提交前及提交后的数据），若需要回滚，则有记录日志，根据日志回滚就可以了。（空间换时间）</li><li>可靠性问题：搭建协调者的集群</li><li>数据一致性问题：脚本扫描数据核实数据是否一致，若发现数据不一致，则按照设定好的策略进行补偿</li></ul><p>案例：seata，lcn，tcc</p><h4 id="什么是补偿事务">4.什么是补偿事务？</h4><p>TCC（Try-Confirm-Cancel）：TCC事务补偿是基于2PC实现的业务层事务控制方案，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。</p><p>它分为三个步骤：</p><p>1.<strong>Try阶段</strong>：主要是对业务系统做检测及资源预留</p><p>2.<strong>Confirm阶段</strong>：确认真正执行业务，不作任何业务检查，只使用Try 阶段预留的业务资源。（Confirm操作满足幂等性）</p><p>3.<strong>Cancel阶段</strong>：主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。（Cancel操作满足幂等性）</p><p><strong>使用场景：</strong></p><p>业务需要：</p><p>举个例子，假入A要向B转账，思路大概是：</p><p>我们有一个本地方法，里面依次调用步骤：</p><ol type="1"><li>首先在 Try 阶段，要先调用远程接口把 A 和 B 的钱给冻结起来</li><li>在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</li><li>如果第2步执行成功，那么转账成功；如果第二步执行失败，则调用远程冻结接口对应的解冻方法(Cancel)。</li></ol><p>技术需要：不同组件无法在一个事务中完成。</p><p>优点：</p><p>性能提升：具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。数据最终一致性：基于 Confirm 和 Cancel的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。可靠性：解决了XA协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。</p><p>缺点：TCC 的 Try、Confirm 和 Cancel操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。（针对不同的业务需要做不同的补偿开发）</p><h4 id="如何用消息队列实现分布式事务的">5.如何用消息队列实现分布式事务的？</h4><figure><img src="\images\typora-user-images\image-20230305093046104.png" alt="image-20230305093046104"><figcaption aria-hidden="true">image-20230305093046104</figcaption></figure><p>思路：利用BASE理论的最终一致性。通过消息队列把两边的服务拆分开来，把一个大的分布式事务拆成了多个本地事务，然后通过消息中间件作为媒介，在两个服务之间进行通信，由多个小事务组成一个大事务。</p><p>流程：</p><p>1.用户向业务A提交自己的请求，业务A执行用户的业务逻辑，执行完后，将该业务插入事件表中，将其标记为未发送状态，并给用户一个响应；</p><p>2.业务A的定时任务读取事件表中的记录，将未发送状态的事件发送到消息队列中，发送成功后，将状态改为已发送；</p><p>3.业务B的消费服务接收消息队列中的消息，并将其插入到事件表中，并将状态改为已接收，然后给消息队列返回一个相应；</p><p>4.业务B的定时任务读取事件表中已接收状态的消息，操作业务B的业务逻辑，并把事件表中的状态改为已处理。</p><p>优点：用户相应比较快</p><p>缺点：编码复杂，排查问题比较困难</p><h4 id="分布式id生成有哪几种方案">6.分布式ID生成有哪几种方案？</h4><p><strong>分布式ID的特性：</strong></p><ul><li>唯一性：确保生成的ID是全网唯一的。</li><li>有序递增性：确保生成的ID是对于某个用户或者业务是按一定的数字有序递增的。（非必需）</li><li>高可用性：确保任何时候都能正确的生成ID。</li><li>带时间：ID里面包含时间，不容易重复。</li></ul><p><strong>方案：</strong></p><ul><li><p><strong>UUID</strong></p><ul><li>算法的核心思想是结合机器的网卡、当地时间、一个随记数来生成UUID</li><li>优点：本地生成，生成简单，性能好，没有高可用风险</li><li>缺点：长度过长，存储冗余，且无序不可读，查询效率低</li></ul></li><li><p><strong>数据库自增ID</strong></p><ul><li>使用数据库的id自增策略，如 MySQL 的auto_increment。并且可以使用两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。</li><li>优点：数据库生成的ID绝对有序，高可用实现方式简单</li><li>缺点：需要独立部署数据库实例，成本高，有性能瓶颈</li></ul></li><li><p><strong>批量生成ID</strong></p><ul><li>一次按需批量生成多个ID，每次生成都需要访问数据库，将数据库修改为最大的ID值，并在内存中记录当前值及最大值。</li><li>优点：避免了每次生成ID都要访问数据库并带来压力，提高性能</li><li>缺点：属于本地生成策略，存在单点故障，服务重启造成ID不连续</li></ul></li><li><p><strong>Redis生成ID</strong></p><ul><li>Redis的所有命令操作都是单线程的，本身提供像 incr 和 increby这样的自增原子命令，所以能保证生成的ID 肯定是唯一有序的。</li><li>优点：不依赖于数据库，灵活方便，且性能优于数据库；数字ID天然排序，对分页或者需要排序的结果很有帮助。</li><li>缺点：如果系统中没有Redis，还需要引入新的组件，增加系统复杂度；需要编码和配置的工作量比较大。</li><li>考虑到单节点的性能瓶颈，可以使用Redis集群来获取更高的吞吐量。</li></ul></li><li><p><strong>snowflake算法</strong></p><figure><img src="\images\typora-user-images\image-20230305094614851.png" alt="image-20230305094614851"><figcaption aria-hidden="true">image-20230305094614851</figcaption></figure><ul><li>Twitter利用zookeeper实现了一个全局ID生成的服务Snowflake（雪花算法），由下面几部分组成：</li><li>1位符号位：由于long类型在java中带符号的，最高位为符号位，正数为0，负数为1，且实际系统中所使用的ID一般都是正数，所以最高位为0。</li><li>41位时间戳（毫秒级）：存储时间戳的差值（当前时间戳-起始时间戳），这里的起始时间戳一般是ID生成器开始使用的时间戳，41位毫秒时间戳最多可以使用69年。</li><li>10位数据机器位：包括5位数据标识位和5位机器标识位，这10位决定了分布式系统中最多可以部署1024个节点。超过这个数量，生成的ID就有可能会冲突。</li><li>12位毫秒内的序列：这12位计数支持每个节点每毫秒（同一台机器，同一时刻）最多生成4096个ID。</li><li>优点：高性能，低延迟，按时间有序，一般不会造成ID碰撞</li><li>缺点：需要独立的开发和部署，依赖于机器的时钟</li></ul></li><li><p><strong>百度UidGenerator</strong></p></li><li><p><strong>美团Leaf</strong>：能保证全局唯一性、趋势递增、信息安全，但也需要依赖关系数据库、Zookeeper等中间件。</p></li></ul><h4 id="常见的负载均衡算法有哪些">7.常见的负载均衡算法有哪些？</h4><p><strong>轮询算法</strong>：RR，RoundRobin，把每个请求轮流发送到每个服务器上。适合于所有服务器硬件都相同的场景。一个一个来，如果有两个服务器，第一次是你，第二次就是我。</p><p><strong>加权轮询算法</strong>：WRR，Weighted RoundRobin，在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。。</p><p><strong>随机轮询算法</strong>：Random，把请求随机发送到服务器上。该算法比较适合服务器性能差不多的场景。</p><p><strong>最少链接算法</strong>：Leastconnections，记录每个服务器正在处理的连接数（请求数），将新的请求分发到最少连接的服务器上。</p><p><strong>加权最少链接算法</strong>：在最少链接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p><p><strong>原地址哈希算法</strong>：SourceHashing，根据请求来源（客户端）的ip地址进行hash计算，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。这有利于进行session信息的维护。</p><h4 id="说说什么是计数器固定窗口算法">8.说说什么是计数器（固定窗口）算法？</h4><p>计数器算法，是指在指定的时间周期内，累加访问的次数，达到设定的阈值时，触发限流策略。下一个时间周期进行访问时，访问次数清零。此算法无论在单机还是分布式环境下实现都非常简单，使用redis的incr原子自增性，再结合key的过期时间。</p><p>缺点：存在临界值问题。无法挡住两个时间周期内相邻时间的流量突发（如0:50和1:10忽然来了大量请求）</p><h4 id="说说什么是滑动窗口算法">9.说说什么是滑动窗口算法？</h4><p>为了解决计数器算法的临界值的问题，发明了滑动窗口算法。在TCP网络通信协议中，就采用滑动时间窗口算法来解决网络拥堵问题。滑动时间窗口是将计数器算法中的时间周期切分成多个小例时间窗口，分别在每个小的时间窗口中记录访问次数，然后根据时间将窗口往前滑动并删除过期的小时间窗口。最终只需要统计滑动窗口范围内的小时间窗口的总的请求数即可。</p><p>缺点：如果窗口划分较粗，则会造成在波峰和波谷内造成请求不平均（一定时间段内拒绝请求特别多，一定时间段内达不到系统的饱和度）。（解决方法：将窗口划分更细，滑动窗口的滚动就越平滑，限流的统计就会越精确）</p><h4 id="什么是漏桶算法">10.什么是漏桶算法？</h4><p>漏桶算法的原理就像它的名字一样，维持一个漏斗，它有<strong>恒定的流出速度</strong>，不管水流流入的速度有多快，漏斗出水的速度始终保持不变，类似于消息中间件，不管消息的生产者请求量有多大，消息的处理能力取决于消费者。漏桶的容量 = 漏桶的流出速度 *可接受的等待时长。在这个容量范围内的请求可以排队等待系统的处理，超过这个容量的请求，才会被抛弃。</p><p>在漏桶限流算法中，存在下面几种情况：</p><p>(1)当请求速度大于漏桶的流出速度时，也就是请求量大于当前服务所能处理的最大极限值时，触发限流策略</p><ol start="2" type="1"><li>请求速度小于或等于漏桶的流出速度时，也就是服务的处理能力大于或等于请求量时，正常执行。</li></ol><p>缺点：当系统在短时间内有突发的大流量时，漏桶算法处理不了。</p><h4 id="什么是令牌桶算法">11.什么是令牌桶算法？</h4><p>令牌桶算法，是增加一个大小固定的容器，也就是令牌桶，系统以恒定的速率向令牌桶中放入令牌，如果有客户端来请求，先需要从令牌桶中拿一个令牌，拿到令牌，才有资格访问系统，这时令牌桶中少一个令牌。当令牌桶满的时候，再向令牌桶生成令牌时，令牌会被抛弃。</p><p>在令牌桶算法中，存在以下几种情况：</p><p>(1)请求速度大于令牌的生成速度：那么令牌桶中的令牌会被取完，后续再进来的请求，由于拿不到令牌，会被限流。</p><ol start="2" type="1"><li>请求速度等于令牌的生成速度：那么此时系统处于平稳状态。</li></ol><p>(3)请求速度小于令牌的生成速度：那么此时系统的访问量远远低于系统的并发能力，请求可以被正常处理</p><p>优点：由于有一个桶的存在（里面存在很多令牌），可以处理短时间大流量的场景。</p><h4 id="数据库如何处理大数据量">12.数据库如何处理大数据量？</h4><p>对数据库进行：分区，分库分表，主从架构（读写分离）</p><ul><li><p>分区：隔离数据访问。将一个文件拆分成多个文件去存储，将一次大量的并发读写操作分配到了多个不同的磁盘文件上（相当于做了一次负载均衡）</p></li><li><p>分库分表：将一张很大的表拆分成多个库去存储。</p><ul><li>水平分库/表：各个库和表的结构一模一样，数据量不一样。</li><li>垂直分库/表：各个库和表的结构不一样，数据量一样。</li></ul></li><li><p>读写分离：将数据库的读写操作分开，主机负责写，从机负责读。比如让性能比较好的服务器去做写操作，性能一般的服务器做读操作。写入或更新操作频繁可以借助消息队列，进行顺序写入或更新。</p></li><li><p>数据缓存：使用缓存技术降低对数据库直接访问的压力，比如使用Redis内存数据库存储热点数据。</p></li></ul><h4 id="什么是cap定理">13.什么是CAP定理？</h4><p>CAP定理，又称布鲁尔定理。指的是在一个分布式系统中，最多只能同时满足一致性(Consistency)、可用性(Availability) 和分区容错性 (Partition tolerance)这三项中的两项。C：一致性(Consistency)：数据在多个副本中保持一致，可以理解成两个用户访问两个系统A和B，当A系统数据有变化时，及时同步给B系统，让两个用户看到的数据是一致的。</p><p>A：可用性(Availability)：系统对外提供服务必须一直处于可用状态，在任何故障下，客户端都能在合理时间内获得服务端非错误的响应。</p><p>P：分区容错性(Partitiontolerance)：在分布式系统中遇到任何网络分区故障，系统仍然能对外提供服务。</p><p>(1)当网络发生故障时，系统A和系统B没法进行数据同步，也就是不满足P，同时两个系统依然可以访问，那么此时其实相当于是两个单机系统，就不是分布式系统了，所以既然是分布式系统，<strong>P必须满足</strong>。</p><p>(2)当P满足时，如果用户1通过系统A对数据进行了修改将data1改成了data2，也要让用户2通过系统B正确的拿到data2，那么此时是满足C，就必须等待网络将系统A和系统B的数据同步好，并且<strong>在同步期间，任何人不能访问系统B，否则数据就不是一致的</strong>。此时满足的是CP，牺牲的是可用性。</p><p>(3)当P满足时，如果用户1通过系统A对数据进行了修改将data1改成了data2，也要让系统B能继续提供服务，那么此时，只能接受系统A没有将data2同步给系统B。此时满足的就是AP，牺牲了数据的一致性。</p><p>A和C的选择需要根据业务来决定。</p><h4 id="什么是base理论">14.什么是BASE理论？</h4><p>由于CAP中一致性C和可用性A无法兼得，提出了BASE理论，它是通过牺牲数据的强一致性，来获得可用性。它有如下3种特征：</p><p>BasicallyAvailable（基本可用）：分布式系统在出现不可预知故障的时候，允许损失部分可用性，保证核心功能的可用。</p><p>Soft state（软状态）:软状态也称为弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><p>Eventuallyconsistent（最终一致性）：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要<strong>实时</strong>保证系统数据的强一致性。</p><p>BASE理论并没有要求数据的强一致性，而是允许数据在一定的时间段内是不一致的，但在最终某个状态会达到一致。在生产环境中，很多公司，会采用BASE理论来实现数据的一致，因为产品的可用性相比强一致性来说，更加重要。例如在电商平台中，当用户对一个订单发起支付时，往往会调用第三方支付平台，例如支付宝支付或者微信支付，调用第三方成功后，第三方并不能及时通知我方系统，在第三方没有通知我方系统的这段时间内，给用户的订单状态显示支付中，等到第三方回调之后，再将状态改成已支付。虽然订单状态在短期内存在不一致，但是用户却获得了更好的产品体验。</p><h4 id="什么是可靠消息最终一致性方案">15.什么是可靠消息最终一致性方案？</h4><p>可靠消息最终一致性方案。它是保证事务最终一致性的一种方案，允许数据在业务中出现短暂的不一致状态。</p><p>可靠消息最终一致性方案是指，当事务的发起方（事务参与者，也就是消息发送者）执行完本地事务后，同时发出一条消息，事务参与方（事务参与者，也就是消息的消费者）一定能够接收消息并可以成功处理自己的事务。</p><p>这里面强调两点：</p><ul><li><p>可靠消息：发起方一定得把消息传递到消费者。</p></li><li><p>最终一致性：最终发起方的业务处理和消费方的业务处理得完成，达成最终一致。</p></li></ul><p>存在问题：事务发起方和消息中间件之间，事务消费方和消息中间件之间，都有网络通信，由于网络通信的不确定性，会导致数据的问题。</p><p>解决方案：</p><ul><li>事务发起方本地事务和消息发送之间的原子性问题。此问题是本地事务执行成功，消息必须发出去，否则丢弃消息，即本地事务执行成功和消息的发送成功，要么都成功，要么都失败。</li><li>事务消费方和消息消费的原子性问题。此时要保证事务消费方必须能接受到消息，如果由于程序故障，导致事务消费方重启，那么需要消息中间件要有消息重发机制；由于网络延时的存在，当事务消费方消费消息成功，没有向消息中间件响应时，而消息中间件由于重发机制，会再次投递消息，就导致了消息重复消费的问题。此时在消费方要有幂等性解决方案。</li></ul><h4 id="rocketmq在分布式事务中如何应用">16.RocketMQ在分布式事务中如何应用？</h4><p>RocketMQ的事务消息，主要为了解决事务生产方执行业务和消息发送的原子性问题。</p><figure><img src="\images\typora-user-images\image-20230306104354337.png" alt="image-20230306104354337"><figcaption aria-hidden="true">image-20230306104354337</figcaption></figure><p>事务状态：</p><ul><li><code>TransactionStatus.CommitTransaction</code>：提交状态，它允许消费者消费此消息。</li><li><code>TransactionStatus.RollbackTransaction</code>：回滚状态，它代表该消息将被删除，不允许被消费者消费。</li><li><code>TransactionStatus.Unknown</code>：中间状态，它代表需要检查消息队列来确定状态。</li></ul><p>应用流程：</p><ol type="1"><li><p>发送<code>half message</code>。在执行本地业务之前，先向消息队列发送一条事务消息，此时叫做<code>half message</code>，此时消息被标记为（Prepared预备状态），此时的消息是无法被消费者消费的，需要生产者对消息进行二次确认后，消费者才能去消费它。</p></li><li><p>消息队列回应<code>half message</code>发送成功。</p></li><li><p>当事务发起方收到消息队列的成功响应之后，开始执行本地事务。</p></li><li><p>如果本地事务执行成功，则向消息队列发送<code>half message</code>的确认，这样事务消费方就可以消费消息了。</p></li><li><p>如果本地事务执行失败，则向消息队列发送<code>half message</code>的回滚，删除<code>half message</code>。事务消费方就无法消费消息。</p></li><li><p>回查机制。当第4步无论是提交还是回滚，由于网络闪断、生产者应用重启等原因，导致生产者无法对消息队列中的<code>half message</code>进行二次确认（即上面的第4步骤，发送提交或者回滚消息）时，消息队列中的<code>half message</code>就不知道应该怎么办了。此时消息队列会定时扫描长期处于<code>half message</code>的消息，并发起一个回查机制，来确认此时的<code>half message</code>应该是提交还是回滚。此时，消息队列主动询问生产者该消息的最终状态（提交还是回滚），即为消息的回查机制。</p></li></ol><h4 id="说说微服务中注册中心存储结构">17.说说微服务中注册中心存储结构？</h4><h4 id="设计一个注册中心需要写那些接口">18.设计一个注册中心需要写那些接口？</h4><h4 id="谈谈你对restful规范的理解">19.谈谈你对RESTful规范的理解？</h4><p>RESTful是一个普通的http请求（并非一种协议，他只是把http协议更好的使用）。其中REST表示ResourceRepresentational State Transfer，直接翻译即"资源表现层状态转移"。</p><ul><li><p>Resource代表互联网资源。所谓“源”是网络上的一个实体，或者说网上的一个具体信息。它可以是一段文本、一首歌曲、一种服务，可以使用一个URI指向它，每种“资源”对应一个URI。（理解为一个对象）</p></li><li><p>Representational是“表现层”。“资源”是一种消息实体，它可以有多种外在的表现形式，把“资源”具体呈现出来的形式叫作它的“表现层”。例如说文本可以用TXT格式进行表现，也可以使用XML格式、JSON格式和二进制格式；视频可以用MP4格式表现，也可以用AVI格式表现。URI只代表资源的实体，不代表它的形式。它的具体表现形式，应该由HTTP请求的头信息Accept和Content-Type字段指定，这两个字段是对“表现层”的描述。</p></li><li><p>StateTransfer是指“状态转移”。客户端访问服务的过程中必然涉及数据和状态的转化。如果客户端想要操作服务端资源，必须通过某种手段，让服务器端资源发生“状态转移”。而这种转化是建立在表现层之上的，所以被称为“表现层状态转移”。客户端通过使用HTTP协议中的常用的四个动词来实现上述操作，它们分别是获取资源的<strong>GET</strong>、新建或更新资源的<strong>POST</strong>、更新资源的<strong>PUT</strong>和删除资源的<strong>DELETE</strong>。</p></li></ul><h4 id="分布式系统中为什么引入熔断">20.分布式系统中为什么引入熔断？</h4><p>微服务系统之间通过互相调用来实现业务功能，但每个系统都无法百分之百保证自身运行不出问题入在服务调用中，很可能面临依赖服务失效的问题(网络延时，服务异常，负载过大无法及时响应)，导致服务雪崩，这对于一个系统来说是灾难性的。因此需要一个组件，能提供强大的容错能力，当服务发生异常时，能提供保护和控制，把影响控制在较小范围内，不要造成所有服务的雪崩。</p><p>熔断开关：打开（走降级的方法），关闭（走正常的调用），半开</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程面试题</title>
      <link href="/2023/03/17/duo-xian-cheng/"/>
      <url>/2023/03/17/duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程">多线程</h2><h4 id="java中线程的实现方式">1.Java中线程的实现方式？</h4><p>线程的创建分为四种方式：</p><ul><li><strong>继承Thread类，重写run方法</strong></li><li><strong>实现Runnable接口，重写run方法</strong></li><li><strong>实现Callable重写call方法，配合FutureTask</strong></li><li><strong>基于线程池构建线程</strong></li></ul><p>追其底层，其实都是实现Runnable实现的</p><ul><li><p>Thread类直接实现Runnable</p></li><li><p>Callable实现方法是将Callable放到FutureTask中，而FutureTask实现RunnableFuture，而RunnableFuture又继承了Runnable（本质上还是Runnable）</p></li><li><p>ThreadPoolExecutor每次构建都需要一个Worker类，而Worker类又实现了Runnable</p></li></ul><h4 id="java中线程的状态">2.Java中线程的状态？</h4><p><strong>Java中线程状态分为6种</strong>：<strong>NEW</strong>、<strong>RUNNABLE</strong>、<strong>BLOCKED</strong>、<strong>WAITING</strong>、<strong>TIMED_WAITING</strong>、<strong>TERMINATED</strong></p><figure><img src="\images\typora-user-images\image-20230303074549613.png" alt="image-20230303074549613"><figcaption aria-hidden="true">image-20230303074549613</figcaption></figure><p>1.<strong>初始(NEW)</strong>：新创建了一个线程对象，但还没有调用start()方法。</p><ol start="2" type="1"><li><p><strong>运行(RUNNABLE)</strong>：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为"运行"。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</p></li><li><p><strong>阻塞(BLOCKED)</strong>：表示线程阻塞于锁，表示运行时状态的线程的synchronized没有拿到资源，被放到EntryList中阻塞的状态。</p></li><li><p><strong>等待(WAITING)</strong>：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断），它们要等待被显式地唤醒，否则会处于无限期等待的状态。。</p></li><li><p><strong>超时等待(TIMED_WAITING)</strong>：该状态不同于WAITING，它可以在指定的时间后自行返回。</p></li><li><p><strong>终止(TERMINATED)</strong>：表示该线程已经执行完毕。当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。</p></li></ol><h4 id="java中如何停止线程">3.Java中如何停止线程？</h4><ul><li><strong>stop方法</strong>（不用）：强制让线程结束</li><li><strong>使用共享变量（标志位）</strong>（很少使用）：通过修改共享变量在破坏循环，让线程退出循环，结束run方法。（需要在线程中给共享变量留判断入口）</li><li><strong>interrupt</strong>：<ul><li>在默认情况下，interrupt标记位为false，执行interrupt之后，标记位会变成true</li><li>当线程正在休眠，此时修改interrupt标记位，则会抛出异常。</li></ul></li></ul><h4 id="java中sleep和wait方法的区别">4.Java中sleep和wait方法的区别？</h4><ul><li><strong>所属类不同</strong>：sleep属于Thread类中的static方法；wait属于Object类的方法</li><li><strong>唤醒方式不同</strong>：sleep属于TIMED_WAITING状态，休眠之后会自动被唤醒；wait属于WAITING状态，需要手动唤醒，也就是直到另一个线程调用了notify 或 notifyAll 之后，休眠的线程才能被唤醒。</li><li><strong>释放锁资源不同</strong>：<ul><li>sleep在持有锁时被执行，不会释放锁资源；wait在执行后，会释放锁资源</li><li>sleep可以在持有锁或者不持有锁时执行；wait必须在持有锁时才可以执行<ul><li>wait方法会将持有锁的线程从owner扔到WaitSet集合中，这个操作是在修改ObjectMonitor对象，如果没有持有synchronized锁的话，是无法操作ObjectMonitor对象的。</li></ul></li></ul></li></ul><h4 id="并发编程的三大特性">5.并发编程的三大特性？</h4><ul><li><strong>原子性</strong></li></ul><p>定义：原子性指一个操作是不可分割的，不可中断的，一个线程在执行时，另一个线程不会影响到他。</p><p>保证原子性：synchronized、CAS、Lock锁、ThreadLocal（不让多线程操作临界资源，让每个线程操作属于自己的数据）</p><ul><li><strong>可见性</strong></li></ul><p>可见性问题是基于CPU位置出现的，CPU处理速度非常快，相对CPU来说，去主内存获取数据这个事情太慢了，CPU就提供了L1，L2，L3的三级缓存，每次去主内存拿完数据后，就会存储到CPU的三级缓存，每次去三级缓存拿数据，效率肯定会提升。</p><p>这就带来了问题，现在CPU都是多核，每个线程的工作内存(CPU三级缓存)都是独立的，会告知每个线程中做修改时，只改自己的工作内存，没有及时的同步到主内存，导致数据不一致问题。</p><p>解决：volatile：因为volatile所修饰的那块内存，对于它的任何修改另外一个线程立马可见，被volatile修饰的内存，线程每次读取都从内存里面读取一遍，这样就能获得最新的被volatile修饰的那块内存的值，所以一个线程改了以后另一个线程立马可见。此外，还有synchronized，Lock，final可以解决可见性问题。</p><ul><li><strong>有序性</strong></li></ul><p>在Java中，java文件中的内容会被编译，在执行前需要再次转为CPU可以识别的指令，CPU在执行这些指令时，为了提升执行效率，在不影响最终结果的前提下(满足一些要求)，会对指令进行重排。</p><p>保证有序性：</p><p>​ 1.happens-before：可以通过happen-before的原则去避免指令重排</p><p>​2.volatile：如果需要让程序对某一个属性的操作不出现指令重排，除了满足happens-before原则之外，还可以基于volatile修饰属性，从而对这个属性的操作，就不会出现指令重排的问题了。volatile通过将内存屏障看成一条指令，在两个操作之间添加上一道指令，这个指令就可以避免上下执行的其他指令进行重排序。从而实现的禁止指令重排。</p><p>​</p><h4 id="什么是cas有什么优缺点">6.什么是CAS？有什么优缺点？</h4><p>CAS（compare andswap）：就是比较和交换，他是一条CPU的并发原语，用于保证并发编程的原子性。</p><p>CAS是一种基于锁的操作，而且是一种乐观锁。他在替换内存的某个位置的值时，首先查看内存中的值与预期值是否一致，如果一致，执行替换操作。</p><p>CAS执行步骤：</p><p>1.修改前记录数据的内存地址V；</p><p>2.读取数据的当前的值，记录为A；</p><p>3.修改数据的值变为B；</p><p>4.查看地址V下的值是否仍然为A，若为A，则用B替换它；若地址V下的值不为A，表示在自己修改的过程中，其他的线程对数据进行了修改，则不更新变量的值，而是重新从步骤2开始执行，这被称为<strong>自旋</strong>；</p><p>优点：CAS是一种乐观锁，不需要加锁就能进行原子操作。相比于传统的synchronized，它可以避免线程的挂起和唤醒，带来用户态和内核态切换的成本。</p><p>缺点：</p><p>1.自旋时间过长问题：多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。</p><p>解决方案：指定CAS执行次数，超过次数直接失败/挂起线程（增加自旋锁）</p><p>2.ABA问题：指比如有两个线程一个快，一个慢。快线程将初始A变量改为B，然后又将B改成了A，此时慢线程以为初始变量没有改变过一直是A，继续在此版本上进行修改，但此时A已经不是初始的A了，在业务中可能会出现问题。</p><p>解决方案：增加版本号</p><h4 id="contended注解有什么用">7.@Contended注解有什么用？</h4><p>这个注解是为了解决伪共享的问题（解决缓存行同步带来的性能问题）</p><p>CPU在操作主内存变量前，会将主内在数据缓存到CPU缓存 (L1,L2,L3) 中</p><p>CPU缓存L1，是以缓存行为单位存储数据的，一般默认的大小为64字节。</p><p>缓存行同步操作，影响CPU一定的性能（当缓存行中其他数据改变时，会怀疑缓存行内想要获取的数据是否也跟着改变了，可能会造成数据不一致的问题，就需要做缓存行同步的操作），<span class="citation" data-cites="Contented注解就是来解决这个问题的">@Contented注解就是来解决这个问题的</span>。</p><p><span class="citation" data-cites="Contented注解">@Contented注解</span>，会将当前类中的属性，会独占一个缓存行，从而避免缓存行失效造成的性能问题</p><p><span class="citation" data-cites="Contented注解">@Contented注解</span>，就是将一个缓存行的后面7个位置，填充上7个没有意义的数据。</p><h4 id="java中的四种引用类型">8.Java中的四种引用类型</h4><ul><li><strong>强引用</strong>：在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它始终处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一。</li><li><strong>软引用</strong>：对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中，作为缓存使用。SoftReference</li><li><strong>弱引用</strong>：弱引用比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。可以解决内存泄漏问题，ThreadLocal就是基于弱引用解决内存泄漏的问题。</li><li><strong>虚引用</strong>：虚引用不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。</li></ul><h4 id="threadlocal的内存泄漏问题">9.ThreadLocal的内存泄漏问题</h4><p>ThreadLocal内存泄漏的原因主要是因为ThreadLocal中包含了ThreadLocalMap，然而ThreadLocalMap的对象是在Thread中的，如果Thread没有结束，则ThreadLocalMap一直不会释放，假如ThreadLocalMap中设置了很多值，而且没有手动设置remove()，则可能会造成内存泄露。</p><p>ThreadLocalMap中又维护了一个key-value形式的Entry对象，key指向了当前ThreadLocal对象，value就是我们实际在ThreadLocal中存储的值。所以，在当前线程正在运行的时候，发生GC时，在ThreadLocal对象没有被其它地方强引用时，key指向ThreadLocal的弱引用就会立即断开（被垃圾回收掉）。这时，就会出现ThreadLocalMap中存在key为null的Entry（但是value仍然存在），只要当前线程不结束，该ThreadLocalMap对象就会一直存在，永远无法回收（因为此时还存在一条强引用的链路）。所以这个时候就造成了内存泄露。</p><p>key内存泄漏：key如果使用强引用断不开就会造成key内存泄漏，ThreadLocal使用弱引用已经解决了</p><p>value内存泄漏：使用线程池，导致线程对象存在但是找不到里面具体的value</p><p>解决方案：在线程使用完ThreadLocal后调用remove()，把ThreadLocalMap里的某个Entry直接移除掉</p><h4 id="java中锁的分类">10.Java中锁的分类</h4><ul><li><p><strong>可重入锁、不可重入锁</strong></p><ul><li>可重入：当前线程获取到A锁，在获取之后尝试再次获取A锁是可以直接拿到的。Java中提供的synchronized，ReentrantLock，ReentrantReadWriteLock都是可重入锁。</li><li>不可重入：当前线程获取到A锁，在获取之后尝试再次获取A锁，无法获取到的，因为A锁被当前线程占用着，需要等待自己释放锁再获取锁。</li></ul></li><li><p><strong>乐观锁、悲观锁</strong></p><ul><li>悲观锁：获取不到锁资源时，会将当前线程挂起（进入BLOCKED、WAITING），线程挂起会涉及到用户态和内核态的切换，而这种切换是比较消耗资源的。Java中提供的synchronized，ReentrantLock，ReentrantReadWriteLock都是悲观锁。<ul><li>用户态：JVM可以自行执行的指令，不需要借助操作系统执行。</li><li>内核态：JVM不可以自行执行，需要操作系统才可以执行。</li></ul></li><li>乐观锁：获取不到锁资源，可以再次让CPU调度，重新尝试获取锁资源。Java中提供的CAS操作，就是乐观锁的一种实现。</li></ul></li><li><p><strong>公平锁、非公平锁</strong></p><ul><li><p>公平锁：线程A获取到了锁资源，线程B没有拿到，线程B去排队，线程C来了，锁被A持有，同时线程B在排队。直接排到B的后面，等待B拿到锁资源或者是B取消后，才可以尝试去竞争锁资源。</p></li><li><p>非公平锁：线程A获取到了锁资源，线程B没有拿到，线程B去排队，线程C来了，先尝试竞争一波</p><ul><li>拿到锁资源：开心，插队成功。</li><li>没有拿到锁资源：依然要排到B后面，等待B拿到锁资源或是B取消后，才可以尝试去竞争锁资源。</li></ul><p>Java中提供的ReentrantLock，ReentrantReadWriteLock可以实现公平锁和非公平锁。</p><p>Java中提供的synchronized只能是非公平锁。</p></li></ul></li><li><p><strong>互斥锁、共享锁</strong></p><ul><li><p>互斥锁：同一时间点，只会有一个线程持有者当前互斥锁。</p></li><li><p>共享锁：同一时间点，当前共享锁可以被多个线程同时持有。</p><p>Java中提供的synchronized、ReentrantLock是互斥锁。</p><p>Java中提供的ReentrantReadWriteLock，有互斥锁也有共享锁。</p></li></ul></li></ul><h4 id="synchronized在jdk1.6中的优化">11.synchronized在JDK1.6中的优化</h4><ul><li><p><strong>锁消除</strong>：在eynchronized修饰的代码中，如果不存在操作临界资源的情况，会触发锁消除，你即便写了synchronized，他也不会触发。</p></li><li><p><strong>锁膨胀</strong>：如果在一个循环中，频繁的获取和释放做资源，这样带来的消耗很大，锁膨胀就是将锁的范围扩大，避免频繁的竞争和获取锁资源带来不必要的消耗。</p></li><li><p><strong>锁升级</strong>：synchronized在JDK1.6之前，完全就是获取不到锁，立即挂起当前线程，所以synchronized性能比较差。synchronized就在JDK1.6做了锁升级的优化</p><ul><li><strong>无锁、匿名偏向</strong>：当前对象没有作为锁存在。</li><li><strong>偏向锁</strong>：如果当前锁资源，只有一个线程在频繁的获取和释放，那么这个线程过来，只需要判断，当前指向的线程是否是当前线程。<ul><li>如果是，直接拿着锁资源走。</li><li>如果当前线程不是我，基于CAS的方式，尝试将偏向锁指向当前线程。如果获取不到，触发锁升级，升级为轻量级锁。（偏向锁状态出现了锁竞争的情况）</li></ul></li><li><strong>轻量级锁</strong>：会采用自旋锁的方式去频繁的以CAS的形式获取锁资源(采用的是<strong>自适应自旋锁</strong>)<ul><li>如果成功获取到，拿着锁资源走</li><li>如果自旋了一定次数，没拿到锁资源，锁升级。</li></ul></li><li><strong>重量级锁</strong>：就是最传统的synchronized方式，拿不到锁资源，就挂起当前线程。(用户态&amp;内核态)</li></ul></li></ul><h4 id="synchronized的实现原理">12.synchronized的实现原理</h4><p>synchronized的作用是保证在同一时刻，被修饰的代码块或方法只会有一个线程执行，以达到保证并发安全的效果。</p><p>synchronized的底层实现是完全依赖JVM虚拟机的，Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，代码块同步使用的是<code>monitorenter</code>和<code>monitorexit</code>指令实现的，而方法同步是通过<code>Access flags</code>后面的标识来确定该方法是否为同步方法。</p><ul><li><strong>Java对象头</strong><ul><li>在JVM虚拟机中，对象在内存中的存储布局，可以分为三个区域：对象头(Header)、实例数据(InstanceData)、对齐填充(Padding)</li><li>Java对象头主要包括两部分数据：类型指针和标记字段。</li><li>标记字段用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等,它是实现轻量级锁和偏向锁的关键。所以，很明显synchronized使用的锁对象是存储在Java对象头里的标记字段里。</li></ul></li><li><strong>Monitor</strong><ul><li><code>monitor</code>描述为对象监视器，可以类比为一个特殊的房间，这个房间中有一些被保护的数据，<code>monitor</code>保证每次只能有一个线程能进入这个房间进行访问被保护的数据，进入房间即为持有<code>monitor</code>，退出房间即为释放<code>monitor</code>。</li><li>使用syncrhoized加锁的同步代码块在字节码引擎中执行时，主要就是通过锁对象的<code>monitor</code>的取用(<code>monitorenter</code>)与释放(<code>monitorexit</code>)来实现的。</li><li><code>monitorenter</code>指令在编译后插入到同步代码块开始位置，而<code>monitorexit</code>插入到方法结束与异常处，JVM保证每个<code>monitorenter</code>必须有相应<code>monitorexit</code>与之配对。任何对象有一个<code>monitor</code>与之关联，当一个<code>monitor</code>被持有后，它处于锁定状态。</li></ul></li></ul><h4 id="什么是aqs">13.什么是AQS？</h4><p>AQS是一个抽象的队列同步器，通过维护一个共享资源状态和一个先进先出的线程等待队列来实现一个多线程访问共享资源的同步框架。</p><p>AQS为每个共享资源都设置一个共享资源锁，线程在需要访问共享资源时首先需要获取共享资源锁，如果获取到了共享资源锁，便可以在当前线程中使用该共享资源，如果获取不到，则将该线程放入线程等待队列，等待下一次资源调度。其本质上是AbstractQueuedSynchronizer抽象类，其实就是JUC包下的一个基类，JUC下的很多内容都是基于AQS实现了部分功能，比如ReentrantLock，ThreadPoolExecutor，阻塞队列，CountDownLatch，Semaphore，CyclicBarrier等等都是基于AQS实现。</p><p>首先AQS中提供了一个由volatile修饰，并且采用CAS方式修改的int类型的state变量。</p><p>其次AQS中维护了一个双向链表，有head，有tail，并且每个节点都是Node对象</p><h4 id="aqs唤醒节点时为何要从后往前找">14.AQS唤醒节点时，为何要从后往前找？</h4><ul><li>插入节点的顺序：当前节点在插入到整个AQS队列中时，是先把当前节点的上一个指针指向我前面的节点，再把tail指向我。这时，前一个节点的指针指向null，如果从前往后找极大可能会错过某一个节点，造成检验丢失的问题</li><li>在高并发情况下，线程A通过CAS进入if语句块之后，发生上下文切换，此时线程B同样执行了该方法，并且执行完毕。然后线程C调用了unparkSuccessor方法，假如是从头到尾的遍历形式，线程A的next指针此时还是null！也就是说，会出现后续节点被漏掉的情况。</li><li>从后往前的情况下，在将当前节点置为尾部之前就已经把前驱节点赋值了，不会出现prev=null的情况。</li></ul><h4 id="reentrantlock和synchronized的区别">15.ReentrantLock和synchronized的区别？</h4><p><strong>核心区别</strong>：</p><ul><li>ReentrantLock是个类，synchronized是关键字</li></ul><p><strong>效率区别</strong>：</p><ul><li>如果竞争比较激烈，推荐ReentrantLock去实现，不存在锁升级概念。而synchronized是存在锁升级概念的，如果升级到重量级锁，是不存在锁降级的。</li></ul><p><strong>底层实现区别</strong>：</p><ul><li>实现原理不一样，ReentrantLock基于AQS实现的，synchronized是基于ObjectMonitor</li></ul><p><strong>功能向的区别</strong>：</p><ul><li>ReentrantLock的功能比synchronized更全面<ul><li>ReentrantLock支持公平锁和非公平锁</li><li>ReentrantLock可以指定等待锁资源的时间</li></ul></li></ul><p><strong>使用上的区别</strong>：</p><ul><li>ReentrantLock需要手动释放锁资源，synchronized不需要手动释放</li></ul><h4 id="reentreadwritelock的实现原理">16.ReentReadWriteLock的实现原理</h4><p><em>（先从state上说，然后从重入的角度说）</em></p><p>使用场景：操作是读多写少的还要保证线程安全</p><p>功能：读读之间是不互斥的，可以读和读操作并发执行；但是如果涉及到了写操作，那么还得是互斥的操作。</p><p><strong>底层实现</strong>：ReentrantReadWriteLock还是基于AQS实现的，还是对state进行操作，拿到锁资源就去干活，如果没有拿到，依然去AQS队列中排队。</p><p><strong>读锁操作</strong>：基于state的高16位进行操作。<strong>写锁操作</strong>：基于state的低16位进行操作。</p><p>ReentrantReadWriteLock依然是<strong>可重入锁</strong>。</p><p><strong>写锁重入</strong>：读写锁中的写锁的重入方式，基本和ReentrantLock一致，没有什么区别，依然是对state进行+1操作即可，只要确认持有锁资源的线程，是当前写锁线程即可。只不过之前ReentrantLock的重入次数是state的正数取值范围，但是读写锁中写锁范围就变小了。</p><p><strong>读锁重入</strong>：因为读锁是共享锁。读锁在获取锁资源操作时，是要对state的高16位进行+1操作。因为读锁是共享锁，所以同一时间会有多个读线程持有读锁资源。这样一来，多个读操作在持有读锁时，无法确认每个线程读锁重入的次数。为了去记录读锁重入的次数，每个读操作的线程，都会有一个ThreadLocal记录锁重入的次数。</p><p><strong>写锁的饥饿问题</strong>：读锁是共享锁，当有线程持有读锁资源时，再来一个线程想要获取读锁，直接对state修改即可。在读锁资源先被占用后，来了一个写锁资源，此时，大量的需要获取读锁的线程来请求锁资源，如果可以绕过写锁，直接拿资源，会造成写锁长时间无法获取到写锁资源。</p><p>读锁在拿到锁资源后，如果再有读线程需要获取读锁资源，需要去AQS队列排队。如果队列的前面需要写锁资源的线程，那么后续读线程是无法拿到锁资源的。持有读锁的线程，只会让写锁线程之前的读线程拿到锁资源。</p><h4 id="jdk中提供了哪些线程池">17.JDK中提供了哪些线程池？</h4><ul><li><p><strong>newFixedThreadPool</strong></p><p>线程池数量固定。</p></li><li><p><strong>newSingleThreadExecutor</strong></p><p>单例线程池，线程池只有一个工作线程在处理任务。</p></li><li><p><strong>newCachedThreadPool</strong></p><p>它是可缓存的线程池，并且还会回收。它会把任务交给我们的线程，而且线程不够用的话，就会创建线程。如果线程过多，就会把这些线程给回收回来。</p></li><li><p><strong>newScheduleThreadPool</strong></p><p>它是支持定期和周期执行任务的，我们可以设置它每隔多长时间去执行任务。这个线程池用在我们的定时任务或者是用它来替代我们的定时器都是可以的。</p></li><li><p><strong>newWorkStealingPool</strong></p><p>JDK1.8引入的，创建时如果不设置任何参数，则以当前机器处理器个数作为线程个数，此线程池会并行处理任务，不能保证执行顺序。</p></li></ul><h4 id="线程池的核心参数有什么">18.线程池的核心参数有什么？</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>    <span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token comment">//核心工作线程(当前任务执行结束后，不会被销毁)</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token comment">//最大工作线程(代表当前线程池中，一共可以有多少个工作线程)</span><span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span><span class="token comment">//多余空闲线程的存活时间。非核心工作线程在阻塞队列位置等待的时间</span><span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span><span class="token comment">//keepAliveTime的单位。非核心工作线程在阻塞队列位置等待时间的单位</span><span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span><span class="token comment">//里面放了被提交但是尚未执行的任务,任务在没有核心工作线程处理时，任务先扔到阻塞队列中</span>    <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span><span class="token comment">//表示线程池中工作线程的线程工厂,用于创建线程,构建线程的线程工作,可以设置thread的一些信息</span>    <span class="token class-name">ReiectedExecutionHandler</span> handler<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 当线程池无法处理投递过来的任务时，执行当前的拒绝策略</span>    <span class="token comment">// 初始化线程池的模作</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="线程池的状态">19.线程池的状态</h4><figure><img src="\images\typora-user-images\image-20230303141714971.png" alt="image-20230303141714971"><figcaption aria-hidden="true">image-20230303141714971</figcaption></figure><ul><li><strong>RUNNING</strong>：<ul><li>能够接收新任务以及对已添加的任务进行处理。</li><li>线程池的初始状态为RUNNING。线程池一旦被创建，就处于RUNNING状态，且线程池中的任务数为0</li></ul></li><li><strong>SHUTDOWN</strong>：<ul><li>不接收新任务，但能处理已添加的任务</li><li>调用线程池的shutdown()接口时，线程池由RUNNING-&gt;SHUTDOWN</li></ul></li><li><strong>STOP</strong>：<ul><li>不接收新任务，不处理已添加的任务，并且会中断正在处理的任务</li><li>调用线程池的shutdownNow()接口时，线程池由(RUNNING)或者(SHUTDOWN)-&gt;STOP</li></ul></li><li><strong>TIDYING</strong>：<ul><li>当所有的任务已终止，ctl记录的任务数为0，线程池的状态会变为TIDYING状态；当线程池的状态变为TIDYING状态时，会调用钩子函数terminated()，该方法在ThreadPoolExecutor中是空的，若用户想在线程池变为TIDYING时进行相应的处理，就需要重载terminated()函数实现</li><li>当线程池状态为SHUTDOWN时，阻塞队列为空并且线程池中执行的任务也为空时，就会由SHUTDOWN-&gt;TIDYING；当线程池为STOP时，线程池中执行的任务为空时，就会又STOP-&gt;TIDYING</li></ul></li><li><strong>TERMINATED</strong>：<ul><li>线程池彻底终止，就会变成TERMINATED状态</li><li>线程池处于TIDYING状态时，调用terminated()就会由TIDYING-&gt;TERMINATED</li></ul></li></ul><h4 id="线程池的执行流程">20.线程池的执行流程？</h4><figure><img src="\images\typora-user-images\image-20230303142218115.png" alt="image-20230303142218115"><figcaption aria-hidden="true">image-20230303142218115</figcaption></figure><p><strong>优先核心线程、阻塞队列次之，最后非核心线程</strong></p><p>1.提交任务后会首先进行当前工作线程数与核心线程数的比较，如果当前工作线程数小于核心线程数，则直接调用addWorker() 方法创建一个核心线程去执行任务；</p><p>2.如果工作线程数大于核心线程数，即线程池核心线程数已满，则新任务会被添加到阻塞队列中等待执行，当然，添加队列之前也会进行队列是否为空的判断；</p><p>3.如果线程池里面存活的线程数已经等于核心线程数了，且阻塞队列已经满了，再会去判断当前线程数是否已经达到最大线程数maximumPoolSize，如果没有达到，则会调用 addWorker()方法创建一个非核心线程去执行任务；</p><p>4.如果当前线程的数量已经达到了最大线程数时，当有新的任务提交过来时，会执行拒绝策略</p><h4 id="线程池添加工作线程的流程">21.线程池添加工作线程的流程？</h4><p><strong>提交任务</strong></p><p>当向线程池提交一个新的任务时，线程池有三种处理情况，分别是：创建一个工作线程来执行该任务、将任务加入阻塞队列、拒绝该任务。提交任务的过程也可以拆分成以下几个部分：当工作线程数小于核心线程数时，直接创建新的核心工作线程当工作线程数不小于核心线程数时，就需要尝试将任务添加到阻塞队列中去，如果能够加入成功，说明队列还没有满，那么需要做以下的二次验证来保证添加进去的任务能够成功被执行验证当前线程池的运行状态，如果是非RUNNING状态，则需要将任务从阻塞队列中移除，然后拒绝该任务验证当前线程池中的工作线程的个数，如果为0，则需要主动添加一个空工作线程来执行刚刚添加到阻塞队列中的任务如果加入失败，则说明队列已经满了，那么这时就需要创建新的"临时"工作线程来执行任务如果创建成功，则直接执行该任务如果创建失败，则说明工作线程数已经等于最大线程数了，则只能拒绝该任务了。</p><p><strong>创建工作线程</strong></p><p>创建工作线程需要做一系列的判断，需要确保当前线程池可以创建新的线程之后，才能创建。首先，当线程池的状态是SHUTDOWN 或者 STOP时，则不能创建新的线程。另外，当线程工厂创建线程失败时，也不能创建新的线程。还有就是当前工作线程的数量与核心线程数、最大线程数进行比较，如果前者大于后者的话，也不允许创建。除此之外，会尝试通过CAS 来自增工作线程的个数，如果自增成功了，则会创建新的工作线程，即Worker对象。然后加锁进行二次验证是否能够创建工作线程，最后如果创建成功，则会启动该工作线程。</p><p><strong>启动工作线程</strong></p><p>当工作线程创建成功后，也就是 Worker对象已经创建好了，这时就需要启动该工作线程，让线程开始干活了，Worker对象中关联着一个 Thread，所以要启动工作线程的话，只要通过worker.thread.start() 来启动该线程即可。启动完了之后，就会执行 Worker对象的 run 方法，因为 Worker 实现了 Runnable 接口，所以本质上 Worker也是一个线程。通过线程 start 开启之后就会调用到 Runnable 的 run 方法，在worker 对象的 run 方法中，调用了 runWorker(this)方法，也就是把当前对象传递给了 runWorker 方法，让他来执行。</p><p><strong>获取任务并执行</strong></p><p>在 runWorker方法被调用之后，就是执行具体的任务了，首先需要拿到一个可以执行的任务，而Worker对象中默认绑定了一个任务，如果该任务不为空的话，那么就是直接执行。执行完了之后，就会去阻塞队列中获取任务来执行，而获取任务的过程，需要考虑当前工作线程的个数。如果工作线程数大于核心线程数，那么就需要通过poll来获取，因为这时需要对闲置的线程进行回收;如果工作线程数小于等于核心线程数，那么就可以通过take来获取了，因此这时所有的线程都是核心线程，不需要进行回收，前提是没有设置allowCoreThreadTimeOut。</p><h4 id="线程池为何要构建空任务的非核心线程">22.线程池为何要构建空任务的非核心线程？</h4><ul><li>当任务扔到阻塞队列中之后，工作线程个数为0，则需要添加一个空任务的非核心工作线程。</li><li>工作线程已经启动后，会执行runworker方法，在runworker方法中工作线程要结束之后，会执行一次processWorkerExit方法，而这个方法内部添加一个空任务的非核心工作线程。</li></ul><p>出现场景：当把任务添加到工作队列或者阻塞队列当中之后，发现没有工作线程，此时线程池中的任务就会饥饿，没有线程能够处理阻塞队列当中的任务。则任务将会一直在阻塞队列中放置，直到有新任务添加进来，才有可能再去创建工作线程，才会执行放在阻塞队列中存放的任务。这样导致任务的处理实际太晚了。</p><p>出现原因：</p><p>1.在构建工作线程或者构建线程池对象的时候，会对参数做一些校验，其中核心线程数是不允许小于0的（但是可以等于0），这样导致核心线程数为0个，则在执行excute方法时，添加核心线程的操作就进不去，就会把任务扔到阻塞队列中去。</p><p>2.核心线程默认情况下是不允许超时的（核心线程在处理完一个任务，即便空闲了多久，都不会把这个核心线程取消掉），但如果将allowCoreThreadTimeOut属性设置为true，则如果时间到了，核心线程就会被取消掉。</p><h4 id="线程池使用完毕为何必须shutdown">23.线程池使用完毕为何必须shutdown()？</h4><p><em>（先说不shutdown会出现什么问题，其次执行shutdown是如何帮助解决这个问题的）</em></p><p>造成的问题：</p><p>1.核心线程不会被回收，会造成内存泄漏问题</p><p>2.Worker对象不会被回收，而Worker对象属于线程池的内部类，会造成整个线程池对象不会被回收</p><p>如何解决：而执行shutdown()后，将线程池的状态从RUNNING改为了SHUTDOWN，所有阻塞的工作线程都会通过SHUTDOWN跳出获取内容</p><h4 id="线程池的核心参数如何设置">24.线程池的核心参数如何设置？</h4><p>因为任务类型有CPU密集型，IO密集型，甚至有混合型，因为IO我们无法直接控制，所以想要调试出一个符合任务情况的核心参数，最好的方式就是测试需要将项目部署到测试环境或者是沙箱环境像结果各种压测得到一个相对符合的参数。如果每次修改项目都需要重新部署，成本太高了。此时可以实现一个动态监控以及修改线程池的方案。</p><p><strong>核心线程数，拒绝策略</strong>：通过线程池中提供的获取核心信息的get方法来测试CPU的负载情况，若CPU没有被压榨的太好，则可以通过线程池提供的动态修改核心属性的set方法来动态修改一些核心属性，此时线程池会根据内部的一些判断规则，很平滑的把线程池的核心参数调整到最新设置的程度</p><p><strong>工作队列的长度</strong>：需要根据内存的情况查看最多可以做多少个任务，以及任务可以延迟多久来决定</p><h4 id="concurrenthashmap在1.8做了什么优化">25.ConcurrentHashMap在1.8做了什么优化？</h4><p>1.<strong>存储结构</strong>：将原先table数组＋单向链表的数据结构，变成table数组+单向链表+<strong>红黑树</strong>的结构。</p><p>对于个数超过8(默认值)的列表，在jdk1.8中链表就会转化为红黑树，查询的时间复杂度可以降低到O(logN)，可以改进性能。</p><p>2.<strong>存储操作</strong>：ConcurrentHashMap在JDK1.8中是以CAS+synchronized锁头节点的方式实现的线程安全。数组长度有多少，锁的级别就有多少。在没有hash冲突时（Node要放在数组上时），采用CAS；在出现hash冲突时（Node存放的位置已经有数据了），采用synchronized</p><p>3.<strong>扩容操作</strong>：采取了协助扩容操作：如果正在扩容，则帮助扩容，加快扩容的效率。等扩容完毕后，将要写入的数据写到新数组上。</p><p>4.<strong>计数器</strong>：1.8的计数器采用了分而治之的思想，将计数器拆分成多个，效率相比于之前会更高</p><h4 id="concurrenthashmap">26.ConcurrentHashMap</h4><ul><li>散列算法</li><li>初始化数组的流程</li><li>扩容的流程</li><li>读取数据的流程</li><li>计数器的实现</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试题</title>
      <link href="/2023/03/17/redis/"/>
      <url>/2023/03/17/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="redis">Redis</h2><h4 id="redis为什么快">1.Redis为什么快？</h4><ul><li><strong>纯内存访问</strong>：数据存在内存中，绝大部分请求是纯粹的内存操作，非常快速，跟传统的磁盘文件数据存储相比，避免了通过磁盘IO读取到内存这部分的开销。</li><li><strong>单线程避免上下文切换</strong>：省去了很多上下文切换的时间以及CPU消耗，不存在竞争条件，不用去考虑各种锁的问题，不存在加锁释放锁操作，也不会出现死锁而导致的性能消耗。</li><li><strong>采用I/O多路复用机制的线程模型</strong>，可以处理并发的链接。</li><li><strong>渐进式ReHash</strong>：<code>Redis</code>采用渐进式<code>ReHash</code>，他把<code>Rehash</code>过程中哈希表1中的数据重新映射并拷贝到哈希表2中这一个把涉及大量的数据拷贝，会造成<code>Redis</code>线程阻塞的过程分摊到多次请求处理的过程中，从而避免了耗时操作，保证了数据的快速访问。</li><li><strong>缓存时间戳</strong>：<code>Redis</code>每一次获取系统时间戳都是一次系统调用，所以它需要对时间进行缓存，由一个定时任务，每毫秒更新一次时间缓存，获取时间都是从缓存中直接拿，而不需要调用系统，这样也可以加快<code>Redis</code>的调用速度。</li></ul><h4 id="redis合适的应用场景">2.Redis合适的应用场景？</h4><ul><li><strong>缓存</strong>：作为<code>Key-Value</code>形态的内存数据库，<code>Redis</code>最先会被想到的应用场景便是作为数据缓存。合理的利用<code>Redis</code>作为缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。</li><li><strong>计数器</strong>：为了保证如文章的阅读量、微博点赞数、视频网站视频的播放数等数据的时效性，每次浏览都需要将计数+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。我们可以先写入<code>Redis</code>再定时同步到数据库，<code>Redis</code>提供的<code>incr</code>命令来实现计数器功能，直接在内存操作，性能非常好，非常适用于这些计数场景。</li><li><strong>分布式会话</strong>：集群模式下，在应用不多的情况下一般使用容器自带的<code>session</code>复制功能就能满足，当在应用增多且相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的<code>session</code>服务，<code>session</code>不再由容器管理，而是由<code>session</code>服务及内存数据库管理。</li><li><strong>排行榜</strong>：很多网站目前都有排行榜的应用，如淘宝的每日销量榜单、商品按时间的上新排行榜等。利用Redis的zset结构能实现各种复杂的排行榜应用。</li><li><strong>最新列表</strong>：比如说，当我们想要在网页上列出用户的最新20条评论，在最新的评论边上我们有一个"显示全部"的链接，点击后就可以获得更多的评论。<code>Redis</code>列表结构，<code>LPUSH</code>可以在列表头部插入一个内容ID作为关键字，<code>LTRIM</code>可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。</li><li><strong>分布式锁</strong>：在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用<code>Redis</code>的<code>setnx</code>功能来编写分布式的锁。</li><li><strong>消息队列</strong>：<code>Redis</code>提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外<code>Redis</code>中<code>list</code>的数据结构实现是双向链表，所以可以非常便捷的应用于消息队列（生产者/消费者模型）。消息的生产者只需要通过<code>lpush</code>将消息放入<code>list</code>，消费者便可以通过<code>rpop</code>取出该消息，并且可以保证消息的有序性。如果需要实现带有优先级的消息队列也可以选择<code>sorted set</code>。而<code>pub/sub功能</code>也可以用作发布者/订阅者模型的消息。无论使用何种方式，由于<code>Redis</code>拥有持久化功能，也不需要担心由于服务器故障导致消息丢失的情况。</li><li><strong>限流</strong>：在某些秒杀活动中，瞬间会有大量的用户请求涌入，而且大概率也会出现同一用户不断刷新页面或者其他操作来发送大量请求的情况，这时候我们就可以采取限流措施。那如何实现限流呢？我们可以利用<code>Redis</code>的<code>incr</code>方法，以访问者的ip和其他信息作为key，访问一次增加一次计数，当同一用户的访问次数超过我们预先设定的次数则返回提示信息（比如提示用户操作过于频繁，一定时间之后再重新操作等等）。</li></ul><h4 id="redis6.0之前为什么一直不使用多线程">3.Redis6.0之前为什么一直不使用多线程？</h4><ul><li>使用<code>Redis</code>时，几乎不存在CPU成为瓶颈的情况，<code>Redis</code>主要受限于<strong>内存</strong>和<strong>网络</strong>。</li><li>在一个普通的Linux系统上，<code>Redis</code>通过使用<code>pipelining</code>每秒可以处理100万个请求，它几乎不会占用太多CPU。</li><li>单线程、内部维护成本较低。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。</li><li><code>Redis</code>通过AE事件模型以及IO多路复用等技术，处理性能非常高，因此没有必要使用多线程。单线程机制使得<code>Redis</code>内部实现的复杂度大大降低，渐进式<code>Rehash</code>、<code>Lpush</code>等等"线程不安全"的命令都可以无锁进行。</li></ul><h4 id="redis6.0为什么要引入多线程">4.Redis6.0为什么要引入多线程？</h4><ul><li>Redis6.0的多线程是指，将<strong>网络数据读写</strong>和<strong>协议解析</strong>通过多线程的方式来处理，对于命令执行来说，仍然使用单线程操作。也就是说，Redis6.0的多线程是为了解决其网络IO的瓶颈。</li><li>在<code>Redis</code>中，单线程的性能瓶颈主要在<strong>网络IO操作</strong>上。也就是<strong>在读写网络的read/write系统调用执行期间会占用大部分CPU时间</strong>。数据转入内存，响应时间100纳秒。对于较小的数据表，可以到达每秒8-10万的QPS（极限值）。使用多线程可以解决更大的QPS，所以采用了IO的多线程（内部执行命令还是单线程），可以把多线程的分摊到<code>Redis</code>的同步IO中读写负载（<strong>核心原因：为了使Redis能够抗住更大的并发——针对大数据业务场景</strong>）。</li></ul><h4 id="redis有哪些高级功能">5.Redis有哪些高级功能？</h4><p><em>（有哪些高级功能+高级功能的详细了解）</em></p><ul><li><p><strong>慢查询</strong>：帮助开发和运维人员定位系统存在的慢操作（如发生时间，耗时，命令的详细信息）。</p><ul><li>慢查询日志由以下四个属性组成：标识ID、发生时间戳、命令耗时、执行命令和参数。</li></ul></li><li><p><strong>Pipeline</strong>：批量处理数据，有效地节约<code>RTT</code>。</p></li><li><p><strong>事务</strong>：<code>Redis</code>事务的本质是一组命令的集合，<code>Redis</code>事务具有以下几点特性：</p><ul><li><p><code>Redis</code>的事务是通过<code>multi、exec、discard、watch</code>这四个命令来完成的</p><ul><li><p><code>Redis</code>的单个命令都是原子性的，所以这里需要确保事务性的对象是命令集合</p></li><li><p><code>Redis</code>将命令集合序列化并确保处于同一事务的命令集合连续且不被打断的执行</p></li><li><p><code>Redis</code>不能保障失败回滚</p></li></ul></li></ul></li><li><p><strong>Lua</strong>：<code>lua</code>是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。在<code>Redis</code>中使用<code>lua</code>脚本具有以下好处：</p><ul><li>减少网络开销。可以将多个请求通过脚本的形式一次发送，减少网络时延</li><li>原子操作。<code>redis</code>会将整个脚本作为一个整体执行，中间不会被其他命令插入。因此在编写脚本的过程中无需担心会出现竞态条件，无需使用事务。</li><li>复用。客户端发送的脚本会永久存在<code>redis</code>中，这样，其他客户端可以复用这一脚本而不需要使用代码完成相同的逻辑。</li></ul></li><li><p><strong>RDB-AOF混合持久化</strong>：</p><ul><li>RDB：<code>redis</code>数据快照，把内存中所有数据存储到磁盘中。当<code>redis</code>实例故障重启后，从磁盘读取快照文件，恢复数据。</li><li>AOF：<code>redis</code>追加文件，<code>redis</code>处理的每一个写命令都会记录在AOF文件中，可以看作是命令日志文件。</li><li>RDB-AOF混合持久化：RDB以一定的频率执行，在两次RDB之间，使用AOF日志记录这期间的所有命令操作。</li></ul></li></ul><h4 id="为什么要用redis">6.为什么要用Redis？</h4><ul><li><p><strong>高性能</strong>：假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。这样可以保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。不过，要保持数据库和缓存中的数据的一致性。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可。</p></li><li><p><strong>高并发</strong>：一般像 MySQL 这类的数据库的 QPS 大概都在1w 左右，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到30w+。所以，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高的系统整体的并发。</p></li></ul><h4 id="redis与memcached相比有哪些优势">7.Redis与Memcached相比有哪些优势？</h4><table><colgroup><col style="width: 10%"><col style="width: 63%"><col style="width: 26%"></colgroup><thead><tr class="header"><th></th><th>Redis</th><th>Memcached</th></tr></thead><tbody><tr class="odd"><td>整体类型</td><td>1.支持内存<br>2.非关系型数据库</td><td>1.支持内存<br>2.key-value</td></tr><tr class="even"><td>数据类型</td><td>1.String<br>2.List<br>3.Set<br>4.ZSet<br>5.Hash</td><td>1.文本型<br>2.二进制类型</td></tr><tr class="odd"><td>操作类型</td><td>1.单个操作<br>2.批量操作<br>3.事务操作（弱事务、可以结合Lua）<br>4.每个类型不同的CURD</td><td>1.CURD<br>2.少量其他命令</td></tr><tr class="even"><td>附加功能</td><td>1.分布<br>2.主从高可用（哨兵--&gt;完成故障转移）<br>3.序列化支持<br>4.支持Lua脚本</td><td>多线程服务支持</td></tr><tr class="odd"><td>网络IO模型</td><td>执行命令——单线程<br>网络操作——多线程</td><td>多线程、非阻塞的IO模式</td></tr><tr class="even"><td>持久化</td><td>1.RDB<br>2.AOF</td><td>不支持</td></tr><tr class="odd"><td>其他</td><td>支持集群</td><td>不支持原生集群</td></tr></tbody></table><p>在整体类型上，Redis是一种非关系型数据库，其逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作。</p><p>在数据类型上，Redis支持String，list，set，zset，hash丰富的数据类型，而Memcached仅支持文本型和二进制类型的数据类型。</p><p>在操作类型上，Redis不仅支持单个以及批量操作，其还支持事务操作以及针对每个类型不同的CURD。</p><p>在附加功能上，Redis具有分布，主从高可用，序列化支持并支持Lua脚本，具有丰富的高级功能。</p><p>在持久化上，Redis具有RDB+AOF的混合持久化，而Memcached不支持持久化。</p><p>此外，Redis还支持集群。</p><h4 id="怎么理解redis中的事务">8.怎么理解Redis中的事务？</h4><p>事务表示一组动作，要么全部执行，要么全部不执行。</p><p>Redis提供了简单的事务功能，其通过multi、exec、discard和watch这四个命令来完成。Redis将一组需要一起执行的命令放到multi和exec两个命令之间。multi命令代表事务开始，exec命令代表事务结束。</p><p>原理：事务是Redis实现在<strong>服务器端</strong>的行为，用户执行MULTI命令时，服务器会将对应这个用户的<strong>客户端对象</strong>设置为一个特殊的状态，在这个状态下后续用户执行的查询命令不会被真的执行，而是被服务器缓存起来，直到用户执行EXEC命令为止，服务器会将这个用户对应的客户端对象中缓存的命令按照提交的顺序依次执行。</p><p>此外，Redis的事务功能很弱。并且在事务回滚机制上，Redis只能对<strong>基本的语法错误</strong>进行判断。（不能判断运行时错误）</p><h4 id="redis的过期策略以及内存淘汰机制">9.Redis的过期策略以及内存淘汰机制</h4><p><strong>过期策略</strong>：</p><p>Redis采用的是定期删除+惰性删除策略。</p><ul><li><strong>定期删除</strong>：Redis默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的key，而是采用了一种简单的贪心策略。</li><li><strong>惰性删除</strong>：定期删除可能会导致很多过期key到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个key，才会被redis给删除掉。这就是所谓的惰性删除，即当你主动去查过期的key时，如果发现key过期了，就立即进行删除，不返回任何东西。在客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西。</li></ul><p><strong>内存淘汰机制</strong></p><p>定期删除+惰性删除策略存在的问题：如果某个key过期后，定期删除没删除成功（没抽取到），然后也没再次去请求key，也就是说惰性删除也没生效。这时，如果大量过期的key堆积在内存中，redis的内存会越来越高，导致redis的内存块耗尽。那么就应该采用<strong>内存淘汰机制</strong>。</p><p>当 Redis内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换(swap)。</p><ul><li><p>Noeviction：不进行淘汰数据。一旦缓存被写满，再有写请求进来，Redis就不再提供服务，而是直接返回错误。</p></li><li><p>volatile-lru：在设置了过期时间的键值对中，移除最近最少使用的键值对。</p></li><li><p>volatile-lfu：在设置了过期时间的键值对中，移除最不经常使用的键值对（历史访问频率）。</p></li><li><p>volatile-ttl：在设置了过期时间的键值对中，移除即将过期的键值对。</p></li><li><p>volatile-random：在设置了过期时间的键值对中，随机移除某个键值对。</p></li><li><p>allkeys-lru：在所有的键值对中，移除最近最少使用的键值对。</p></li><li><p>allkeys-random：在所有的键值对中，移除最不经常使用的键值对。</p></li><li><p>近似LRU算法：Redis 使用的是一种近似 LRU算法，它跟LRU算法不太一样。之所以不使用LRU算法，是因为需要消耗大量的额外的内存，需要对现有的数据结构进行较大的改造。近似LRU算法则很简单，在现有数据结构的基础上使用随机采样法来淘汰元素，能达到和LRU算法非常近似的效果。Redis为实现近似LRU算法，它给每个key增加了一个额外的小字段，这个字段的长度是24个bit，也就是最后一次被访问的时间戳。当Redis执行写操作时，发现内存超出maxmemory，就会执行一次LRU淘汰算法。这个算法也很简单，就是随机采样出5 (可以配置maxmemory-samples)个key，然后淘汰掉最旧的key，如果淘汰后内存还是超出maxmemory，那就继续随机采样淘汰，直到内存低于maxmemory为止。</p></li></ul><h4 id="什么是缓存穿透如何避免">10.什么是缓存穿透？如何避免？</h4><p>缓存穿透指的是：同一时刻，大量的并发请求数据库中不存在的信息（如发起为id为“-1”的数据或id为特别大不存在的数据。），他既不会命中缓存，也不会命中数据库，但是他会查找数据库。由于大量的并发请求到达数据库，而数据库承受不住这么高的并发，从而导致数据库奔溃，这就是缓存穿透。</p><p>解决方案：</p><ul><li><strong>将空数据存入缓存</strong>：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key 对应的数据 insert 了之后清理缓存。</li><li><strong>布隆过滤器</strong>：在访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来，做第一层拦截，当收到一个对key请求时先用布隆过滤器验证是key否存在，如果存在在进入缓存层、存储层。可以使用bitmap做布隆过滤器。<ul><li>布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。</li></ul></li></ul><h4 id="什么是缓存击穿如何避免">11.什么是缓存击穿？如何避免？</h4><p>缓存击穿是指：热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到数据库，引起数据库压力瞬间增大，造成过大压力。并且在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。</p><p>解决方案：</p><ul><li><strong>分布式互斥锁</strong>：当同个业务不同线程访问redis未命中时，先获取一把互斥锁，然后进行数据库操作，此时另外一个线程未命中时，拿不到锁，等待一段时间后重新查询缓存，此时之前的线程已经重新把数据加载到redis之中了，线程二就直接缓存命中。这样就不会使得大量访问进入数据库。</li><li><strong>逻辑过期</strong>：给缓存设置一个逻辑过期时间，为了防止缓存击穿，我们以一种预判的方式，主动设置一个过期时间，当然这个时间过期了，缓存里面的数据是不会消失的，但是我们只需要根据这个假设的过期时间来进行经常的动态的缓存数据的更新。可以对缓存击穿起一定的预防作用。</li><li><strong>永不过期</strong>：在设置热点key的时候，不给key设置过期时间即可。</li></ul><h4 id="什么是缓存雪崩如何避免">12.什么是缓存雪崩？如何避免？</h4><p>原因：当缓存中有大量的key在同一时刻过期，或者Redis直接宕机了，导致大量的查询请求全部到达数据库，造成数据库查询压力骤增，甚至直接挂掉。</p><p>解决方案：</p><ul><li>引入集群，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务。</li><li>搭建多级缓存，把高并发的数据请求放到EHCache中</li><li>加入限流组件，如hystrix，当用户请求超过一定流量时，加一些限制</li><li>将过期时间岔开，对key在原来过期时间的基础上生成一个随机时间，这个随机时间比较小，然后两者相加即可（例如60s+(0~1s)）。</li></ul><h4 id="使用redis如何设计分布式锁">13.使用Redis如何设计分布式锁？</h4><p>分布式锁：控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。想要实现分布式锁，必须要求Redis 有<strong>互斥</strong>的能力。</p><p>① 使用 SETNX 命令，即如果 key不存在，才会设置它的值，否则什么也不做。客户端进程可以执行这个命令，达到互斥，就可以实现一个分布式锁。假如客户端1在获取到锁资源后，服务宕机了，那么向redis中写入的数据会一直存在redis中，其他服务就永远无法获取到锁了（死锁问题）。</p><p>② 针对①中的<strong>死锁</strong>问题，给这个 key设置一个过期时间。假设操作共享资源的时间不会超过10s，那么在加锁时，给这个key 设置 10s过期即可。假如服务A加锁成功，锁会在10s后自动释放，但由于业务复杂，执行时间过长，10s内还没执行完，此时锁已经被redis自动释放掉了。此时服务B就重新获取到了该锁，服务B开始执行他的业务，服务A在执行到第12s的时候执行完了，那么服务A会去释放锁，则此时释放的却是服务B刚获取到的锁。</p><p>③针对②中<strong>锁过期时间不好评估</strong>的问题，加入<strong>看门狗</strong>线程。加锁时，先设置一个过期时间，然后开启<strong>守护线程</strong>，定时去检测这个锁的失效时间，如果锁快要过期了操作共享资源还未完成，那么就自动对锁进行<strong>续期</strong>，重新设置过期时间。</p><h4 id="如何使用redis实现消息队列">14.如何使用Redis实现消息队列？</h4><ul><li><p><strong>基于List的LPUSH+RPOP的实现</strong></p><p>使用<strong>rpush</strong>和<strong>lpush</strong>操作入队列，<strong>lpop</strong>和<strong>rpop</strong>操作出队列。</p><p>优点：足够简单，消费消息延迟几乎为0</p><p>缺点：</p><p>①需要处理空闲连接的问题。如果线程一直阻塞在那里，Redis客户端的连接就成了闲置连接，闲置过久，服务器一般会主动断开连接，减少闲置资源占用，这个时候blpop或brpop会抛出异常，所以在编写客户端消费者的时候要小心，如果捕获到异常，还有重试。</p><p>②做消费者确认ACK麻烦，不能保证消费者消费消息后是否成功处理的问题(宕机或处理异常等)，通常需要维护一个Pending列表，保证消息处理确认</p><p>③ 不能做广播模式，如pub/sub，消息发布/订阅模型</p><p>④ 不能重复消费，一旦消费就会被删除</p><p>⑤ 不支持分组消费</p></li><li><p><strong>基于Sorted-Set的实现</strong></p><p>优点：可以实现延迟队列</p><p>缺点：消费者无法阻塞的获取消息，只能轮询，不允许重复消息。</p></li><li><p><strong>PUB/SUB，订阅/发布模式</strong></p><p>SUBSCRIBE，用于订阅信道；PUBLISH，向信道发送消息；UNSUBSCRIBE，取消订阅</p><p>此模式允许生产者只生产一次消息，由中间件负责将消息复制到多个消息队列，每个消息队列由对应的消费组消费。</p><p>优点：</p><p>① 典型的广播模式，一个消息可以发布到多个消费者</p><p>② 多信道订阅，消费者可以同时订阅多个信道，从而接收多类消息</p><p>③消息即时发送，消息不用等待消费者读取，消费者会自动接收到信道发布的消息。</p><p>缺点: ①消息一旦发布，不能接收。换句话就是发布时若客户端不在线，则消息丢失，不能寻回</p><p>② 不能保证每个消费者接收的时间是一致的</p><p>③若消费者客户端出现消息积压，到一定程度，会被强制断开，导致消息意外丢失。通常发生在消息的生产远大于消费速度时。</p><p>可见，Pub/Sub模式不适合做消息存储，消息积压类的业务，而是擅长处理广播，即时通讯，即时反馈的业务。</p></li><li><p><strong>基于Stream类型的实现</strong> <em>（重点）</em></p><p>Stream提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p><p>Stream<strong>有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的ID和对应的内容</strong>。<strong>消息是持久化的</strong>，Redis重启后，内容还在。每个Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd指令追加消息时自动创建。</p><p>优点：</p><p>​ ① 支持"阻塞式"拉取消息：读取消息时，只需要增加 BLOCK参数即可支持"阻塞式"拉取消息。这时，消费者就会阻塞等待，直到生产者发布新的消息才会返回。</p><p>​ ② 支持发布 / 订阅模式</p><p>​ ③ 能保证消息不丢失，重新消费：消费者异常宕机重新上线后，Redis就会把之前没有处理成功的数据，重新发给这个消费者。</p><p>​ ④ 数据会写入到RDB和AOF做持久化：Stream每个写操作都会写入到 RDB 和AOF 中。我们只需要配置好持久化策略，这样的话，就算 Redis宕机重启，Stream 中的数据也可以从 RDB 或 AOF 中恢复回来。</p></li></ul><h4 id="什么是bigkey会有什么影响">15.什么是bigkey？会有什么影响？</h4><p>bigkey是指key对应的<strong>value</strong>所占的内存空间比较大。按照数据结构来细分的话，一般分为字符串类型bigkey和非字符串类型bigkey。</p><p>字符串类型：体现在单个value<strong>值很大</strong>，一般认为超过10KB就是bigkey，但这个值和具体的OPS相关。非字符串类型：哈希、列表、集合、有序集合，体现在<strong>元素个数</strong>过多。</p><p>影响：</p><ul><li>内存空间不均匀.(平衡)：例如在Redis Cluster中，bigkey会造成节点的内存空间使用不均匀。</li><li>超时阻塞：由于Redis单线程的特性，操作bigkey比较耗时，也就意味着阻塞Redis可能性增大。</li><li>网络拥塞：每次获取bigkey产生的网络流量较大</li></ul><p>注：如果这个bigkey存在但是几乎不被访问，那么只有内存空间不均匀的问题存在，相对于另外两个问题没有那么重要紧急。但是如果bigkey是一个热点key(频繁访问)，那么其带来的危害不可想象。</p><h4 id="redis如何解决key冲突">16.Redis如何解决key冲突？</h4><p>当有两个或以上数量的key被分配到了哈希表数组的同一个索引上面时，我们称这些key发生了冲突（collision）。</p><ul><li>业务隔离：不同的业务使用不同的redis集群，或者协议使用redis的不同数据库。</li><li>key的设计：业务模块+系统名称+关键字(biz-pay-orderid)</li><li>分布式锁：解决多个客户端并发写一个key的问题。需要客户端拿到锁才能进行操作。</li><li>时间戳：</li></ul><h4 id="如何提高缓存命中率">17.如何提高缓存命中率？</h4><ul><li>提前加载数据：提前将MySQL的数据加载到Redis中</li><li>增加缓存的存储空间，提高缓存的数据</li><li>调整缓存的存储类型，根据业务情况适当的调整缓存的类型</li><li>提升缓存的更新频次</li></ul><h4 id="redis持久化方式有哪些有什么区别">18.Redis持久化方式有哪些？有什么区别？</h4><p>redis提供了三种持久化方式，分别是RDB，AOF以及RDB+AOF的混合持久化方式。</p><ul><li><p><strong>RDB</strong></p><ul><li>定义：在指定的时间间隔对数据进行快照存储（快照存储方式）</li><li>redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。</li><li>优点：<ul><li>一旦采用该方式，那么整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li><li>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</li><li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</li><li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li></ul></li><li>缺点：<ul><li>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</li><li>数据比较大会造成堵塞，不适合实时持久化。由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li></ul></li></ul></li><li><p><strong>AOF</strong></p><ul><li>定义：记录服务器每次写的操作，当服务器重启时会执行命令来恢复原来的数据</li><li><strong>AOF</strong>以日志的形式来记录每个<strong>写</strong>操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作.</li><li>优点：<ul><li>该机制可以带来更高的数据安全性，即数据持久性。</li><li>由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。</li><li>如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</li><li>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li></ul></li><li>缺点：<ul><li>对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB在恢复大数据集时的速度比 AOF 的恢复速度要快。</li><li>根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</li></ul></li></ul></li><li><p><strong>混合方式</strong>（适用于高并发的场景中）</p><ul><li><p>定义：<strong>RDB以一定的频率执行</strong>，在两次RDB之间，使用AOF日志记录这期间的所有命令操作。</p></li><li><p>优点：快照不用很频繁地执行，这就<strong>避免了频繁 fork对主线程的影响</strong>。而且，AOF日志也只用记录两次快照间的操作，就<strong>不会出现文件过大的情况了</strong>，也可以<strong>避免重写开销。</strong></p></li></ul></li></ul><h4 id="为什么redis需要把所有数据放到内存中">19.为什么Redis需要把所有数据放到内存中？</h4><p>内存访问速度是纳秒级，硬盘的访问速度是微秒级，内存的读取速度是最快的，Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。</p><h4 id="如何保证缓存与数据库双写时的数据一致性">20.如何保证缓存与数据库双写时的数据一致性？</h4><p><strong>更新缓存类</strong></p><ul><li><p><strong>先更新缓存，再更新数据库</strong></p><p>一般不考虑，若更新缓存成功，更新数据库出现异常了，会导致缓存数据与数据库数据完全不一致，而且很难察觉，因为缓存中的数据一直都存在。</p></li><li><p><strong>先更新数据库，再更新缓存</strong></p><p>一般不考虑，若数据库更新成功了，缓存更新失败，同样会出现数据不一致问题。</p></li></ul><p><strong>删除缓存类（倾向）</strong></p><ul><li><p><strong>先删除缓存，后更新数据库</strong></p><p>请求A（更新操作）和请求B（查询操作），A先删除Redis中的数据，然后去更新数据库。但是B看到Redis数据空了后，会去数据库查询，然后补录到Redis中。但此时A没有更新成功，B去数据库查得旧值，补录到Redis中的也是旧值，会造成数据库和Redis数据不一致的问题。</p><p>解决方案：<strong>延时双删</strong>（写数据库之前删除一次，写完数据库后，再删除一次。）</p><p>​ ① 淘汰缓存</p><p>​ ② 再写数据库</p><p>​ ③休眠1秒，再淘汰缓存</p></li><li><p><strong>先更新数据库，后删除缓存</strong>（CAP）</p></li></ul><p>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</p><p>更新的时候，先更新数据库，然后再删除缓存。</p><h4 id="redis集群方案应该怎么做">21.Redis集群方案应该怎么做？</h4><ul><li><p><strong>RedisCluster</strong>：当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的</p></li><li><p>Redis利用了<strong>虚拟槽分区</strong>，可以算虚拟一致性哈希分区的变种，它使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽(slot)。这个范围一般远远大于节点数，比如RedisCluster槽范围是0~16383。槽是集群内数据管理和迁移的基本单位。采用大范围槽的主要目的是为了方便数据拆分和集群扩展。每个节点会负责一定数量的槽。</p></li></ul><p>集群的搭建方案：</p><ul><li><p>依照Redis协议手工搭建，使用cluster meet、clusteraddslots、cluster replicate命令。</p></li><li><p>Redis5.0之前使用由ruby语言编写的redis-trib.rb，在使用前需要安装ruby语言环境。</p></li><li><p>Redis5.0及其之后redis摒弃了redis-trib.rb，将搭建集群的功能合并到了redis-cli。<em>（采用）</em></p></li></ul><p><em>（节点配置——集群创建（创建集群随机主从节点，指定主从节点）——集群管理（检查集群，集群信息查看，修复集群，设置集群的超时时间，集群配置））</em></p><p><em>（集群伸缩（集群扩容，集群缩容，迁移等），集群原理（节点通信，故障转移（故障发现，故障恢复，集群不可用判定，集群读写分离）））</em></p><h4 id="redis集群方案什么情况会导致整个集群不可用">22.Redis集群方案什么情况会导致整个集群不可用？</h4><ul><li><p>集群不可用判定</p><p>为了保证集群完整性，默认情况下当集群16384个槽任何一个没有指派到节点时，整个集群不可用。这是对集群完整性的一种保护措施，保证所有的槽都指派给在线的节点。但是当持有槽的主节点下线时，从故障发现到自动完成转移期间整个集群是不可用状态。</p></li><li><p>从集群的故障转移的原理来说，当以下情况发生时，集群会出现不可用：</p><p>①当访问一个主节点和从节点发生宕机的时候，cluster-require-full-coverage=yes，会报槽无法获取。</p><p>② 集群主节点半数宕机</p><p>③ 当集群 Master节点个数小于3个的时候，或者集群可用节点个数为偶数的时候，基于 fail的这种洗举机制的自动主从切换过程可能会不能正常工作，一个是标记 fail的过程，一个是选举新的 master 的过程，都有可能异常。</p></li></ul><h4 id="说一说redis哈希槽的概念">23.说一说Redis哈希槽的概念</h4><p>Redis利用了<strong>虚拟槽分区</strong>，可以算虚拟一致性哈希分区的变种，它使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为哈希槽(slot)。这个范围一般远远大于节点数。槽是集群内数据管理和迁移的基本单位。采用大范围槽的主要目的是为了方便数据拆分和集群扩展。每个节点会负责一定数量的槽。Redis集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个key-value时，redis 先对 key 使用 CRC16 算法算出一个结果，然后把结果对16384 求余数，这样每个 key 都会对应一个编号在 0-16383之间的哈希槽，redis会根据节点数量大致均等的将哈希槽映射到不同的节点。</p><p><em>（哈希分区——一致性哈希分区——一致性虚拟哈希分区——哈希槽的分区）</em></p><h4 id="redis集群会有写操作丢失吗为什么">24.Redis集群会有写操作丢失吗？为什么？</h4><p>Redis通过异步的方式进行数据备份，不能确保数据的强一致性，所以有可能会有写数据的丢失。</p><p>例如：一主多从结构中，当主节点接收用户数据还没有写到从节点时，主节点发生宕机，则从节点会发生数据丢失</p><h4 id="redis常见性能问题和解决方案有哪些">25.Redis常见性能问题和解决方案有哪些？</h4><ul><li><p><strong>持久化性能问题</strong></p><p>Redis早期时只支持全量复制、部分复制，在一台机器上是会产生大量的CPU，内存，网络等开销</p><p>解决方案：主从架构。主节点不要做持久化，从节点做持久化。</p></li><li><p><strong>对重要数据开启AOF持久化问题</strong></p><p>解决方案：对从(slave)节点开启AOF，策略每秒同步一次。</p></li><li><p><strong>主从节点之间复制的流畅性</strong></p><p>解决方案：使用同一个局域网</p></li><li><p>尽量避免在搭建主从架构时，主库压力大的时候搭建从库</p></li><li><p>主从复制时，尽量不要采用网状结构，而是采用线性结构（在从库同步数据时，可以减轻主库的压力）</p></li></ul><h4 id="热点数据和冷数据是什么">26.热点数据和冷数据是什么？</h4><ul><li><p><strong>热数据</strong></p><p>访问频次比较高的数据。</p><p>例如：网站中的点赞数，收藏数。这些数据在不断地变化，可以考虑使用Redis进行缓存，减少DB的压力</p><p>数据在更新之前至少需要读取2次，才考虑把数据放入到缓存中</p></li><li><p><strong>冷数据</strong></p><p>若数据在更新之前仅读了一次或没有被读，则把其称之为冷数据。（不放到Redis中）</p></li></ul><h4 id="什么情况下可能会导致redis阻塞">27.什么情况下可能会导致Redis阻塞？</h4><ul><li><p><strong>客户端阻塞</strong></p><p>Redis针对IO采用了多路复用，在处理时有很多命令（例如：keys*，Hgetall，smembers）执行时间会很长，时间复杂度O(N)，元素越多，返回的数据量越大，时间复杂度越高</p></li><li><p><strong>BIGkey的删除</strong></p><p>BIGkey的删除过程会一下释放出大量的占用空间，操作系统需要把这块释放的内存插入一个空闲内存块的链表当中，以便后续管理和再分配。这个过程会阻塞当前释放内存的应用程序，也就会造成Redis主线程的阻塞。（例如，删除zset中100万的元素，删除时间为2s）</p></li><li><p><strong>清空库</strong></p><p>主从复制时，主节点变成从节点时，需要清空库，执行如flush db，flushall等命令会造成阻塞</p></li><li><p><strong>AOF日志同步写</strong></p><p>写操作时需要记录AOF日志，若有大量的写操作，并且配置的是同步写回的话，就会阻塞主线程了。一个同步写磁盘的操作的耗时大约1~2ms，如果有大量写操作需要记录到AOF日志并同步写回，就会阻塞主线程。</p></li><li><p><strong>从库加载RDB文件</strong></p></li></ul><p>​ 在主从集群中，主库生成 RDB文件，并传输给从库。主从复制过程的创建和传输RDB都是子进程处理的，不会阻塞主线程。但是从库在接收了 RDB文件后，需要使用 FLUSHDB命令清空当前数据库，而且，在从库清空数据库后，需要将 RDB文件加载到内存，快慢和 RDB文件大小相关。加载 RDB文件又是一个阻塞点。RDB文件越大，阻塞就越久。</p><h4 id="什么时候选择redis什么时候选择memchached">28.什么时候选择Redis？什么时候选择Memchached？</h4><ul><li>业务复杂（功能）角度：复杂时选择Redis，当value是哈希，列表，集合，有序集合等复杂数据结构的时候，选择redis更合适，因为Memchached无法满足这样的需求。</li></ul><p>​ 典型场景：用户消息，评论，订单列表等</p><ul><li>持久化角度：redis天然支持集群功能，可实现主从复制，读写分离，高可用的情况选择Redis</li><li>内存管理角度：redis采用申请内存的方式，会把带过期时间的数据存放到一起，redis理论上能够存储比物理内存更多的数据，当数据超量时，会引发swap，把冷数据刷到磁盘上。而memcached把所有的数据存储在物理内存里。memcache使用预分配池管理，会提前把内存分为多个slab，slab又分成多个不等大小的chunk，chunk从最小的开始，根据增长因子增长内存大小。redis更适合做数据存储，memcached更适合做缓存，memcache在存储速度方面也会比redis这种申请内存的方式来的快。</li><li>IO角度：Redis支持多路复用，但是命令都是单线程的，子任务可能会有一些冲突；Memchached一般都是非阻塞IO，且支持多路复用</li><li>线程角度：Memchached使用多线程，主线程监听，worker子线程接受请求，执行读写，可能存在锁冲突。redis使用单线程模式，不存在锁冲突，但难以利用多核的特效提升整体吞吐量。</li><li>集群角度：redis天然支持高可用集群，支持主从，而Memchached需要自己实现类似一致性hash的负载均衡算法才能解决集群的问题，扩展性比较低。</li></ul><h4 id="redis过期策略有哪些lru算法知道吗">29.Redis过期策略有哪些？LRU算法知道吗？</h4><p>Redis中可以使用<strong>定期删除</strong>、<strong>惰性删除</strong>和<strong>定时删除</strong>三种过期策略。</p><ul><li><strong>定期删除</strong>：Redis默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的key，而是采用了一种简单的贪心策略。</li><li><strong>惰性删除</strong>：定期删除可能会导致很多过期key到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个key，才会被redis给删除掉。这就是所谓的惰性删除，即当你主动去查过期的key时，如果发现key过期了，就立即进行删除，不返回任何东西。在客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西。</li><li><strong>定时删除</strong>：在设置<strong>key</strong>的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。</li></ul><p>Redis默认采用的是<strong>惰性删除+定期删除</strong>结合的过期策略</p><p><strong>LRU算法</strong></p><p>LRU算法又叫淘汰算法，根据数据历史访问记录进行淘汰数据，其核心思想是"如果数据最近被访问过，那么将来被访问的几率也更高"。换句话说，当内存达到极限时，应该把内存中最久没有被访问的数据淘汰掉。LRU算法需要在原有结构上附加一个链表。当某个元素被访问时，它在链表中的位置就会被移动到表头，这样位于链表尾部的元素就是最近最少使用的元素，优先被踢掉；位于链表头部的元素就是最近刚被使用过的元素，暂时不会被踢。</p><p><strong>近似LRU算法</strong></p><ul><li><p>Redis 使用的是一种近似 LRU 算法，之所以不用传统的 LRU是因为它引入了链表，会占用较多的内存。</p></li><li><p>近似 LRU算法在现有数据结构的基础上采用随机采样的方式来淘汰元素，它为每个 key增加了一个最后一次被访问的时间戳，当内存不足时，就执行一次近似 LRU算法，具体步骤是随机采样 5 个 key，这个采样个数默认为5，然后根据时间戳淘汰掉最旧的那个key，如果淘汰后内存还是不足，就继续随机采样来淘汰。这里的淘汰策略如果设置的是allkeys，就从所有 key 中随机采样，如果设置的是volatile，就从设有过期时间的 key中随机采样，采样值越大，效果就越接近传统的 LRU 算法。</p></li><li><p>redis 3.0 在算法中增加了淘汰池，进一步提升了近似 LRU算法的效果。具体原理是构建一个淘汰池数组，在每一次淘汰循环中，新随机采样的key 会和淘汰池中的 key 进行融合，淘汰掉最旧的那个 key 后，保留剩余的 key放入淘汰池中等待下一次循环。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL笔记分享</title>
      <link href="/2023/03/17/mysql-bi-ji-fen-xiang/"/>
      <url>/2023/03/17/mysql-bi-ji-fen-xiang/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="第1章-数据库概述">第1章 数据库概述</h2><h3 id="关系型数据库设计规则">1 关系型数据库设计规则</h3><h4 id="表记录字段">1.1 表、记录、字段</h4><p>E-R（entity-relationship）模型中主要概念：实体集、属性、联系集</p><pre class="line-numbers language-none"><code class="language-none">ORM思想（Object Relational Mapping）：数据库中的一个表 &lt;---&gt; Java或Python中的一个类表中的一条数据 &lt;---&gt; 类中的一个对象（或实体）表中的一个列 &lt;---&gt; 类中的一个字段、属性（field）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="表的关联关系">1.2 表的关联关系</h4><h5 id="一对一关系one-to-one">1.2.1 一对一关系（one-to-one）</h5><h5 id="一对多关系one-to-many">1.2.2 一对多关系（one-to-many）</h5><h5 id="多对多关系many-to-many">1.2.3 多对多关系（many-to-many）</h5><h5 id="自我引用">1.2.4 自我引用</h5><h2 id="第2章-基本的select语句">第2章 基本的SELECT语句</h2><h3 id="sql概述">1 SQL概述</h3><h4 id="sql分类">1.1 SQL分类</h4><h5 id="ddldata-definition-languages数据定义语言">1.1.1 DDL（DataDefinition Languages，数据定义语言）</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> \ <span class="token keyword">ALTER</span> \ <span class="token keyword">DROP</span> \ <span class="token keyword">RENAME</span> \ <span class="token keyword">TRUNCATE</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="dmldata-manipulation-language数据操作语言">1.1.2 DML（DataManipulation Language，数据操作语言）</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> \ <span class="token keyword">DELETE</span> \ <span class="token keyword">UPDATE</span> \ <span class="token keyword">SELECT</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="dcldata-control-language数据控制语言">1.1.3 DCL（Data ControlLanguage，数据控制语言）</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">COMMIT</span> \ <span class="token keyword">ROLLBACK</span> \ <span class="token keyword">SAVEPOINT</span> \ <span class="token keyword">GRANT</span> \ <span class="token keyword">REVOKE</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="sql语言的规则与规范">2 SQL语言的规则与规范</h3><h4 id="基本规则">2.1 基本规则</h4><h4 id="sql规范">2.2 SQL规范</h4><h4 id="注释">2.3 注释</h4><h4 id="命名规则">2.4 命名规则</h4><h4 id="数据导入指令">2.5 数据导入指令</h4><h5 id="source文件的全路径名">2.5.1 source文件的全路径名</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">source d:\mysqldb.sql;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="基于具体的图形化界面工具导入数据">2.5.2基于具体的图形化界面工具导入数据</h5><h3 id="基本的select语句">3 基本的SELECT语句</h3><h4 id="select...">3.0 SELECT...</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 1;SELECT 2*3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="select...from...">3.1 SELECT...FROM...</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># *:表中所有的字段（或列）SELECT * FROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="列的别名">3.2 列的别名</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># as全称:alias(别名),可以省略# 列的别名可以使用一对""引起来SELECT employee_id emp_id,last_name AS lname,department_id "dep id"FROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="去除重复行">3.3 去除重复行</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT DISTINCT department_idFROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="空值参与运算">3.4 空值参与运算</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#空值:null#空值参与运算,其结果一定也为空SELECT employee_id,salary "月工资",salary*(1 + commission_pct) * 12 "年工资"FROM employees;#实际问题的解决方案:引入IFNULLSELECT employee_id,salary "月工资",salary*(1 + IFNULL(commission_pct,0)) * 12 "年工资"FROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="着重号">3.5 着重号</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># ``:避免表名和关键字重复SELECT * FROM `order`;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="查询常数">3.6 查询常数</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 'constant',123,employee_id,last_nameFROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="显示表结构">4 显示表结构</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DESCRIBE employees;DESC employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="过滤数据">5 过滤数据</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#过滤条件WHERE:声明在FROM结构后面SELECT *FROM employeesWHERE department_id = 90;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第3章-运算符">第3章 运算符</h2><h3 id="算数运算符">1 算数运算符</h3><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220094347610.png" alt="image-20221220094347610"><figcaption aria-hidden="true">image-20221220094347610</figcaption></figure><h4 id="加法与减法运算符">1.1 加法与减法运算符</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 在SQL中，+ 没有连接的作用，只表示加法运算。此时，会将字符串转换为数值SELECT 100 + '1'FROM DUAL;SELECT 100 + 'a' #此时将'a'看作0处理FROM DUAL;SELECT 100 + NULL #null值参与运算,结果为nullFROM DUAL;SELECT 100 DIV 0 #分母如果为0,则结果为nullFROM DUAL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="取模运算">1.2 取模运算</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查询员工id为偶数的员工信息SELECT employee_id,last_nameFROM employeesWHERE employee_id % 2 = 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="比较运算符">2 比较运算符</h3><h4 id="符号类运算符">2.1 符号类运算符</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220095140881.png" alt="image-20221220095140881"><figcaption aria-hidden="true">image-20221220095140881</figcaption></figure><h5 id="section">2.1.1 =</h5><p>1.字符串存在隐式转换。如果转换数值不成功，则看作0</p><p>2.两边都是字符串的话，则按照ANSI的比较规则进行比较</p><p>3.只要有null参与判断，结果就为null</p><h5 id="section-1">2.1.2 &lt;=&gt;</h5><p>两边操作数均为null时，返回值为1；当一个操作数为null时，返回值为0</p><h4 id="非符号类运算符">2.2 非符号类运算符</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220101511026.png" alt="image-20221220101511026"><figcaption aria-hidden="true">image-20221220101511026</figcaption></figure><h5 id="is-null-is-not-null-isnull">2.2.1 IS NULL &nbsp; IS NOT NULL &nbsp;ISNULL</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT last_name,commission_pctFROM employeesWHERE commission_pct IS NULL;SELECT last_name,commission_pctFROM employeesWHERE ISNULL(commission_pct);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT last_name,commission_pctFROM employeesWHERE commission_pct IS NOT NULL;SELECT last_name,commission_pctFROM employeesWHERE NOT commission_pct &lt;=&gt; NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="least-greatest">2.2.2 LEAST() &nbsp; GREATEST</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT LEAST(first_name,last_name),LEAST(LENGTH(first_name),LENGTH(last_name))FROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="between-条件上界1-and-条件上界2">2.2.3 BETWEEN 条件上界1 AND条件上界2</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查询条件1和条件2范围内的数据，包含边界SELECT last_name,salaryFROM employeesWHERE salary BETWEEN 6000 AND 8000;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="in-set-not-in-set">2.2.4 in (set) &nbsp; not in (set)</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT last_name,department_idFROM employeesWHERE department_id IN (10,20,30);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="like模糊查询">2.2.5 LIKE：模糊查询</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查询last_name中包含字符'a'且包含字符'e'的员工信息# %:代表不确定个数的字符SELECT last_nameFROM employeesWHERE last_name LIKE '%a%' AND last_name LIKE '%e%';SELECT last_nameFROM employeesWHERE last_name LIKE '%a%e%' OR last_name LIKE '%e%a%';#查询第2个字符是'_'且第3个是'a'的员工信息# _:代表一个不确定的字符# 转义字符:\SELECT last_nameFROM employeesWHERE last_name LIKE '_\_a%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="regexp">2.2.6 REGEXP</h5><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220105020877.png" alt="image-20221220105020877"><figcaption aria-hidden="true">image-20221220105020877</figcaption></figure><h3 id="逻辑运算符">3 逻辑运算符</h3><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220105302086.png" alt="image-20221220105302086"><figcaption aria-hidden="true">image-20221220105302086</figcaption></figure><p>OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。</p><h3 id="位运算符">4 位运算符</h3><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220105824731.png" alt="image-20221220105824731"><figcaption aria-hidden="true">image-20221220105824731</figcaption></figure><h3 id="运算符的优先级">5 运算符的优先级</h3><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220105800448.png" alt="image-20221220105800448"><figcaption aria-hidden="true">image-20221220105800448</figcaption></figure><h2 id="第4章-排序与分页">第4章 排序与分页</h2><h3 id="排序">1 排序</h3><p>使用<code>ORDER BY</code>对查询的数据进行排序操作。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#升序:ASC(默认)#降序:DESCSELECT employee_id,last_name,salaryFROM employeesORDER BY salary DESC;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><p>①如果没有使用排序操作，默认情况下查询返回的数据是按照添加数据的顺序显示的</p><p>②列的别名只能在<code>ORDER BY</code>中使用，不能在<code>WHERE</code>中使用</p><p>③<code>WHERE</code>需要声明在<code>FROM</code>后，<code>ORDER BY</code>之前</p><h4 id="二级排序">1.1 二级排序</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#显示员工信息,按照department_id的降序排序,salary的升序排序SELECT employee_id,last_name,salary,department_idFROM employeesORDER BY department_id DESC,salary;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分页">2 分页</h3><h4 id="mysql使用limit实现数据的分页显示">2.1MYSQL使用LIMIT实现数据的分页显示</h4><p>LIMIT格式：<code>LIMIT 位置偏移量,条目数</code></p><p>结构<code>LIMIT 0,条目数</code>等价于<code>LIMIT 条目数</code></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#每页显示pageSize条记录,此时显示第pageNo页SELECT employee_id,last_name,salary,department_idFROM employeesLIMIT (pageNo-1) * pageSize,pageSize;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="where...order-by...limit声明顺序">2.2 WHERE...ORDERBY...LIMIT声明顺序</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT employee_id,last_name,salary,department_idFROM employeesWHERE salary &gt; 6000ORDER BY salary DESCLIMIT 0,10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="mysql8.0新特性limit...offset...">2.3MYSQL8.0新特性：LIMIT...OFFSET...</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#只查询第32,33条数据SELECT employee_id,last_name,salary,department_idFROM employeesLIMIT 31,2;SELECT employee_id,last_name,salary,department_idFROM employeesLIMIT 2 OFFSET 31;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第5章-多表查询">第5章 多表查询</h2><p>1.如果查询语句中出现了多个表中都存在的字段，则必须指明此字段所在的表</p><p>2.从sql优化的角度，建议多表查询时，每个字段前都指明其所在的表</p><p>3.可以给表起别名，在SELECT和WHERE中使用表的别名</p><p>4.如果给表起了别名，一旦在SELECT或WHERE中使用表名的话，则必须使用表的别名，而不能再使用表的原名。</p><p>5.如果有n个表实现多表的查询，则需要至少n-1个连接条件</p><h3 id="多表查询的分类">1 多表查询的分类</h3><h4 id="等值连接-vs-非等值连接">1.1 等值连接 vs 非等值连接</h4><h5 id="非等值连接">1.1.1 非等值连接</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT e.last_name,e.salary,j.grade_levelFROM employees e,job_grades jWHERE e.salary BETWEEN j.lowest_sal AND j.highest_sal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="自连接-vs-非自连接">1.2 自连接 vs 非自连接</h4><h5 id="自连接">1.2.1 自连接</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查询员工id,员工姓名及其管理者的id和姓名SELECT e1.employee_id,e1.last_name,e1.manager_id,e2.last_nameFROM employees e1,employees e2WHERE e1.manager_id = e2.employee_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="内连接-vs-外连接">1.3 内连接 vs 外连接</h4><h5 id="内连接">1.3.1 内连接</h5><p>内连接：合并具有同一列的两个以上的表的行，结果集中不包含一个表与另一个表不匹配的行</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT employee_id,department_nameFROM employees e,departments dWHERE e.department_id = d.department_id;#SQL99:(INNER可以省略)SELECT e.employee_id,d.department_name,l.cityFROM employees e INNER JOIN departments dON e.department_id = d.department_idJOIN location lON d.location_id = l.location_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="外连接">1.3.2 外连接</h5><p>外连接：合并具有同一列的两个以上的表的行，结果集中除了包含一个表与另一个表匹配的行之外，还查询到了左表或右表中不匹配的行。</p><p>外连接的分类：左外连接、右外连接、满外连接</p><p>左（右）外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回左（右）表中不满足条件的行，这种连接称为左（右）外连接</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查询所有的员工的last_name,department_name信息#SQL92:使用 + (MYSQL不支持SQL92语法中外连接的写法)SELECT e.employee_id,d.department_idFROM employees e,departments d #需要使用左连接WHERE e.department_id = d.department_id(+);#SQL99:JOIN...ON(MySQL支持)(OUTER可以省略)#左外连接:SELECT e.employee_id,d.department_idFROM employees e LEFT OUTER JOIN departments dON e.department_id = d.department_id;#右外连接:SELECT e.employee_id,d.department_idFROM employees e RIGHT JOIN departments dON e.department_id = d.department_id;#满外连接:(MySQL不支持FULL OUTER JOIN)SELECT e.employee_id,d.department_idFROM employees e FULL JOIN departments dON e.department_id = d.department_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="union的使用">2 UNION的使用</h3><h5 id="合并查询结果">合并查询结果</h5><p>利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNIONALL关键字分隔。</p><p>语法格式：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT column,... FROM table1UNION [ALL]SELECT column,... FROM table2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="union操作符">UNION操作符</h5><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220162812696.png" alt="image-20221220162812696"><figcaption aria-hidden="true">image-20221220162812696</figcaption></figure><p>UNION 操作符返回两个查询的结果集的并集，去除重复记录</p><h5 id="union-all操作符">UNION ALL操作符</h5><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220163121439.png" alt="image-20221220163121439"><figcaption aria-hidden="true">image-20221220163121439</figcaption></figure><p>UNIONALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分不去重。</p><h3 id="种sql-joins的实现">3 7种SQL JOINS的实现</h3><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220162416061.png" alt="image-20221220162416061"><figcaption aria-hidden="true">image-20221220162416061</figcaption></figure><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#中图:内连接SELECT employee_id,department_nameFROM employees e JOIN departments dON e.department_id = d.department_id;#左上图:左外连接SELECT employee_id,department_nameFROM employees e LEFT JOIN departments dON e.department_id = d.department_id;#右上图:右外连接SELECT employee_id,department_nameFROM employees e RIGHT JOIN departments dON e.department_id = d.department_id;#左中图:SELECT employee_id,department_nameFROM employees e LEFT JOIN departments dON e.department_id = d.department_idWHERE d.department_id IS NULL;#右中图SELECT employee_id,department_nameFROM employees e RIGHT JOIN departments dON e.department_id = d.department_idWHERE e.department_id IS NULL;#左下图:满外连接#方式1: 左上图 UNION ALL 右中图SELECT employee_id,department_nameFROM employees e LEFT JOIN departments dON e.department_id = d.department_idUNION ALLSELECT employee_id,department_nameFROM employees e RIGHT JOIN departments dON e.department_id = d.department_idWHERE e.department_id IS NULL;#右下图:左中图 UNION ALL 右中图SELECT employee_id,department_nameFROM employees e LEFT JOIN departments dON e.department_id = d.department_idWHERE d.department_id IS NULLUNION ALLSELECT employee_id,department_nameFROM employees e RIGHT JOIN departments dON e.department_id = d.department_idWHERE e.department_id IS NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sql99语法新特性">4 SQL99语法新特性</h3><h4 id="自然连接">4.1 自然连接</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT employee_id,last_name,department_nameFROM employees e JOIN departments dON e.department_id = d.department_idAND e.manager_id = d.manager_id;#SQL99:NATURAL JOIN:它会帮你自动查询两张连接表中'所有相同的字段'，然后进行'等值连接'。SELECT employee_id,last_name,department_nameFROM employees e NATURAL JOIN departments d;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="using">4.2 USING</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT employee_id,last_name,department_nameFROM employees e JOIN departments dON e.department_id = d.department_id#SQL99:SELECT employee_id,last_name,department_nameFROM employees e JOIN departments dUSING (department_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第6章-单行函数">第6章 单行函数</h2><h3 id="函数的理解">1 函数的理解</h3><h4 id="mysql的内置函数及分类">1.1 MySQL的内置函数及分类</h4><p>MySQL提供的内置函数从<strong>实现的功能角度</strong>可以分为：数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取MySQL信息函数、聚合函数等。</p><p>将这些丰富的内置函数再分为两类：单行函数、聚合函数（或分组函数）。</p><h3 id="数值函数">2 数值函数</h3><h4 id="基本函数">2.1 基本函数</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220170213285.png" alt="image-20221220170213285"><figcaption aria-hidden="true">image-20221220170213285</figcaption></figure><h4 id="角度与弧度互换函数">2.2 角度与弧度互换函数</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220171335008.png" alt="image-20221220171335008"><figcaption aria-hidden="true">image-20221220171335008</figcaption></figure><h4 id="三角函数">2.3 三角函数</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220171156829.png" alt="image-20221220171156829"><figcaption aria-hidden="true">image-20221220171156829</figcaption></figure><h4 id="指数与对数">2.4 指数与对数</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220171540420.png" alt="image-20221220171540420"><figcaption aria-hidden="true">image-20221220171540420</figcaption></figure><h3 id="字符串函数">3 字符串函数</h3><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220171736256.png" alt="image-20221220171736256"><figcaption aria-hidden="true">image-20221220171736256</figcaption></figure><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220171906352.png" alt="image-20221220171906352"><figcaption aria-hidden="true">image-20221220171906352</figcaption></figure><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220172049099.png" alt="image-20221220172049099"><figcaption aria-hidden="true">image-20221220172049099</figcaption></figure><h3 id="日期和时间函数">4 日期和时间函数</h3><h4 id="获取日期时间">4.1 获取日期、时间</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220172215832.png" alt="image-20221220172215832"><figcaption aria-hidden="true">image-20221220172215832</figcaption></figure><h4 id="日期与时间戳的转换">4.2 日期与时间戳的转换</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220172238916.png" alt="image-20221220172238916"><figcaption aria-hidden="true">image-20221220172238916</figcaption></figure><h4 id="获取月份星期星期数天数等函数">4.3获取月份、星期、星期数、天数等函数</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220174029933.png" alt="image-20221220174029933"><figcaption aria-hidden="true">image-20221220174029933</figcaption></figure><h4 id="日期的操作函数">4.4 日期的操作函数</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220172629343.png" alt="image-20221220172629343"><figcaption aria-hidden="true">image-20221220172629343</figcaption></figure><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220174133855.png" alt="image-20221220174133855"><figcaption aria-hidden="true">image-20221220174133855</figcaption></figure><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220174159235.png" alt="image-20221220174159235"><figcaption aria-hidden="true">image-20221220174159235</figcaption></figure><h4 id="时间和秒钟转换的函数">4.5 时间和秒钟转换的函数</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220172847982.png" alt="image-20221220172847982"><figcaption aria-hidden="true">image-20221220172847982</figcaption></figure><h4 id="计算日期和时间的函数">4.6 计算日期和时间的函数</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220173011677.png" alt="image-20221220173011677"><figcaption aria-hidden="true">image-20221220173011677</figcaption></figure><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220174412244.png" alt="image-20221220174412244"><figcaption aria-hidden="true">image-20221220174412244</figcaption></figure><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220173046332.png" alt="image-20221220173046332"><figcaption aria-hidden="true">image-20221220173046332</figcaption></figure><h4 id="日期的格式化与解析">4.7 日期的格式化与解析</h4><pre class="line-numbers language-none"><code class="language-none">格式化:日期 ---&gt; 字符串解析:字符串 ---&gt; 日期<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220173259762.png" alt="image-20221220173259762"><figcaption aria-hidden="true">image-20221220173259762</figcaption></figure><p>上述非GET_FORMAT函数中fmt参数常用的格式符：</p><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220175055666.png" alt="image-20221220175055666"><figcaption aria-hidden="true">image-20221220175055666</figcaption></figure><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220175247330.png" alt="image-20221220175247330"><figcaption aria-hidden="true">image-20221220175247330</figcaption></figure><p>GET_FORMAT函数中date_type和format_type参数取值如下：</p><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220175747147.png" alt="image-20221220175747147"><figcaption aria-hidden="true">image-20221220175747147</figcaption></figure><h3 id="流程控制函数">5 流程控制函数</h3><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220202855666.png" alt="image-20221220202855666"><figcaption aria-hidden="true">image-20221220202855666</figcaption></figure><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#IF(VALUE,VALUE1,VALUE2)SELECT last_name,salary, IF(salary&gt;=6000,'高工资','低工资')FROM employees;SELECT last_name,commission_pct, IF(commission_pct IS NOT NULL,commission_pct,0) FROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#IFNULL(VALUE1,VALUE2):看做是IF(VALUE,VALUE1,VALUE2)的特殊情况SELECT last_name,commission_pct, IFNULL(commission_pct,0) "details"FROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#CASE WHEN ... THEN ... WHEN ... THEN ... ELSE ... ENDSELECT last_name,salary, CASE WHEN salary &gt;= 15000 THEN 'SALARY_A'WHEN salary &gt;= 10000 THEN 'SALARY_B'WHEN salary &gt;= 8000 THEN 'SALARY_C'ELSE 'SALARY_D' END "details"FROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="加密与解密函数">6 加密与解密函数</h3><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220233254619.png" alt="image-20221220233254619"><figcaption aria-hidden="true">image-20221220233254619</figcaption></figure><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#PASSWORD() \ ENCODE() \ DECODE() 在MySQL8.0中弃用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="mysql信息函数">7 MySQL信息函数</h3><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220234204925.png" alt="image-20221220234204925"><figcaption aria-hidden="true">image-20221220234204925</figcaption></figure><h3 id="其他函数">8 其他函数</h3><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221220234357704.png" alt="image-20221220234357704"><figcaption aria-hidden="true">image-20221220234357704</figcaption></figure><h2 id="第7章-聚合函数">第7章 聚合函数</h2><h3 id="常见的聚合函数">1 常见的聚合函数</h3><h4 id="avg-sum">1.1 AVG / SUM</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#只适用于数值类型的字段(或变量)SELECT AVG(salary),SUM(salary)FROM employees;#AVG = SUM / COUNT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="max-min">1.2 MAX / MIN</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#适用于数值类型、字符串类型、日期时间类型的字段(或变量)SELECT MAX(salary),MIN(salary)FROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="count">1.3 COUNT</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 作用:计算指定字段在查询结构中出现的个数(不包含NULL)SELECT COUNT(employee_id)FROM employees;#如果计算表中有多少条记录,如何实现?#方式1:COUNT(*)#方式2:COUNT(*)#方式3:COUNT(具体字段):不含NULL#COUNT(*)、COUNT(1)、COUNT(具体字段)哪个效率更高?#如果使用的是 MyISAM 存储引擎,则三者效率相同,都是O(1)#如果使用的是 InnoDB 存储引擎,三者效率 COUNT(*) = COUNT(1) &gt; COUNT(具体字段)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="group-by">2 GROUP BY</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查询各个department_id,job_id的平均工资#方式1:SELECT department_id,job_id,AVG(salary)FROM employeesGROUP BY department_id,job_id;#方式2:SELECT job_id,department_id,AVG(salary)FROM employeesGROUP BY job_id,department_id;#结论1:SELECT中出现的非组函数的字段必须上明在GROUP BY中。反之,GROUP BY中生命的字段可以不出现在SELECT中。#结论2:GROUP BY声明在FROM后面,WHERE后面,ORDER BY前面,LIMIT前面#结论3:MySQL中GROUP BY使用WITH ROLLUPSELECT department_id,AVG(salary)FROM employeesGROUP BY department_id WITH ROLLUP;#说明:当使用ROLLUP时,不能同时使用ORDER BY子句进行结果排序,即ROLLUP和ORDER BY是互相排斥的。#查询各个部门的平均工资,按照平均工资升序排列SELECT department_id,AVG(salary) avg_salFROM employeesGROUP BY department_idORDER BY avg_sal ASC;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="having">3 HAVING</h3><p>作用：过滤数据</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查询部门id为10,20,30,40的部门中最高工资比10000高的部门信息#方式1:推荐,执行效率高于方式2SELECT department_id,MAX(salary)FROM employeesWHERE department_id IN (10,20,30,40)GROUP BY department_idHAVING MAX(salary)&gt;10000;#方式2:SELECT department_id,MAX(salary)FROM employeesGROUP BY department_idHAVING MAX(salary)&gt;10000 AND department_id IN (10,20,30,40);#要求1:如果过滤条件中使用了聚合函数,则必须使用HAVING替换WHERE#要求2:HAVING必须声明在GROUP BY后面#要求3:开发中,使用HAVING的前提是使用了GROUP BY#结论:当过滤条件中没有聚合函数时,则此过滤条件声明在WHERE中或HAVING中都可以(建议声明在WHERE中)/*WHERE和HAVING的对比1.从适用范围上来讲,HAVING的适用范围更广2.如果过滤条件中没有聚合函数:这种情况下,WHERE的执行效率要高于HAVING<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sql底层执行原理">4 SQL底层执行原理</h3><h4 id="select语句的完整结构">4.1 SELECT语句的完整结构</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#sql92语法:SELECT ...,...,...(存在聚合函数)FROM ...,...,...WHERE 多表的连接条件 AND 不包含聚合函数的过滤条件GROUP BY ...,...HAVING 包含聚合函数的过滤条件ORDER BY ...,...(ASC/DESC)LIMIT ...,...#sql99语法:SELECT ...,...,...(存在聚合函数)FROM ... (LEFT/RIGHT) JOIN ... ON 多表的连接条件(LEFT/RIGHT) JOIN ... ON ...WHERE 多表的连接条件 AND 不包含聚合函数的过滤条件GROUP BY ...,...HAVING 包含聚合函数的过滤条件ORDER BY ...,...(ASC/DESC)LIMIT ...,...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="sql语句的执行过程">4.2 SQL语句的执行过程</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">FROM ...,... -&gt; ON -&gt; (LEFT/RIGHT JOIN) -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="第8章-子查询">第8章 子查询</h2><h3 id="子查询的基本使用">1 子查询的基本使用</h3><ul><li><p>外查询（或主查询）、内查询（或子查询）</p></li><li><p>子查询（内查询）在主查询之前一次执行完成</p></li><li><p>子查询的结果被主询 （外查询）使用</p><p>注意事项：</p></li><li><p>子查询要包含在括号内</p></li><li><p>将子查询放在比较条件的右侧</p></li><li><p>单行操作符对应单行子查询，多行操作符对应多行子查询</p></li></ul><h3 id="子查询的分类">2 子查询的分类</h3><h4 id="角度1从内查询返回的结构的条目数">角度1：从内查询返回的结构的条目数</h4><p>单行子查询、多行子查询</p><h4 id="角度2从内查询是否被执行多次">角度2：从内查询是否被执行多次</h4><p>相关子查询、不相关子查询</p><p>例如：</p><p>相关子查询：查询工资大于本部门平均工资的员工信息</p><p>不相关子查询：查询工资大于本公司平均工资的员工信息</p><h3 id="单行子查询">3 单行子查询</h3><h4 id="单行操作符">3.1 单行操作符</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221228211950247.png" alt="image-20221228211950247"><figcaption aria-hidden="true">image-20221228211950247</figcaption></figure><h4 id="子查询中的空值问题">3.2 子查询中的空值问题</h4><h4 id="非法使用子查询">3.3 非法使用子查询</h4><h3 id="多行子查询">4 多行子查询</h3><h4 id="多行比较操作符">4.1 多行比较操作符</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221228223004414.png" alt="image-20221228223004414"><figcaption aria-hidden="true">image-20221228223004414</figcaption></figure><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查询平均工资最低的部门id#MYSQL中聚合函数是不能嵌套使用的#方式1:SELECT department_idFROM employeesGROUP BY department_idHAVING AVG(salary) = (                        SELECT MIN(avg_sal)                        FROM (                        SELECT AVG(salary) avg_sal                        FROM employees                        GROUP BY department_id                        ) t_dept_avg_sal);#方式2:SELECT department_idFROM employeesGROUP BY department_idHAVING AVG(salary) &lt;= ALL(                        SELECT AVG(salary) avg_sal                        FROM employees                        GROUP BY department_id                        ));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="空值问题">4.2 空值问题</h4><h3 id="相关子查询">5 相关子查询</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查询员工中工资大于本部门平均工资的员工的last_name,salary,department_id#方式1:使用相关子查询SELECT last_name,salary,department_idFROM employees e1WHERE salary &gt; (SELECT AVG(salary)FROM employees e2WHERE department_id = e1.department_id);#方式2:在FROM中声明子查询SELECT e.last_name,e.salary,e.department_idFROM employees e,(SELECT department_id,AVG(salary) avg_salFROM employeesGROUP BY department_id) t_dept_avg_salWHERE e.salary &gt; t_dept_avg_sal.avg_salAND e.department_id = t_dept_avg_sal.department_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结论：在SELECT中，出了<code>GROUP BY</code>和<code>LIMIT</code>之外，其他位置都可以声明子查询</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT ...,...,...(存在聚合函数)FROM ... (LEFT/RIGHT) JOIN ... ON 多表的连接条件(LEFT/RIGHT) JOIN ... ON ...WHERE 多表的连接条件 AND 不包含聚合函数的过滤条件GROUP BY ...,...HAVING 包含聚合函数的过滤条件ORDER BY ...,...(ASC/DESC)LIMIT ...,...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="exists-与-not-exists-关键字">5.1 EXISTS 与 NOT EXISTS关键字</h4><p>如果在子查询中不存在满足条件的行： 条件返回 FALSE继续在子查询中查找</p><p>如果在子查询中存在满足条件的行： 不在子查询中继续查找 条件返回TRUE</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查询公司管理者的employee_id,last_name,job_id,department_id#方式1:自连接SELECT DISTINCT e2.employee_id,e2.last_name,e2.job_id,e2.department_idFROM employees e1 JOIN employees e2ON e1.manager_id = e2.employee_id;#方式2:子查询SELECT employee_id,last_name,job_id,department_idFROM employeesWHERE employee_id IN (SELECT DISTINCT manager_idFROM employees);#方式3:使用EXISTSSELECT employee_id,last_name,job_id,department_idFROM employees e1WHERE EXISTS (SELECT *FROM employees e2WHERE e1.employee_id = e2.employee_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查询departments表中,不存在于employees表中的部门的department_id和department_name#方式1:SELECT d.department_id,d.department_nameFROM employees e RIGHT JOIN departments dON e.department_id = d.department_idWHERE e.department_id IS NULL;#方式2:SELECT department_id,department_nameFROM departments dWHERE NOT EXISTS (                SELECT *                FROM employees e                WHERE e.department_id = d.department_id                );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第9章-创建和管理表">第9章 创建和管理表</h2><h3 id="创建和管理数据库">1 创建和管理数据库</h3><h4 id="创建数据库">1.1 创建数据库</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#方式1:CREATE DATABASE mytest1;#方式2:显式指明要创建的数据库的字符集CREATE DATABASE mytest2 CHARACTER SET 'gbk';#方式3:CREATE DATABASE IF NOT EXISTS mytest3 CHARACTER SET 'utf8';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="管理数据库">1.2 管理数据库</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查看创建数据库的结构SHOW CREATE DATABASE mytest1;#查看当前连接中的数据库都有哪些SHOW DATABASES;#切换数据库USE mytest2;#查看当前数据库中保存的数据表SHOW TABLES;#查看当前使用的数据库SELECT DATABASE() FROM DUAL;#查看指定数据库下保存的数据表SHOW TABLES FROM mytest3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修改数据库">1.3 修改数据库</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#修改数据库的字符集ALTER DATABASE mytest2 CHARACTER SET 'utf8';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="删除数据库">1.4 删除数据库</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#方式1:DROP DATABASE mytest1;#方式2:DROP DATABASE IF EXISTS mytest2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="mysql中的数据类型">1.5 MySQL中的数据类型</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20221231161352844.png" alt="image-20221231161352844"><figcaption aria-hidden="true">image-20221231161352844</figcaption></figure><h3 id="如何创建数据表">2 如何创建数据表</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#方式1:需要用户具备创建表的权限CREATE TABLE IF NOT EXISTS myemp1(id INT,emp_name VARCHAR(15), #使用VARCHAR来定义字符串,必须在使用VARCHAR时指明其长度hire_date DATE);#查看表结构DESC myemp1;#查看创建表的语句结构SHOW CREATE TABLE myemp1; #如果在创建表时没有指明使用的字符集,则默认使用表所在数据库的字符集#查看表的数据SELECT * FROM myemp1;#方式2:基于现有的表#说明1:查询语句中字段的别名,可以作为新创建的表的字段的名称。#说明2:此时的查询语句可以结构比较丰富,使用前面章节讲过的各种SELECTCREATE TABLE myemp2ASSELECT employee_id,last_name,salaryFROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改表">3 修改表</h3><h4 id="添加一个字段">3.1 添加一个字段</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#默认添加到表中的最后一个字段的位置ALTER TABLE myemp1ADD salary DOUBLE(10,2);ALTER TABLE myemp1ADD phone_number VARCHAR(20) FIRST;ALTER TABLE myemp1ADD email VARCHAR(45) AFTER emp_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修改一个字段数据类型长度默认值略">3.2修改一个字段：数据类型、长度、默认值（略）</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE myemp1MODIFY emp_name VARCHAR(25);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="重命名一个字段">3.3 重命名一个字段</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE myemp1CHANGE salary monthly_salary DOUBLE(10,2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="删除一个字段">3.4 删除一个字段</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE myemp1DROP COLUMN my_email;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="重命名表">4 重命名表</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#方式1:RENAME TABLE myemp1TO myemp2;#方式2:ALTER TABLE myemp1RENAME TO myemp2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除表">5 删除表</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#将表结构删除,同时将表中的数据也删除,释放表空间DROP TABLE IF EXISTS myemp2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="清空表">6 清空表</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#清空表,表示清空表中的所有数据,但是表结构保留。TRUNCATE TABLE myemp2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="dcl中的-commit-和-rollback">7 DCL中的 COMMIT 和 ROLLBACK</h3><p>COMMIT：提交数据。一旦执行COMMIT，则数据就永久的保存在数据库中，意味着数据不可以回滚。</p><p>ROLLBACK：回滚数据。一旦执行ROLLBACK，则可以实现数据的回滚。回滚到最近的一次COMMIT之后。</p><h3 id="对比-truncate-table-和-delete-from">8 对比 TRUNCATE TABLE 和DELETE FROM</h3><p>相同点：都可以实现对表中所有数据的删除，同时保留表结构。</p><p>不同点：</p><p>​<code>TRUNCATE TABLE</code>：一旦执行此操作，表数据全部清除。同时，数据是不可以回滚的。</p><p>​<code>DELETE FROM</code>：一旦执行此操作，表数据可以全部清除（不带WHERE）。同时，数据是可以实现回滚的。</p><h3 id="ddl-和-dml-的说明">9 DDL 和 DML 的说明</h3><p>1.DDL的操作一旦执行，就不可回滚。指令<code>SET autocommit = FALSE</code>对DDL操作无效。（因为在执行完DDL操作之后，一定会执行一次COMMIT。而此COMMIT操作不受<code>SET autocommit = FALSE</code>影响。）</p><p>2.DML的操作在默认情况夏一旦执行，也是不可回滚的。但是，如果在DML之前，执行了<code>SET autocommit = FALSE</code>，则执行的DML操作就可以实现回滚。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#DML:DELETE FROM# 1.COMMIT;# 2.有效，使DML可以实现回滚SET autocommit = FALSE;# 3.DELETE FROM myemp;# 4.SELECT *FROM myemp;# 5.ROLLBACK;# 6.有数据SELECT *FROM myemp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#DDL:TRUNCATE TABLE# 1.COMMIT;# 2.无效SET autocommit = FALSE;# 3.TRUNCATE TABLE myemp;# 4.SELECT *FROM myemp;# 5.ROLLBACK;# 6.无数据SELECT *FROM myemp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="mysql8.0新特性ddl的原子化">10 MySQL8.0新特性：DDL的原子化</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE DATABASE mytest;USE mytest;CREATE TABLE book1(book_id INT ,book_name VARCHAR(255));SHOW TABLES;#8.0中book1不会被删除(被回滚)DROP TABLE book1,book2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第10章-数据处理之增删改">第10章 数据处理之增、删、改</h2><h3 id="插入数据">1 插入数据</h3><h4 id="方式一一条一条添加">1.1 方式一：一条一条添加</h4><h5 id="没有指明添加的字段">① 没有指明添加的字段</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#注意:按照声明字段的先后顺序添加INSERT INTO emp1VALUES (1,'Tom','1999-01-15',3400);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="指明要添加的字段">② 指明要添加的字段</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">INSERT INTO emp1(id,`name`,hire_date,salary)VALUES (1,'Tom','1999-01-15',3400);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="同时插入多条记录">③ 同时插入多条记录</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">INSERT INTO emp1(id,`name`,hire_date,salary)VALUES(1,'Tom','1999-01-15',3400),(2,'Jerry','1998-11-28',4500),;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方式二将查询结果插入到表中">1.2方式二：将查询结果插入到表中</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT * FROM emp1;INSERT INTO emp1(id,`name`,hire_date,salary)#查询语句SELECT employee_id,last_name,salary,hire_date #查询的字段要与添加到的表的字段一一对应FROM employeesWHERE department_id IN (70,60);#说明:emp1表中要添加数据的字段的长度不能低于employees表中查询的字段的长度。若低于,则有添加不成功的风险。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="更新数据或修改数据">2 更新数据（或修改数据）</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#可以实现批量修改数据UPDATE emp1SET hire_date = CURDATE()WHERE id = 5;#同时修改一条数据的多个字段UPDATE emp1SET hire_date = CURDATE(),salary = 6000WHERE id = 4;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除数据">3 删除数据</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DELETE FROM emp1WHERE id = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>小结：DML操作默认情况下，执行完以后都会自动提交数据。如果希望执行完以后不自动提交数据，则需要使用<code>SET autocommit = FALSE</code></p><h3 id="mysql8特性计算列">MySQL8特性：计算列</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE test1(a INT,b INT,c INT GENERATED ALWAYS AS (a + b) VIRTUAL #字段c即为计算列);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第11章-数据类型">第11章 数据类型</h2><h3 id="mysql中的数据类型-1">1 MySQL中的数据类型</h3><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20230131111729456.png" alt="image-20230131111729456"><figcaption aria-hidden="true">image-20230131111729456</figcaption></figure><p>常见数据类型的属性：</p><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20230131112458180.png" alt="image-20230131112458180"><figcaption aria-hidden="true">image-20230131112458180</figcaption></figure><h3 id="整数类型">2 整数类型</h3><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20230131112529556.png" alt="image-20230131112529556"><figcaption aria-hidden="true">image-20230131112529556</figcaption></figure><p>注意：</p><p>1.可以设置显示宽度，当INSERT的值小于设置的显示宽度时，使用0填充。</p><p>2.当使用ZEROFILL时，会自动添加UNSIGNED</p><h3 id="浮点类型">3 浮点类型</h3><h3 id="定点类型">4 定点类型</h3><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20230203101514163.png" alt="image-20230203101514163"><figcaption aria-hidden="true">image-20230203101514163</figcaption></figure><p><code>DECIMAL(M,D)</code>：M为精度，D为标度。最大取值范围与DOUBLE相同。默认值为<code>DECIMAL(10,0)</code>.</p><h3 id="位类型bit">5 位类型：BIT</h3><h3 id="日期与时间类型">6 日期与时间类型</h3><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20230203105232831.png" alt="image-20230203105232831"><figcaption aria-hidden="true">image-20230203105232831</figcaption></figure><h3 id="文本类型">7 文本类型</h3><p><code>CHAR(M)</code>类型</p><p><code>VARCHAR(M)</code>类型：必须指定长度M。</p><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20230203112147055.png" alt="image-20230203112147055"><figcaption aria-hidden="true">image-20230203112147055</figcaption></figure><p><code>TEXT</code>类型</p><h3 id="enum类型">8 ENUM类型</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE test_enum(season ENUM('SPRING','SUMMER','AUTUMN','WINTER'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="set类型">9 SET类型</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE test_set(s SET('A','B','C'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="二进制字符串类型">10 二进制字符串类型</h3><h4 id="binary类型">BINARY类型</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20230203114712943.png" alt="image-20230203114712943"><figcaption aria-hidden="true">image-20230203114712943</figcaption></figure><h4 id="blob类型">BLOB类型</h4><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20230203114650655.png" alt="image-20230203114650655"><figcaption aria-hidden="true">image-20230203114650655</figcaption></figure><h3 id="json类型">11 JSON类型</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE test_json(js json);INSERT INTO test_json(js)VALUES ('{"name":"Tom","age":18,"address":{"province":"BeiJing","city":"BeiJing"}}');SELECT js -&gt; '$.name' AS NAME,js -&gt; '$.age' AS age,js -&gt; '$.address.province' AS province,js -&gt; '$.address.city' AS CITYFROM test_json;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="空间类型">12 空间类型</h3><figure><img src="C:\Users\RicardoHao\AppData\Roaming\Typora\typora-user-images\image-20230203115922938.png" alt="image-20230203115922938"><figcaption aria-hidden="true">image-20230203115922938</figcaption></figure><h2 id="第12章-约束">第12章 约束</h2><h3 id="约束constraint概述">1 约束（constraint）概述</h3><h4 id="为什么需要约束">1.1 为什么需要约束？</h4><p>为了保证数据的完整性</p><h4 id="什么叫约束">1.2 什么叫约束？</h4><p>对表中字段的限制</p><h4 id="约束的分类">1.3 约束的分类</h4><h5 id="角度1约束的字段的个数">角度1：约束的字段的个数</h5><p>单列约束 多列约束</p><h5 id="角度2约束的作用范围">角度2：约束的作用范围</h5><p>列级约束：将此约束声明在对应字段的后面</p><p>表级约束：在表中所有字段都声明完，在所有字段的后面声明的约束</p><h5 id="角度3约束的作用">角度3：约束的作用</h5><p>not null（非空约束）</p><p>unique（唯一性约束）</p><p>primary key（主键约束）</p><p>foreign key（外键约束）</p><p>check（检查约束）</p><p>default（默认值约束）</p><h4 id="如何添加约束">1.4 如何添加约束</h4><p><code>CREATE TABLE</code> 时添加约束</p><p><code>ALTER TABLE</code> 时增加、删除约束</p><h4 id="如何查看表中的约束">1.5 如何查看表中的约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT * FROM information_schema.table_constraintsWHERE table_name = 'employees';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="非空约束not-null">2 非空约束（not null）</h3><h4 id="create-table-时添加约束">2.1 CREATE TABLE 时添加约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE test1(id INT NOT NULL,last_name VARCHAR(15) NOT NULL,email VARCHAR(25),salary DECIMAL(10,2));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="alter-table-时添加约束">2.2 ALTER TABLE 时添加约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE test1MODIFY email VARCHAR(25) NOT NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="唯一性约束unique">3 唯一性约束（unique）</h3><h4 id="create-table-时添加约束-1">3.1 CREATE TABLE 时添加约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE test2(id INT UNIQUE, #列级约束last_name VARCHAR(15),email VARCHAR(25) UNIQUE,salary DECIMAL(10,2),    #表级约束CONSTRAINT uni_test2_email UNIQUE(email));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><p>1.在创建唯一约束时，如果不给唯一约束命名，就默认和列名相同。</p><p>2.可以向声明为unique的字段上添加null值。且可以多次添加null值。</p><h4 id="alter-table-时添加约束-1">3.2 ALTER TABLE 时添加约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#方式1:ALTER TABLE test2ADD CONSTRAINT uni_test2_sal UNIQUE(salary);#方式2:ALTER TABLE test2MODIFY last_name VARCHAR(15) UNIQUE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复合的唯一性约束">3.3 复合的唯一性约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE USER(id INT,`name` VARCHAR(15),`password` VARCHAR(25),#表级约束CONSTRAINT uk_user_name_pwd UNIQUE(`name`,`password`));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除唯一性约束">3.4 删除唯一性约束</h4><p>添加唯一性约束的列上也会自动创建唯一索引。</p><p>删除唯一约束只能通过删除唯一索引的方式删除。</p><p>删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。</p><p>如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和（）中排在第一个的列名相同。也可以自定义唯一性约束名。</p><h3 id="主键约束primary-key">4 主键约束（primary key）</h3><h4 id="create-table-时添加约束-2">4.1 CREATE TABLE 时添加约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE test3(id INT PRIMARY KEY, #列级约束last_name VARCHAR(15),email VARCHAR(25),salary DECIMAL(10,2),    #表级约束CONSTRAINT pk_test3_id PRIMARY KEY(id) #没有必要起名字);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><p>1.一个表中最多只能有一个主键约束。</p><p>2.特征：非空且唯一。用于唯一的标识表中的一条记录。</p><h4 id="alter-table-时添加约束-2">4.2 ALTER TABLE 时添加约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE test3ADD PRIMARY KEY (id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="删除主键约束实际开发中不会删除主键约束">4.3删除主键约束(实际开发中，不会删除主键约束)</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE test3DROP PRIMARY KEY;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="自增列auto_increment">5 自增列：AUTO_INCREMENT</h3><p>1.一个表最多只能有一个自增长列</p><p>2.当需要产生唯一标识符或顺序值时，可设置自增长</p><p>3.自增长列约束的列必须是键列（主键列，唯一键列）</p><p>4.自增约束的列的数据类型必须是整数类型</p><p>5.向主键(含AUTO_INCREMENT)的字段上添加0或null时，实际上会自动的往上添加指定的字段的数值</p><h4 id="create-table-时添加auto_increment">5.1 CREATE TABLE时添加AUTO_INCREMENT</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE test4(id INT PRIMARY KEY AUTO_INCREMENT,last_name VARCHAR(15));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="alter-table-时添加auto_increment">5.2 ALTER TABLE时添加AUTO_INCREMENT</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE test4MODIFY id INT AUTO_INCREMENT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="删除auto_increment">5.3 删除AUTO_INCREMENT</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE test4MODIFY id INT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="mysql-8.0新特性自增变量的持久性">5.4 MySQL8.0新特性：自增变量的持久性</h4><p>MySQL5.7中，对于自增主键的分配规则，是由InnoDB数据字典内部一个计数器来决定的，在<strong>内存中维护</strong>，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。</p><p>MySQL8.0将自增主键的计数器持久化到<strong>重做日志</strong>中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。</p><h3 id="外键约束foreign">6 外键约束（foreign）</h3><h4 id="create-table-时添加约束-3">6.1 CREATE TABLE 时添加约束</h4><p>主表和从表：父表和子表</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#先创建主表CREATE TABLE dept1(dept_id INT PRIMARY KEY,dept_name VARCHAR(15));#再创建从表CREATE TABLE emp1(emp_id INT PRIMARY KEY AUTO_INCREMENT,emp_name VARCHAR(15),department_id INT,    #表级约束(关联的外键约束要求主表上的字段必须是主键约束或唯一性约束)CONSTRAINT fk_emp1_dept_id FOREIGN KEY (department_id) REFERENCES dept1(dept_id));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="外键约束的演示">6.2 外键约束的演示</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#需要先在主表中添加,才能在从表中创建INSERT INTO dept1VALUES(10,'IT');INSERT INTO emp1VALUES(1001,'Tom',10);#需要先删除从表中的数据，才能删除主表中的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="alter-table-时添加约束-3">6.3 ALTER TABLE 时添加约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE emp1ADD CONSTRAINT fk_emp1_dept_id FOREIGN KEY (department_id) REFERENCES dept1(dept_id)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="约束等级">6.4 约束等级</h4><ul><li><p>Cascade方式：在表上update/delete记录时，同步update/delete掉子表的匹配记录</p></li><li><p>Setnull方式：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为notnull</p></li><li><p>Noaction方式：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作</p></li><li><p>Restrict方式：同no action，都是立即检查外键约束</p></li><li><p>Set default方式(在可视化工具SQLyog中可能显示空白)：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别</p><p>如果没有指定等级，就相当于Restrict方式</p><p>对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETE RESTRICT的方式。</p></li></ul><h4 id="删除外键约束">6.5 删除外键约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#一个表中可以声明多个外键约束ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;ALTER TABLE emp1DROP FOREIGN KEY fk_emp1_dept_id;#手动删除外键约束对应的普通索引SHOW INDEX FROM emp1;ALTER TABLE emp1DROP INDEX fk_emp1_dept_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="check约束">7 CHECK约束</h3><p>检查某个字段的值是否符号xx要求，一般指的是值的范围</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE test5(id INT,last_name VARCHAR(15),salary DECIMAL(10,2) CHECK(salary &gt; 2000));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="default约束">8 DEFAULT约束</h3><p>给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p><h4 id="create-table-时添加约束-4">8.1 CREATE TABLE 时添加约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE test6(id INT,last_name VARCHAR(15),salary DECIMAL(10,2) DEFAULT 2000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="alter-table-时添加约束-4">8.2 ALTER TABLE 时添加约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE test6MODIFY salary DECIMAL(10,2) DEFAULT 2500;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="alter-table-时删除约束">8.3 ALTER TABLE 时删除约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE test6MODIFY salary DECIMAL(10,2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="第13章-视图">第13章 视图</h2><h3 id="视图view概述">1 视图（View）概述</h3><p>1.视图是一种<strong>虚拟表</strong>，本身是<strong>不具有数据</strong>的，占用很少的内存空间，它是SQL中的一个重要概念。</p><p>2.视图建立在已有表的基础上，视图赖以建立的这些表称为<strong>基表</strong>。</p><p>3.视图的本质：存储起来的SELECT语句。</p><p>4.针对视图做DML操作，回影响到对应的基表中的数据。反之亦然。</p><p>5.视图本身的删除，不会导致基表中数据的删除。</p><p>6.应用场景：针对于大型项目，可以考虑使用视图。</p><p>7.优点：简化查询；控制数据的访问。</p><h3 id="创建视图">2 创建视图</h3><p>在CREATE VIEW语句中嵌入子查询</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE [OR REPLACE][ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]VIEW 视图名称 [(字段列表)]AS 查询语句[WITH [CASCADED|LOCAL] CHECK OPTION]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#针对于单表CREATE VIEW vu_emp1ASSELECT employ_id,last_name lname,salaryFROM emps;WHERE salary &gt; 8000;CREATE VIEW vu_emp2(emp_id,NAME,monthly_sal)ASSELECT employee_id,last_name,salaryFROM empsWHERE salary &gt; 8000;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#针对于多表CREATE VIEW vu_emp_deptASsELECT e.employee_id,e.department_id,d.department_nameFROM emps e JOIN depts dON e.`department_id`= d.`department_id`;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#基于视图创建视图CREATE VIEW vu_emp3ASSELECT employee_id,last_nameFROM vu_emp1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看视图">3 查看视图</h3><p>语法1：查看数据库的表对象、视图对象</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW TABLES;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>语法2：查看视图的结构</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DESC / DESCRIBE 视图名称;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>语法3：查看视图的属性信息</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查看视图信息(显示数据表的存储引擎、版本、数据行数和数据大小等)SHOW TABLE STATUS LIKE '视图名称'\G<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>语法4：查看视图的详细定义信息</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW CREATE VIEW 视图名称;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="更新视图中的数据">4 更新视图中的数据</h3><h4 id="一般情况下">4.1 一般情况下</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#更新视图的数据,会导致基表中数据的修改UPDATE vu_emp1SET salary = 20000WHERE employee_id = 101;#同理,更新表中的数据,也会导致视图中的数据的修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="不能更新的情况">4.2 不能更新的情况</h4><ul><li>在定义视图的时候指定了<code>"ALGORITHM = TEMPTABLE"</code>，视图将不支持INSERT和DELETE操作</li><li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作</li><li>在定义视图的SELECT语句中使用了<strong>JOIN联合查询</strong>，视图将不支持INSERT和DELETE操作</li><li>在定义视图的SELECT语句后的字段列表中使用了<strong>数学表达式</strong>或<strong>子查询</strong>，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值</li><li>在定义视图的SELECT语句后的字段列表中使用<strong>DISTINCT</strong>、聚合函数、<strong>GROUPBY</strong>、<strong>HAVING</strong>、<strong>UNION</strong>等，视图将不支持INSERT、UPDATE、DELETE;</li><li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE</li><li>视图定义基于一个<strong>不可更新视图</strong></li><li>常量视图</li></ul><h3 id="修改视图">5 修改视图</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#方式1CREATE OR REPLACE VIEW vu_emp1ASSELECT employee_id,last_name,salaryFROM empsWHERE salary &gt; 8000;#方式2ALTER VIEW vu_emp1ASSELECT employee_id,last_name,salaryFROM empsWHERE salary &gt; 8000;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除视图">6 删除视图</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP VIEW IF EXISTS vu_emp2,vu_emp3;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明：基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这样的视图c需要手动删除或修改，否则影响使用。</p><h3 id="总结">7 总结</h3><h4 id="视图优点">7.1 视图优点</h4><p>1.操作简单</p><p>2.减少数据冗余</p><p>3.数据安全</p><p>4.适应灵活多变的需求</p><p>5.能够分解复杂的查询逻辑</p><h4 id="视图缺点">7.2 视图缺点</h4><p>如果我们在实际数据表的基础上创建了视图，那么，如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护。特别是嵌套的视图(就是在视图的基础上创建视图)，维护会变得比较复杂，可读性不好，容易变成系统的潜在隐患。因为创建视图的SOL查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。实际项目中，如果视图过多，会导致数据库维护成本的问题</p><h2 id="第14章-存储过程与存储函数">第14章 存储过程与存储函数</h2><h3 id="存储过程概述">1 存储过程概述</h3><p>Stored Procedure：一组经过预先编译的SQL语句的封装。</p><p>好处：</p><ol type="1"><li>简化操作，提高了sql语句的重用性，减少了开发程序员的压力<br>(2)减少操作过程中的失误，提高效率<br>(3)减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器）<br>(4)减少了 SQL 语句暴露在网上的风险也提高了数据查询的安全性</li></ol><h3 id="创建存储过程">2 创建存储过程</h3><p>语法：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)[characteristics ...]BEGIN存储过程体END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="存储函数的使用">3 存储函数的使用</h3><p>语法：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE FUNCTION 函数名(参数名 参数类型,...)RETURNS 返回值类型[characteristics ...]BEGIN函数体#函数体中肯定有 RETURN 语句END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第15章-变量流程控制与游标">第15章 变量、流程控制与游标</h2><h3 id="变量">1 变量</h3><h4 id="系统变量">1.1 系统变量</h4><h5 id="系统变量分类">1.1.1 系统变量分类</h5><p>全局系统变量（需要添加<strong>global</strong>关键字）</p><p>会话系统变量（需要添加<strong>session</strong>关键字）</p><p>在MySQL中有些系统变量只能是全局的，例如 max_connections用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如character_set_client用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如pseudo_thread_id 用于标记当前会话的 MySQL连接ID。</p><h5 id="查看系统变量">1.1.2 查看系统变量</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#查看所有全局变量SHOW GLOBAL VARIABLES; #617#查看所有会话变量SHOW SESSION VARIABLES; #640#或SHOW VARIABLES;#查看部分系统变量SHOW GLOBAL VARIABLES LIKE 'admin_%';#查看指定系统变量SELECT @@glogal.max_connections;SELECT @@session.character_set_client;SELECT @@pseudo_thread_id; #先查询会话系统变量,再查询全局系统变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="修改系统变量">1.1.3 修改系统变量</h5><p>方式1：修改MySQL配置文件（需要重新MySQL服务）</p><p>方式2：在MySQL服务运行期间，使用"set"命令重新设置系统变量的值</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#全局系统变量#方式1:SET @@global.max_connections = 161;#方式2:SET GLOBAL max_connections = 171;#针对于当前的数据库实例是有效的,一旦重启mysql服务,就失效了。#会话系统变量#方式1:SET @@session.character_set_client = 'gbk';#方式2:SET SESSION character_set_client = 'gbk';#针对于当前会话是有效的，一旦结束会话，重新建立起新的会话，就失效了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="用户变量">1.2 用户变量</h4><h5 id="用户变量分类">1.2.1 用户变量分类</h5><p>会话用户变量：只对<strong>当前连接</strong>会话有效。使用"@"开头，作用域为当前会话。</p><p>局部变量：只在 BEGIN 和 END语句块中有效。局部变量只能在<strong>存储过程和存储函数</strong>中使用。</p><h5 id="会话用户变量">1.2.2 会话用户变量</h5><p>变量的声明和赋值：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#方式1:SET @用户变量 = 值;SET @用户变量 := 值;#方式2:SELECT @用户变量 := 表达式 [EROM 等子句];SELECT 表达式 INTO @用户变量 [FROM 等子句];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT @变量名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="局部变量">1.2.3 局部变量</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">BEGIN#声明局部变量DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];DECLARE 变量名2,变量名3,...变量数据类型 [DEFAULT 变量默认值];#为局部变量赋值SET 变量名1 = 值;SELECT 值 INTO 变量名2 [FROM 子句];#查看局部变量的值SELECT 变量1,变量2,变量3;END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定义条件与处理程序">2 定义条件与处理程序</h3><p>定义条件是事先定义程序执行过程中可能遇到的问题，处理程序定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行</p><h4 id="定义条件">2.1 定义条件</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DECLARE 错误名称 CONDITION FOR 错误码(错误条件)#方式1:使用MySQL_error_codeDECLARE Field_Not_Be_NULL CONDITION FOR 1048;#方式2:使用sqlstate_valueDECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE'23000';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="定义处理程序">2.2 定义处理程序</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DECLARE 处理方式 HANDLER FOR 错误类型 处理语句<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>处理方式：处理方式有3个取值: CONTINUE、EXIT、UNDO</p><ul><li><p>CONTINUE：表示遇到错误不处理，继续执行。</p></li><li><p>EXIT：表示遇到错误马上退出</p></li><li><p>UNDO：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。</p></li></ul><p>错误类型（即条件）可以有如下取值：</p><ul><li>SQLSTATE'字符串错误码'：表示长度为5的sqlstate_value类型的错误代码</li><li>MySQL_error_code : 匹配数值类型错误代码；</li><li>错误名称：表示DECLARE...CONDITION定义的错误条件名称</li><li>SQLWARNING：匹配所有以01开头的SQLSTATE错误代码</li><li>NOT FOUND：匹配所有以02开头的SQLSTATE错误代码</li><li>SQLEXCEPTION：匹配所有没有被SQLWARNING或NOTFOUND捕获的SQLSTATE错误代码</li></ul><p>处理程序：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#方法1: 捕获sqlstate_valueDECLARE CONTINUE HANDLER FOR SQLSTATE '42S02' SET @info ='NO_SUCH_TABLE';#方法2: 捕获mysql_error_valueDECLARE CONTINUE HANDLER FOR 1146 SET @info = 'NO_SUCH_TABLE';#方法3: 先定义条件，再调用DECLARE no_such_table CONDITION FOR 1146;DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @nfO = 'NO_SUCH_TABLE';#方法4: 使用SQLWARNINGDECLARE EXIT HANDLER FOR SQLWARNING SET @info ='ERROR';#方法5:使用NOT FOUNDDECLARE EXIT HANDLER FOR NOT FOUND SET @info ='NO_SUCH_TABLE';#方法6: 使用SQLEXCEPTIONDECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info ='ERROR';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="流程控制">3 流程控制</h3><h4 id="分支结构">3.1 分支结构</h4><h5 id="if">3.1.1 IF</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">IF 表达式1THEN 操作1[ELSEIF 表达式2 THEN 操作2].....[ELSE 操作N]END IF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="case">3.2.2 CASE</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#情况一: 类似于switchCASE 表达式WHEN 值1 THEN 结果1或语句1(如果是语句,需要加分号)WHEN 值2 THEN 结果2或语句2(如果是语句,需要加分号)...ELSE 结果n或语句n(如果是语句,需要加分号)END [case](如果是放在begin end中需要加上case,如果放在select后面不需要)CASE语句的语法结构2:#情况二:类似于多重ifCASEWHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号)WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号)...ELSE 结果n或语句n(如果是语句,需要加分号)END [case](如果是放在begin end中需要加上case,如果放在select后面不需要)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环结构">3.2 循环结构</h4><h5 id="loop">3.2.1 LOOP</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">[loop_label:] LOOP循环执行的语句END LOOP [loop_label]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="while">3.2.2 WHILE</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">[while_label:] WHILE 循环条件 DO循环体END WHILE [while_label];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="repeat">3.2.3 REPEAT</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">[repeat_label:] REPEAT循环体的语句UNTIL 结束循环的条件表达式END REPEAT[repeat_label]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="跳转语句">3.3 跳转语句</h4><h5 id="leave">3.3.1 LEAVE</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">LEAVE 标记名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="iterate">3.3.2 ITERATE</h5><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ITERATElabel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="游标">3.4 游标</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#1.声明游标DECLARE cursor_name CURSOR FOR select_statement;#2.打开游标OPEN cursor_name#3.使用游标FETCH cursor_name INTO var_name [, var_name] ...#4.关闭游标CLOSE cursor_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第16章-触发器">第16章 触发器</h2><p>触发器是由 事件来触发 某个操作，这些事件包括 INSERT、UPDATE、DELETE事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作。</p><h3 id="触发器的创建">1 触发器的创建</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TRIGGER 触发器名称{BEFORE|AFTER} {INSERT|UPDATE|DELETE} ON 表名FOR EACH ROW触发器执行的语句块;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看删除触发器">2 查看、删除触发器</h3><h4 id="查看触发器">2.1 查看触发器</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#方式1:SHOW TRIGGERS\G;#方式2:SHOW CREATE TRIGGER 触发器名#方式3:SELECT * FROM information_schema.TRIGGERS;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除触发器">2.2 删除触发器</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP TRIGGER IF EXISTS 触发器名称;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="第17章-mysql高级篇">第17章 MySQL高级篇</h2><h3 id="sql大小写规范">1 SQL大小写规范</h3><p>MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的：</p><p>1、数据库名、表名、表的别名、变量是严格区分大小写的；<br>2、关键字、函数名称在SQL 中不区分大小写的；<br>3、列名（或字段名）与列的别名（或字段别名）在所有的情况下均是忽略大小写的；</p><p>MySQL在Windows的环境下全部不区分大小写</p><h2 id="第17章-mysql的数据目录">第17章 MySQL的数据目录</h2><h4 id="innodb存储引擎模式"><strong>InnoDB存储引擎模式</strong></h4><p>举例：数据库a ，表b 。</p><p>如果表b采用 InnoDB，data1个或者2个文件：</p><ul><li>b.frm : 描述表结构文件，字段长度等</li><li>如果采用<strong>系统表空间</strong>模式的，数据信息和索引信息都存储在ibdata1 中</li><li>如果采用<strong>独立表空间</strong>存储模式，datab.ibd文件（存储数据信息和索引信息）</li></ul><p>此外：</p><p>① MySQL5.7 中会在data/a的目录下生成 db.opt文件用于保存数据库的相关配置。比如：字符集、比较规则。而MySQL8.0不再提供db.opt文件。</p><p>② MySQL8.0中不再单独提供b.frm，而是合并在b.ibd文件中。</p><h4 id="myisam存储引擎模式">MyISAM存储引擎模式</h4><p>如果表b采用 MyISAM，data3个文件：</p><ul><li>MySQL5.7 中：b.frm : 描述表结构文件，字段长度等。</li><li>MySQL8.0 中 b.xxx.sdi：描述表结构文件，字段长度等。</li><li>b.MYD(MYData)：数据信息文件，存储数据信息(如果采用独立表存储模式)</li><li>b.MYI(MYIndex)：存放索引信息文件</li></ul><h2 id="第18章-用户与权限管理">第18章 用户与权限管理</h2><h3 id="用户管理">1 用户管理</h3><h4 id="登录mysql服务器">1.1 登录MySQL服务器</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql -h localhost -P 3306 -p dbtest1 -e "select * from emp1";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="创建用户">1.2 创建用户</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE USER '用户名'@localhost IDENTIFIED BY '密码';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="更新用户">1.3 更新用户</h4><p>更新完需要 <code>flush privileges;</code></p><h4 id="删除用户">1.4 删除用户</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#方式1:使用DROP(推荐)DROP USER '用户名'@'localhost';#方式2:使用DELETEDELETE FROM mysql.user WHERE Host='hostname' AND User='username';flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置当前用户密码">1.5 设置当前用户密码</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#方式1:ALTER USER USER() IDENTIFIED BY 'new_password';#方式2:SET PASSWORD = 'new_password';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修改其他用户密码">1.6 修改其他用户密码</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#方式1:ALTER USER '用户名' IDENTIFIED BY 'new_password';#方式2:SET PASSWORD FOR 'username'@'localhost' = 'new_password';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="权限管理">2 权限管理</h3><h4 id="权限列表">2.1 权限列表</h4><figure><img src="C:\Users\wuhao\AppData\Roaming\Typora\typora-user-images\image-20230302195601042.png" alt="image-20230302195601042"><figcaption aria-hidden="true">image-20230302195601042</figcaption></figure><h4 id="授予权限">2.2 授予权限</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">GRANT 权限1,权限2,...权限N ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY '密码口令'];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果需要赋予包括GRANT的权限，添加参数<code>WITH GRANT OPTION</code>这个选项</p><h4 id="查看权限">2.3 查看权限</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW GRANTS;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="收回权限">2.4 收回权限</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">REVOKE 权限1,权限2,...权限n ON 数据库名称.表名称 FROM 用户名@用户地址;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>总结 有一些程序员喜欢使用 Root超级用户来访问数据库，完全把权限控制放在应用层面实现。这样当然也是可以的。但建议大家，尽量使用数据库自己的角色和用户机制来控制访问权限，不要轻易用Root 账号。因为Root账号密码放在代码里面不安全，一旦泄露，数据库就会完全失去保护。<br>而且，MySQL的权限控制功能十分完善，应该尽量利用，可以提高效率，而且安全可靠。</p><h3 id="角色管理">3 角色管理</h3><h4 id="创建角色">3.1 创建角色</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE ROLE 'role_name'[@'host_name'];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="赋予角色权限">3.2 赋予角色权限</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">GRANT privileges ON table_name TO 'role_name'[@'host_name'];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看角色权限">3.3 查看角色权限</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW GRANTS FOR 'role_name'[@'host_name'];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="回收角色的权限">3.4 回收角色的权限</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">REVOKE privileges ON table_name FROM 'role_name'[@'host_name'];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="删除角色">3.5 删除角色</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP ROLE 'role_name'[@'host_name'];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="给用户赋予角色">3.6 给用户赋予角色</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">GRANT 'role_name'[@'host_name'] TO user;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="激活角色">3.7 激活角色</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#方式1:SET DEFAULT ROLE ALL TO user;#方式2:SET GLOBAL activate_all_roles_on_login = ON;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="撤销用户的角色">3.8 撤销用户的角色</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">REVOKE role FROM user;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="设置强制角色">3.9 设置强制角色</h4><h2 id="第19章-逻辑架构">第19章 逻辑架构</h2><h3 id="逻辑架构">1 逻辑架构</h3><figure><img src="C:\Users\wuhao\AppData\Roaming\Typora\typora-user-images\image-20230302203317586.png" alt="image-20230302203317586"><figcaption aria-hidden="true">image-20230302203317586</figcaption></figure><figure><img src="C:\Users\wuhao\AppData\Roaming\Typora\typora-user-images\image-20230302204435124.png" alt="image-20230302204435124"><figcaption aria-hidden="true">image-20230302204435124</figcaption></figure><h3 id="sql执行流程">2 SQL执行流程</h3><figure><img src="C:\Users\wuhao\AppData\Roaming\Typora\typora-user-images\image-20230302204529872.png" alt="image-20230302204529872"><figcaption aria-hidden="true">image-20230302204529872</figcaption></figure><h3 id="引擎介绍">3 引擎介绍</h3><h4 id="innodb引擎具备外键支持功能的事务存储引擎">InnoDB引擎：具备外键支持功能的事务存储引擎</h4><ul><li>MySQL大于等于5.5之后，默认采用InnoDB引擎<ul><li>InnoDB是MySQL的<strong>默认事务型引擎</strong>，它被设计用来处理大量的短期（short-lived）事务。可以确保事务的完整提交（Commit）和回滚（Rollback）</li></ul></li><li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎</li><li>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎</li><li>InnoDB是为处理巨大数据量的最大性能设计</li><li>对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和索引。</li><li>MyISAM只缓存索引，不缓存真实数据；lnnoDB不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。</li></ul><h4 id="myisam引擎主要的非事务处理存储引擎">MyISAM引擎：主要的非事务处理存储引擎</h4><ul><li><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MylSAM不支持事务、行级锁、外键，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</p></li><li><p>优势是访问的速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用</p></li><li><p>针对数据统计有额外的常数存储。故而count(*)的查询效率很高</p></li><li><p>应用场景：只读应用或者以读为主的业务</p></li></ul><figure><img src="C:\Users\wuhao\AppData\Roaming\Typora\typora-user-images\image-20230302210615805.png" alt="image-20230302210615805"><figcaption aria-hidden="true">image-20230302210615805</figcaption></figure><h4 id="archive引擎用于数据存档">Archive引擎：用于数据存档</h4><ul><li>archive仅仅支持插入和查询两种功能 (行被插入后不能再修改)。</li><li>在MySQL5.5以后支持索引功能。</li><li>拥有很好的压缩机制，使用zlib压缩库，在记录请求的时候实时的进行压缩，经常被用来作为仓库使用。</li><li>创建ARCHIVE表时，存储引擎会创建名称以表名开头的文件。数据文件的扩展名为.ARZ</li><li>根据英文的测试结论来看，同样数据量下，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%</li><li>ARCHIVE存储引擎采用了行级锁。该ARCHIVE引擎支持 AUTO_INCREMENT列属性。AUTO_INCREMENT列可以具有唯一索引或非唯一索引。尝试在任何其他列上创建索引会导致错误。</li><li>Archive表适合日志和数据采集（档案）类应用，适合存储大量的独立的作为历史记录的数据。拥有很高的插入速度，但是对查询的支持较差。</li></ul><h4 id="blackhole引擎丢弃写操作读操作会返回空内容">Blackhole引擎：丢弃写操作，读操作会返回空内容</h4><h4 id="csv引擎存储数据时以逗号分隔各个数据项">CSV引擎：存储数据时，以逗号分隔各个数据项</h4><ul><li>CSV引擎可以将普通的CSV文件作为MySQL的表来处理 ，但不支持索引</li><li>CSV引擎可以作为一种数据交换的机制，非常有用</li><li>CSV存储的数据直接可以在操作系统里，用文本编辑器或者excel读取</li><li>对于数据的快速导入、导出是有明显优势的</li></ul><h4 id="memory引擎置于内存的表">Memory引擎：置于内存的表</h4><p>Memory采用的逻辑介质是内存，响应速度很快，但是当mysqld守护进程崩溃的时候数据会丢失。另外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用（长度不固定的）。</p><ul><li><p>Memory同时支持哈希 (HASH) 索引和B+树索引</p></li><li><p>哈希索引相等的比较快，但是对于范围的比较慢很多</p></li><li><p>默认使用哈希 (HASH) 索引 ，其速度要比使用B型树 (BTREE)索引快</p></li><li><p>如果希望使用B树索引，可以在创建索引时选择使用。</p></li><li><p>Memory表至少比MyISAM表要快一个数量级</p></li><li><p>MEMORY表的大小是受到限制的。表的大小主要取决于两个参数，分别是max_rows和max_heap_table_size。其中，max_rows可以在创建表时指定；max_heap_table_size的大小默认为16MB，可以按需要进行扩大</p></li><li><p>数据文件与索引文件分开存储</p><ul><li>每个基于MEMORY存储引擎的表实际对应一个磁盘文件，该文件的文件名与表名相同，类型为frm类型，该文件中只存储表的结构，而其数据文件都是存储在内存中的。</li><li>这样有利于数据的快速处理，提供整个表的处理效率</li></ul></li><li><p>缺点:其数据易丢失，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心</p><p>使用Memory存储引擎的场景：</p><ul><li>目标数据比较小，而且非常频繁的进行访问，在内存中存放数据，如果太大的数据会造成内存溢出。可以通过参数max_heap_table_size控制Memory表的大小，限制Memory表的最大的大小</li><li>如果数据是临时的，而且必须立即可用得到，那么就可以放在内存中</li><li>存储在Memory表中的数据如果突然间丢失的话也没有太大的关系</li></ul></li></ul><h4 id="federated引擎访问远程表">Federated引擎：访问远程表</h4><h4 id="merge引擎管理多个myisam表构成的表集合">Merge引擎：管理多个MyISAM表构成的表集合</h4><h4 id="ndb引擎mysql集群专用存储引擎">NDB引擎：MySQL集群专用存储引擎</h4><h2 id="第20章-索引的数据结构">第20章 索引的数据结构</h2><h3 id="索引概述">1 索引概述</h3><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。</p><p>索引的本质：索引是数据结构。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法。</p><p>索引是在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。</p><figure><img src="C:\Users\wuhao\AppData\Roaming\Typora\typora-user-images\image-20230302223802544.png" alt="image-20230302223802544"><figcaption aria-hidden="true">image-20230302223802544</figcaption></figure><p>索引按照物理实现方式，索引可以分为 2种：聚簇（聚集）和非聚（非聚集）索引。我们也把非聚集索引称为二级索引或者辅助索引。</p><p>MyISAM与InnoDB对比：</p><p>MyISAM的索引方式都是""非聚簇"的，与lnnoDB包含1个聚族索引是不同的。</p><ul><li>在lnnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引。</li><li>lnnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</li><li>lnnoDB的非聚簇索引data域存储相应记录主键的值，而MyISAM索引记录的是地址。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</li><li>MyISAM的回表操作是十分快速的，团为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</li><li>lnnoDB要求表必须有主键（MyISAM可以没有）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySOL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Modeling path information for knowledge graph completion</title>
      <link href="/2023/03/17/modeling-path-information-for-knowledge-graph-completion/"/>
      <url>/2023/03/17/modeling-path-information-for-knowledge-graph-completion/</url>
      
        <content type="html"><![CDATA[<figure><img src="\images\typora-user-images\image-20220308152758157.png" alt="image-20220308152758157"><figcaption aria-hidden="true">image-20220308152758157</figcaption></figure><p>1.节点和边的结构嵌入：使用TransE将实体和关系转换成实值表示</p><p>2.节点描述的文本嵌入：由Bi-LSTM和自注意力机制组成，首先使用TransE为描述序列生成初始嵌入，</p><p>(GloVE：输入单词序列输出单词向量序列)，接着使用Bi-LSTM，再使用注意力机制重新加权序列</p><p>3.统一编码：在得到实体表示和实体文本表示之后，通过调整他们的注意力权重，将他们放到同一个表示空间，然后将两个节点嵌入合并。</p><p>4.路径表示</p><p>①信息传播：使用GAT的一种变体在路径节点之间传播信息，使用MLP评估节点和其相邻节点之间的注意力系数。最后，根据归一化注意力系数对相邻节点的线性组合进行评估。</p><p>在GAT层之后使用了feed-forward(FFN)层(受Transformer的启发)</p><p>5.关系预测</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>A Path-based Interaction Model for Few-shot Knowledge Graph Completion</title>
      <link href="/2023/03/17/a-path-based-interaction-model-for-few-shot-knowledge-graph-completion/"/>
      <url>/2023/03/17/a-path-based-interaction-model-for-few-shot-knowledge-graph-completion/</url>
      
        <content type="html"><![CDATA[<figure><img src="\images\typora-user-images\image-20220306201557199.png" alt="image-20220306201557199"><figcaption aria-hidden="true">image-20220306201557199</figcaption></figure><p>模块1：推理模块</p><p>目的：给一个query头实体<span class="math inline">\(h_q\)</span>,得到一个包含真正尾实体<span class="math inline">\(t_q\)</span>的子图。</p><p>做法：①提取support子图 ②推理query子图</p><p>①提取support子图</p><p>对每个support实体对<span class="math inline">\((h_s,t_s)\in{S_r}\)</span>采用双侧BFS算法</p><p>最大路径长度<span class="math inline">\(T\)</span>,从<span class="math inline">\(h_s\)</span>开始执行<span class="math inline">\(\lceil{T/2}\rceil\)</span>-跳的BFS，收集不同跳数的邻居(<span class="math inline">\(N^h_i\)</span>)，以及从<span class="math inline">\(h_s\)</span>到这些邻居不同长度的相应路径(leftpaths),对<span class="math inline">\(t_s\)</span>也执行相同的操作，得到right paths</p><p>接着，计算出交点<span class="math inline">\(\{h_s\}\cap{N^t_1},{N^h_1}\cap{N^t_1},...,{N^h_{\lceil{T/2}\rceil}}\cap{N^t_{\lceil{T/2}\rceil}}\)</span>.相交的邻居用来连接左右两侧路径，最后生成从<span class="math inline">\(h_s\)</span>到<span class="math inline">\(h_t\)</span>的不同长度的路径，记作<span class="math inline">\(P(h_s,t_s)\)</span>,将其中的关系集合称为support关系集合，表示为<span class="math inline">\(R^s\)</span></p><p>②推理query子图</p><p>计算G中每一对关系之间的余弦相似度</p><p>限制每一跳的最大扩展邻居数为L，在第t跳中，我们将L个实体与<span class="math inline">\(N_L\)</span>个邻居一起扩展。</p><p>对于每个邻居<span class="math inline">\(r_i\)</span>,计算其和<span class="math inline">\(R^s\)</span>中每个support关系的相似度，可以获得最大值<span class="math inline">\(a_i^{max}=max_j\{a_{ij}\}\)</span></p><p>从<span class="math inline">\(N_L\)</span>个邻居中抽取L个邻居，每个邻居被抽取的概率为：</p><figure><img src="\images\typora-user-images\image-20220306205628378.png" alt="image-20220306205628378"><figcaption aria-hidden="true">image-20220306205628378</figcaption></figure><p>在T跳之后，可以扩展得到一个最多具有T*L个实体的query子图。</p><p>在推理的同时，我们可以追踪从<span class="math inline">\(h_q\)</span>到子图中每个扩展实体的所有路径，这被表示为<span class="math inline">\(P(h_q,t_q)\)</span></p><p>模块2：匹配模块</p><p>①表示路径 ②计算<span class="math inline">\(P(h_q,t_q)\)</span>和<span class="math inline">\(P(h_s,t_s)\)</span>之间的相互作用 ③路径注意力</p><p>①表示路径</p><p>首先用关系序列表示一条路径<span class="math inline">\(p=(r_1,r_2,...,r_{|p|})\)</span></p><p>然后放入TransE中进行预训练，作为GRU的输入，生成一个聚合的嵌入，作为路径嵌入<span class="math inline">\(\boldsymbol{p}\)</span>.（忽略了路径中的实体）</p><p>②计算路径相互作用</p><p>拿到生成的路径嵌入(<span class="math inline">\(P(h_q,t_q)\)</span>和<span class="math inline">\(P(h_s,t_s)\)</span>的)，建立相似度矩阵<span class="math inline">\(S^P\)</span>表示每个<span class="math inline">\(p_i^s\)</span>和<span class="math inline">\(p_j^q\)</span>之间的相似度(<span class="math inline">\(s_{ij}^P\)</span>)</p><p>然后使用聚合函数从相似性矩阵中提取相似性特征(RBF kernel aggregationfunction)</p><p>使用过程：先对每一行用最大池化，去获得最大的相似度<span class="math inline">\(s_i^{max}\)</span>，代表<span class="math inline">\(P(h_s,t_s)\)</span>对<span class="math inline">\(p_i\in{P(h_q,t_q)}\)</span>中最可能匹配的对应项，然后转换成长度特定的特征向量，所有的内核都代表相似性的分布。</p><p>目的：从一维相似性到Γ维相似性向量的转换可以提高相似性特征的分辨能力。</p><p>最后，把他们加起来，成为相似性嵌入。<span class="math inline">\(\phi{(P(h_s,t_s),P(h_q,t_q))}\)</span>,代表<span class="math inline">\((h_q,t_q)\)</span>和<span class="math inline">\((h_s,t_s)\)</span>之间的相似性。</p><figure><img src="\images\typora-user-images\image-20220307193953908.png" alt="image-20220307193953908"><figcaption aria-hidden="true">image-20220307193953908</figcaption></figure><figure><img src="\images\typora-user-images\image-20220307193735609.png" alt="image-20220307193735609"><figcaption aria-hidden="true">image-20220307193735609</figcaption></figure><p>③路径注意力</p><figure><img src="\images\typora-user-images\image-20220308141917115.png" alt="image-20220308141917115"><figcaption aria-hidden="true">image-20220308141917115</figcaption></figure><figure><img src="\images\typora-user-images\image-20220308141929567.png" alt="image-20220308141929567"><figcaption aria-hidden="true">image-20220308141929567</figcaption></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Research progress of zero-shot learning</title>
      <link href="/2023/03/17/research-progress-of-zero-shot-learning/"/>
      <url>/2023/03/17/research-progress-of-zero-shot-learning/</url>
      
        <content type="html"><![CDATA[<center><strong>Research progress of zero-shot learning</strong></center><center>零样本学习的研究进展</center><hr><h4 id="abstract">Abstract</h4><p>尽管自深度学习的复兴以来，监督学习取得了令人鼓舞的突破，但大规模对象类的识别仍然是一个挑战，特别是在某些类没有或很少训练样本的情况下。本文全面回顾了ZSL的发展历程，包括发展历程、关键技术、主流模型、当前研究热点和未来研究方向。首先，从多样本、少样本到零样本学习的角度介绍了进化过程。其次，从视觉特征提取、语义表示和视觉语义映射三个方面详细分析了ZSL的关键技术。第三，按时间顺序解释了一些典型模型。最后，收集近三年的相关文献，分析当前的研究热点，并列出未来的研究方向。</p><h4 id="introduction">1 Introduction</h4><p>传统的视觉识别技术通常需要大量的带标签的训练数据，如每一类需要数千张甚至上万张图像，才能达到良好的分类精度。然而，不可能为所有类收集如此大量的带有标签的数据，这对传统的监督学习是一个巨大的挑战。目前，有一些不同的解决方案，例如，半监督学习、迁移学习、特征学习和少样本学习。研究发现，训练样本越少，识别难度越大；当没有训练样本时，该过程称为零镜头学习(ZSL)。</p><p>ZSL可以看作是一种特殊的跨模态检索学习。它是一种使用未标记数据识别新类的方法，其基本思想是通过共享属性将知识从可见类转移到不可见类。大多数现有的ZSL方法使用中间语义表示（例如视觉特征或语义词向量），并且语义表示在标记的辅助数据集和未标记的目标数据集之间共享。特别地，从低级特征空间到语义空间的投影是从辅助数据集学习的，这不需要对目标数据集进行自适应。</p><h4 id="evolution-of-network-architecture">2 Evolution of networkarchitecture</h4><p>ZZSL经历了一个漫长的发展过程。无监督学习和有监督学习是机器学习领域的两个核心。前者是利用大量未标记数据训练分类器，然后利用样本之间的内在关系进行分类。后者是利用大量的标签数据来训练分类器，然后根据每个特征与其标签之间的关系来完成分类。半监督学习是一种结合了无监督学习和监督学习的方法。它使用少量的标记数据和大量的未标记数据来训练分类器，这显著提高了它对可见类的识别性能。少样本学习和半监督学习的区别在于样本数量，少样本学习需要少于10个标记样本才能完成分类过程。然而，ZSL是最极端的情况，测试类是完全看不见的。对于广义ZSL(GZSL)，测试样本包括看不见的类和看到的类。有关ZSL发展的详细信息见表1。</p><figure><img src="\images\typora-user-images\image-20211202145205830.png" alt="image-20211202145205830"><figcaption aria-hidden="true">image-20211202145205830</figcaption></figure><p>表1显示，ZSL不同于以前的监督学习方法，因为看不见的测试集和看不见的训练集是互斥的。然而，ZSL可以通过在可见类和不可见类之间建立关系来识别不可见类，如图1所示。</p><figure><img src="\images\typora-user-images\image-20211202145252803.png" alt="image-20211202145252803"><figcaption aria-hidden="true">image-20211202145252803</figcaption></figure><p>如图1所示，通常，这种关系是通过嵌入空间建立的，嵌入空间是ZSL的核心。首先从原始图像中提取特征向量构建特征空间，然后从相应的类别标签中提取语义向量构建语义空间。最后，分析空间之间的映射关系，构造嵌入空间。在训练阶段，基于语义空间，利用可见类数据集学习特征与类标签之间的关系；此外，该关系还用于在测试阶段完成预测过程。首先根据图像的特征预测出一个语义向量，然后根据该语义向量对图像的类别进行匹配。</p><figure><img src="\images\typora-user-images\image-20211202145639627.png" alt="image-20211202145639627"><figcaption aria-hidden="true">image-20211202145639627</figcaption></figure><p>其中，<span class="math inline">\(f\)</span>从训练集中获取，用于完成图像特征<span class="math inline">\(x\)</span>到嵌入空间<span class="math inline">\(k\)</span>的映射。通常采用最近邻算法或其他更复杂的相似度计算方法来预测图像的类别标签<span class="math inline">\(z\)</span>。</p><p>目前，根据训练阶段未标记数据的使用情况，现有的ZSL方法可分为两类：<br>转换(transductive)型和感应(inductive)型</p><h5 id="transductive-type">2.1 Transductive type</h5><p>TransductiveZSL意味着在分类器的训练阶段可以使用未标记的数据，如图2(a)所示。一方面，该策略可以提高模型对不可见类的泛化能力；另一方面，可以组合看不见和看到的类的数据来共同优化分类器。这种方法的动机是视觉空间<span class="math inline">\(X\)</span>和语义嵌入空间<span class="math inline">\(K\)</span>有各自的流形结构，并且在模型学习过程中，流形结构对齐是尽可能的。然后，在这种情况下学习的映射函数在测试集上表现出改进的传输能力。2012年，Fu等人首次提出了转换型ZSL，他引入了用户定义属性的生成模型。通过原型的平均k近邻(KNN)预测测试数据的属性分布。</p><p>TransductiveZSL的另一个代表性工作是讨论了分析流形结构与模型在不同语义嵌入空间中的传输能力之间关系的指标，然后构建了流形结构的优化模型。Verma等人使用了生成框架，该框架可以自然地使用概率分布表示每个类。他们的方法还使用了来自不可见类的未标记数据，并采用转移/半监督学习来改进类分布的估计。值得注意的是，通过提供少量附加标签，他们的方法可以很容易地自我更新，然后可以很容易地扩展到少样本学习。</p><figure><img src="\images\typora-user-images\image-20211202145946827.png" alt="image-20211202145946827"><figcaption aria-hidden="true">image-20211202145946827</figcaption></figure><h5 id="inductive-type">2.2 Inductive type</h5><p>InductiveZSL是指只有分类器的训练阶段使用的训练集，然后在测试阶段并行预测类标签，如图2(b)所示。TransductiveZSL模型中的训练样本对未标记的测试样本有严格的要求，这在一定程度上限制了ZSL训练过程。但是，InductiveZSL具有较好的灵活性和可扩展性，符合实际问题的要求。因此，它也是目前应用最广泛的ZSL方法。</p><h4 id="key-techniques-for-zsl">3 Key techniques for ZSL</h4><p>研究人员针对ZSL问题所使用的一般步骤是视觉特征提取、语义表示和视觉语义映射，如图3所示。</p><figure><img src="\images\typora-user-images\image-20211202150409939.png" alt="image-20211202150409939"><figcaption aria-hidden="true">image-20211202150409939</figcaption></figure><h5 id="visual-feature-extraction">3.1 Visual feature extraction</h5><h5 id="semantic-representation">3.2 Semantic representation</h5><p>ZSL不仅使用视觉特征进行识别，而且引入了语义属性，因此ZSL能够完成识别不可见类的任务，这对于传统的监督方法是不可能的。语义属性提取的目的是构造一个语义向量，该向量必须具有足够的语义能力和较强的判别能力；不幸的是，这两个需求相互矛盾。语义属性向量的高度详细的对象信息是需要的，包括一些与分类任务无关的信息。然而，强大的辨别能力要求语义向量最关注可用于区分不同对象的信息。Hascoet等人认为，不同的语义表示对ZSL的准确性有不同的影响。ZSL中的主要语义表示方法包括基于属性的方法、基于词向量的方法和基于知识图谱的方法。</p><h6 id="semantic-attribute">3.2.1 Semantic attribute</h6><p>语义属性指的是图像或对象的固有特征，它们可以在低级特征和高级类概念之间架起桥梁。属性生成方法通过在图像和视频识别任务中传递属性知识来处理数据稀疏性问题。语义属性是==根据专家知识手工标注的类标签的语义向量==，==是对象之间可以共享的自然语言属性==。它是构造语义特征最常用、最有效的方法。属性通常可以命名，例如颜色、形状、身体部位、气候、偏好等。请注意，这些定义允许不直接可见但与视觉信息密切相关的属性。众所周知，图像特征是可计算的，但人类不容易理解；人类将一个意义与一个给定的属性名相关联，这允许他们直接以属性值的形式创建注释，然后计算机可以使用这些注释。属性可以分配给图像或类，尤其是后者，因为它们可以以尽可能低的成本为新类形成属性注释；因此，它们为基于属性的零样本分类奠定了基础。</p><h6 id="semantic-word-vector">3.2.2 Semantic word vector</h6><p>基于词嵌入向量的方法通过处理无监督文本自动构造语义向量，通常采用自然语言处理技术。分布式表达方法包括Skipgram和CBOW，该方法是目前最成功的语义表示形式，因为它具有较少的维度和语义相似词之间的最近距离。近年来，字向量法在ZSL中得到了广泛的应用。用户定义的语义属性空间是根据人类专家或概念本体预先定义的，空间的每个维度都有特定的语义。语义词向量空间由NLP模型和其他语言知识库进行训练。尽管不同视觉概念的相对位置具有语义意义，例如马更像狗而不是树，但空间的每个维度都没有特定的语义意义。与无监督语言模型不同，分布式词向量表示有助于建模语言中的语法和语义规则，并支持面向向量的推理。例如，很少使用目标域和一般嵌入式词空间的本体描述进行泛化，然后通过使用用户反馈细化零样本语义分析器的参数，以提高模型的在线性能。</p><h6 id="knowledge-graph">3.2.3 Knowledge graph</h6><p>基于知识图谱的方法与上述两种方法不同，它们直接使用==类相似度==来构造语义向量，每个向量的每个元素表示类相似度。WordNet是一个范围广泛的英语词汇语义网，通过它可以提取所有看不见的类和看不见的类的最小公共上相似子集。然后，使用路径长度计算上层子集中每个类与所有其他类之间的相似性。最后，利用这些相似性构建具有层次特征的语义向量。最近，Gao等人在知识图的基础上完成了端到端的ZSL框架工作；该框架是一个双流卷积网络(TS-GCN)，它充分利用知识图谱来实现动作的零样本识别。</p><p>​目前，除了上述三种语义属性提取方法外，研究人员还在继续尝试新的方法。例如，Karessli等人提出了一种依赖于人类注意机制作为辅助信息的模型，并使用三种新的嵌入来学习图像和注意力之间的兼容性功能。该方法可以提供与专家注释得出的结果相当的结果。基于ZSL模型发展相对稳定的事实，研究人员开始关注细粒度识别模型的创新。一个例子是Elhoseiny等人，他提供了一个端到端的灵活紧凑模型，只对用于区分类别的部分进行编码。</p><h5 id="visual-semantic-mapping">3.3 Visual-semantic mapping</h5><p>视觉语义映射是实现ZSL不可或缺的基石，是图像特征和语义向量之间的连接点。一旦建立了视觉语义映射，就可以计算任何看不见的类的数据与看到的类原型之间的相似度，并根据相似度预测看不见的类。构建视觉语义映射的方法有三种：<br>(1)正向映射：在视觉侧建立映射模型，然后将图像特征映射到语义空间，在语义空间中完成对不可见类的识别。<br>(2)公共空间映射：映射模型建立在两侧。图像特征和语义向量同时映射到公共空间，在公共空间中识别不可见的类。<br>(3)反向映射：在语义侧建立映射模型，将语义向量映射到视觉空间，完成视觉空间中不可见类的识别。</p><figure><img src="\images\typora-user-images\image-20211202151809581.png" alt="image-20211202151809581"><figcaption aria-hidden="true">image-20211202151809581</figcaption></figure><p>这三种方法的细节如图4所示。上图中，<span class="math inline">\(f_v\)</span>代表视觉空间映射函数，<span class="math inline">\(f_s\)</span>代表语义空间映射函数。自2009年开始使用正向映射函数，它是ZSL的主流映射方法。例如，作者提出了一种非线性正演映射方法；他们的方法通过统一的概率模型自动发现并捕获对象的属性关系。2013年，Akata等人首次提出利用双线性方程进行公共空间映射，该方法具有良好的判断能力和泛化能力。2015年，首次采用反向映射，可用于为看不见的类构建虚拟训练样本，从而允许在图像特征空间中进行直接监督分类学习。例如，Bucher等人使用DAE/GAN模型将看不见的类属性向量映射到视觉空间，并使用SVM进行监督分类。他们的方法将ZSL问题转化为监督学习问题。通过对大量现有工作的分析，发现虽然采用了许多正向映射的方法，反向映射的利用率逐年提高，因为深度学习技术能够提取出相似数据分布紧凑、分辨能力强的良好图像特征结构；因此，反向映射方法将继续呈现快速发展。</p><h4 id="mainstream-zsl-models">4 Mainstream ZSL models</h4><p>近年来，ZSL的大量网络体系结构都起源于两种经典的网络模型，DAP和IAP。</p><figure><img src="\images\typora-user-images\image-20211202154007905.png" alt="image-20211202154007905"><figcaption aria-hidden="true">image-20211202154007905</figcaption></figure><p>(1)DAP:这是感应式ZSL方法的典型示例。该模型利用训练数据(如像素)直接学习从图像特征到公共属性的映射，然后利用公共属性匹配图像的类别。如图6(a)所示，该模型可以理解为三层模型。第一层是输入层；第二层表示p维特征空间(每个维表示一个特征)；第三层是输出层，显示类的判断结果。在第一层和第二层之间，存在用于判断图像是否与对应于p维视觉空间的特征一致的区域。在第二层和第三层之间，有一个知识库，用于存储p维特征空间和输出“y”之间的对应关系。DAP善于判断属性，但在预测类别方面表现不佳。此外，它无法利用新样本来提高分类器的性能；例如，它不能使用额外的属性信息，例如WordNet。</p><figure><img src="\images\typora-user-images\image-20211202160303582.png" alt="image-20211202160303582"><figcaption aria-hidden="true">image-20211202160303582</figcaption></figure><p>(2)IAP:IAP明显不同于DAP，IAP模型通过组合所有相关可见类的概率来构造属性分类器，如图6(b)所示。在训练步骤中，可以通过学习多类分类器的概率来估计所有训练类的概率，然后分类方法与DAP模型相同。</p><figure><img src="\images\typora-user-images\image-20211202160537287.png" alt="image-20211202160537287"><figcaption aria-hidden="true">image-20211202160537287</figcaption></figure><p>(3)IIAP/QR:该模型是基于IAP的增量ZSL框架。首先，提出了一种基于线性判别分析和QR更新的快速增量式分类器，该分类器可以解决增量式学习中经常出现的样本数少和样本不均匀的问题。然后，通过类属性层和零样本属性分类层的概率推理，模型能够有效地进行自我更新。</p><p>(4)ALE:ALE模型的特殊之处在于，它不研究如何从图像中提取适当的特征，而是将一个类别映射到适当的欧几里德属性空间。ALE模型学习一个函数<span class="math inline">\(f\)</span>，该函数测量图像和属性向量之间的匹配率。ALE模型使用语义信息(例如属性)将每个标签嵌入p维语义空间，并且该模型直接学习特征空间与语义向量之间的映射关系；因此，ALE训练过程由直接预测的类别指导。测试时，映射功能可以确保语义空间中映射的点远离训练过程中出现的类别对应的点，并确保正确零样本类对应的语义向量接近。需要强调的是，模型性能可以通过附加的类别辅助信息来提高，如果需要，这些信息可以转换为其他类别的先验知识。</p><p>(5)DeViSE:使用语言学习中的嵌入向量进行正则化，将标签映射到目标向量表示。该模型的softmax预测层由投影层和相似性度量层代替，投影层和相似性度量层被训练来预测每个图像的这些向量。关于损失函数，将点积相似性和hinglerank损失结合起来，并在分布式计算平台上通过同步随机梯度下降对模型进行训练；因此，它比线性搜索方法更快。</p><p>(6)ConSE:该模型与DEVICE模型完全不同，因为它保持了卷积网络softmax层的完整性，并且不需要进一步训练神经网络。对于给定的测试图像，ConSE可以运行KRiZevSkyet等人的分类器，并考虑模型的排名<span class="math inline">\(T\)</span>预测。然后，计算<span class="math inline">\(T\)</span>语义嵌入向量在语义空间中的凸组合，该步骤定义了从softmax分类器的输出到嵌入空间的确定性变换。</p><p>(7)SJE:在该模型中，通过确定产生最高相关兼容性分数的标签来执行图像的ZSL。为了解决细粒度ZSL问题，构造了一个兼容性函数，以获得匹配嵌入比不匹配嵌入更高的分数。提出了一种新的弱监督word2vec变体，它可以与其他输出相结合，以提高细粒度识别精度。</p><p>(8)ESZSL:该模型基于一个通用框架。该框架将特征、属性和类之间的关系建模为两个线性网络，其中顶部的权重不是学习的，而是由环境给定的。该方法提供了一种学习泛化错误并将其转化为领域自适应方法的策略。</p><p>(9)LatEM:该模型还关注于双线性框架，并为学习图像和类嵌入之间的兼容性函数提供了一种新的潜在嵌入模型。该方法通过添加潜变量扩展了双线性相容性模型(ESZSL)。该模型不学习单个双线性映射，而是学习一组映射。该模型通过基于排序的目标函数进行训练，该函数惩罚给定图像的真实类的错误排序。</p><p>(10)SCoRE:一些方法采用独立学习语义(Deep-RIS)，而另一些方法通过训练类来监督子空间(Deep-RULE)。然而，前一种类型可以约束整个空间，但缺乏执行语义关联的能力。后者虽然具有语义关联能力，但部分语义空间是无监督的，这加剧了语义域转移的问题。因此，作者在一个新的卷积神经网络(CNN)框架中利用了这两种类型的互补性，该框架使用语义约束进行识别，CNN的传输能力由一个隐藏的语义层和语义代码支持。</p><p>(11)MFMR:该模型是基于矩阵三因式分解的多重正则化投影的新框架。具体来说，在语义嵌入和类标签矩阵的指导下，通过对视觉特征矩阵的分解来学习语义嵌入投影。通过在视觉数据中引入流形正则化学习投影和语义嵌入，可以有效地捕捉几何流形结构，避免投影域移位问题。</p><p>(12)SAE:这也是域转移问题的解决方案。对模型输入层生成的属性层进行变换，使其具有恢复到原始输入层的功能；此外，映射层必须具有特定语义的限制，从而确保映射函数保留尽可能多的关于原始输入层的信息。</p><p>(13)JSLA:以往的属性学习方法大多侧重于命名语义属性，而忽略了潜在的可共享视觉属性的含义；为此，提出了一种新的词典学习模型，将词典空间分解为语义属性、潜在区分属性和潜在背景属性三部分。然后，通过多任务迁移学习框架对该联合属性学习模型进行扩展，以解决无监督领域自适应问题。</p><p>(14)LAD:该模型还考虑了属性之间的相关性对识别效果的影响。提出了一种潜在的属性空间学习方法，该方法不仅具有区分性，而且零样本学习的研究进展也存在语义限制。具体来4说，该模型使用字典学习框架将潜在属性空间与属性空间和相似空间关联起来。</p><p>(15)SYNC:该模型通过添加一组虚拟对象类来连接可见类和不可见类，并通过这些虚拟类的凸组合来派生新的嵌入，从而实现语义空间和视觉空间之间的对齐。</p><p>(16)LDF:许多研究侧重于学习视觉和语义空间的正确映射，但忽略了学习判别式表示的重要性。开发了一个端到端网络，该网络可以通过zoom网络自动发现识别区域。</p><p>(17)DIPL:学习特征空间和语义空间之间的投影函数是ZSL的关键，该函数可以有效地抵抗可见类和不可见类之间巨大的领域鸿沟。该模型有两个新组件：第一个是在可见/不可见类数据中引入域不变特征自重构任务。其次，映射的学习可以进一步对齐两个域，在语义空间中形成一个超类，实现可见类和不可见类之间的语义结构共享。</p><p>(18)SSE:基于将每个源/目标数据对用作可见类混合比，如果两个样本属于相同的不可见类，则混合模式必须相似；这启发了学习嵌入式源/目标函数的研究。这些函数将任意源/目标域数据映射到同一语义空间；因此，本文提出了一个学习相似性函数的最大margin框架。</p><p>结论：</p><p>DAP和IAP模型的相似之处在于使用支持向量机(SVM)学习嵌入，并采用贝叶斯公式进行识别。然而，区别在于DAP擅长识别属性，而IAP模型擅长识别类。在这些模型中，IAP/QR模型是IAP的扩展，而ALE是DAP模型的扩展。</p><h4 id="generalized-zero-shot-learning-gzsl">5 Generalized zero-shotlearning (GZSL)</h4><p>传统的ZSL是指在训练阶段只使用可见类，而在测试阶段使用不可见类的情况。虽然这种假设可以大大简化识别任务，但在实际应用中并不现实；毕竟，在测试阶段，可见和不可见的类都可能出现，这称为GZSL。首先，需要区分要识别的对象属于可见类还是不可见类，然后确定特定的成员类。2013年，Socher等人从迁移学习的角度引入了GZSL。该具体实现首先在语义空间中使用离群点检测，然后开发两个独立的识别模型。2016年，Zhao等人首次提出了GZSL的概念，Song等人首次使用转换模型探索GZSL的设置问题，有效解决了分类偏差问题。参考文献[78]的作者开发了一种低维嵌入方法，它缓解了将高维视觉特征映射到语义空间所造成的语义鸿沟。提出了一种新的深度校准网络(DCN)，可以同时校准源类别的置信度和目标类别的不确定度。该方法将图像的视觉特征和类原型的语义表示映射到一个公共的嵌入空间，从而确保源类和目标类数据的最大兼容性。Arora创建了基于变分自动编码器的体系结构。该体系结构的关键是反馈驱动机制，其中鉴别器将生成的示例映射到相应的类属性向量。然后，得到了一种改进的生成器，该生成器可以减少GZSL中可见类预测的偏差。值得一提的是，Shafin提出了一个解决传统ZSL、GZSL和小样本学习(FSL)问题的总体策略。该方法基于一种新的类别自适应主方向(CAPD)概念，允许在语义空间中嵌入多个图像特征。因此，可以在可见类和不可见类之间实现高效且自适应的信息传输。</p><p>虽然在探索向深层神经网络添加新类的同时保持模型识别原始类的能力方面取得了一些成就，但终身学习和逐步添加新类仍然是未解决的问题。</p><h4 id="analysis-of-relevant-papers">6 Analysis of relevant papers</h4><h5 id="paper-collection-and-analysis">6.1 Paper collection andanalysis</h5><h5 id="challenges-and-the-future">6.2 Challenges and the future</h5><h4 id="section"></h4><h4 id="conclusions">7 Conclusions</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>A Generative Adversarial Approach for Zero-Shot Learning from Noisy Texts</title>
      <link href="/2023/03/17/a-generative-adversarial-approach-for-zero-shot-learning-from-noisy-texts/"/>
      <url>/2023/03/17/a-generative-adversarial-approach-for-zero-shot-learning-from-noisy-texts/</url>
      
        <content type="html"><![CDATA[<center><strong>A Generative Adversarial Approach for Zero-Shot Learning fromNoisy Texts</strong></center><center>从噪声文本中进行零样本学习的生成性对抗方法</center><hr><h4 id="abstract">Abstract</h4><p>使用GAN从文本描述中想象不可见的类别，从而在看不到实例的情况下可以识别新类。</p><p>具体来说，我们提出了一个简单而有效的生成模型，该模型将关于一个不可见的类的嘈杂文本描述作为输入，并为该类生成合成的视觉特征。通过添加虚假数据，零样本学习转化为传统的分类问题。此外，为了保留所生成特征的类间区分，提出了一种视觉轴心正则化方法(avisual pivotregularization)作为显式监督。可以在无需额外正则化的情况下抑制噪声。从经验上看，我们的方法在基于文本的零镜头学习的最大可用基准上始终优于最新水平。</p><h4 id="introduction">1 Introduction</h4><p>在传统的目标分类任务中，所有类别的样本都可用于训练模型。然而，现实世界中的对象具有长尾分布。尽管可以很容易地找到常见概念的图像，但是仍然存在大量的视觉数据不足且稀疏的概念，因此传统的对象分类方法不可行。零样本学习正是为了解决这样一个不可见的目标识别问题，近年来得到了广泛的研究。</p><p>确保零样本学习成功的基本方法是找到一种==中间语义表示==(例如属性或文本特征)，将从已知类学到的知识转移到未知类。大多数最先进的方法考虑将零样本学习作为==视觉语义(visual-semantic)嵌入==问题。该范式可以概括为将视觉特征和语义特征投影到公共嵌入空间的训练映射函数。通过在嵌入空间中对所有不可见类的语义特征与实例的视觉特征之间的相似度进行排序，预测不可见实例的类标签。这种策略从语义空间到视觉空间进行一对一的投影。然而，类别和对象的文本描述固有地映射到图像空间中的各种点。这促使我们研究对抗训练如何通过增加随机性来学习一对多映射。</p><p>在本文中，我们采用了一种新的策略，将零样本学习转化为想象问题，如图1所示。我们的重点是研究如何在保持类间区分的同时，产生能够提供类内多样性的有能力的数据实例。一旦这个伪数据被生成，一个有监督的分类器被直接训练来预测看不见的图像的标签。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Structure-Augmented Text Representation Learning for Efficient Knowledge Graph Completion</title>
      <link href="/2023/03/17/structure-augmented-text-representation-learning-for-efficient-knowledge-graph-completion/"/>
      <url>/2023/03/17/structure-augmented-text-representation-learning-for-efficient-knowledge-graph-completion/</url>
      
        <content type="html"><![CDATA[<figure><img src="\images\typora-user-images\image-20220509150128444.png" alt="image-20220509150128444"><figcaption aria-hidden="true">image-20220509150128444</figcaption></figure><p>感知三元组编码器(structure-aware triple encoder)</p><p>目标：将一个图三元组编码为潜在语义空间中的向量表示(该向量表示可以输入到任何下游目标特定模块中)</p><ol type="1"><li><p>two-branchSiamese结构，通过编码query和candidate来绕过成对输入</p><p>作用：能够预先计算所有候选对象的表示，使用一个轻量级的匹配网络来计算相关性</p><p>存在问题：</p><ol type="1"><li><p>如何在三元组中保存跨实体和关系的情景化知识；</p></li><li><p>如何将Siamese结构应用于包含三个组件的三元组中；</p></li><li><p>如何促进下游模块的结构学习</p></li></ol><p>解决方法：</p><p>(1)以效率(efficiency)来权衡情境化知识：保持头实体和关系之间的情景，同时分离尾部实体进行可重用嵌入(reusableembeddings)去避免爆炸组合</p><p>(2)将一个三元组分成两个不对称的部分：①头实体和关系的串联；②尾实体</p><p>(3)为上述两个部分做了情景化嵌入，探索他们之间的空间特征来学习结构化知识</p><p>基于翻译的图嵌入方法(TransE,RotatE等)。通过将翻译函数(translationfunction)应用于头实体和关系的嵌入以及通过探索函数的输出与尾实体嵌入之间的空间关系(例如距离)来进行结构学习。</p><p>①通过隐式地将函数表述为基于Transformer的编码器应用于头实体和关系的文本串联。连接为：</p><figure><img src="\images\typora-user-images\image-20220506161755084.png" alt="image-20220506161755084"><figcaption aria-hidden="true">image-20220506161755084</figcaption></figure><p>语境化(contextualizing)的翻译函数定义为：</p><figure><img src="\images\typora-user-images\image-20220506161859462.png" alt="image-20220506161859462"><figcaption aria-hidden="true">image-20220506161859462</figcaption></figure><p>注：</p><p>1.标记令牌(token是什么)：实体(0)，关系(1)</p><p>2.Pool()收集[CLS]的结果，用于表示序列级上下文的表示</p><p>3.<strong><em>u</em></strong>是跨头实体和关系的语境化表示，是翻译函数的输出</p><p>②使用Transformer编码器应用于尾实体的文本用于对他进行编码</p><figure><img src="\images\typora-user-images\image-20220506162407801.png" alt="image-20220506162407801"><figcaption aria-hidden="true">image-20220506162407801</figcaption></figure><p>注：</p><p>1.<strong><em>v</em></strong>是尾实体的语境化表示，是尾实体的嵌入</p><p>2.本实验使用了两个Transformer编码器，并将其参数绑定在一起(提高参数的效率)</p><p>3.Transformer编码器可以通过预先训练得语言模型进行初始化，以进一步提高其表征学习的能力(在本实验中在BERT喝RoBERTa中交替出现)</p></li></ol><p>结构增强三元组评分模块(structure-augmented triple scoring module)</p><p>1.确定性表示学习(Deterministic Representation Learning)</p><ol type="1"><li><p>KG-BERT使用二元分类器来确定三元组是否合理(对于文本模型极为重要)</p></li><li><p>本文首先使用了交互式串联(<strong><em>c</em></strong>用于表示三元组两个部分之间的语义关系)</p></li></ol><figure><img src="\images\typora-user-images\image-20220507152152417.png" alt="image-20220507152152417"><figcaption aria-hidden="true">image-20220507152152417</figcaption></figure><p>然后将双向分类器(two-wayclassifier)应用于<strong><em>c</em></strong>，并产生分别对应于负概率和正概率的二维类别分布(two-dimensionalcategorical distribution)</p><figure><img src="\images\typora-user-images\image-20220507152416633.png" alt="image-20220507152416633"><figcaption aria-hidden="true">image-20220507152416633</figcaption></figure><p><strong><em>p</em></strong>的第二维表示正概率，可以作为输入三元组的分数来进行候选排名</p><figure><img src="\images\typora-user-images\image-20220507152727773.png" alt="image-20220507152727773"><figcaption aria-hidden="true">image-20220507152727773</figcaption></figure><p>2.空间结构学习(Spatial Structure Learning)</p><p>通过探索两种情景化表示之间的空间特征，可以增强编码器中的结构化知识。</p><p>计算结构化知识(<span class="math inline">\(s^d\)</span>是基于两种情景化表示的合理分数)</p><figure><img src="\images\typora-user-images\image-20220507153244695.png" alt="image-20220507153244695"><figcaption aria-hidden="true">image-20220507153244695</figcaption></figure><p>训练和推理</p><p>1.训练目标及推理细节</p><ol type="1"><li><p>进行负采样生成错误的三元组：采用了随机抽取策略</p></li><li><p>三元组分类目标：采用二进制交叉熵损失来训练编码器</p></li></ol><figure><img src="\images\typora-user-images\image-20220508154029860.png" alt="image-20220508154029860"><figcaption aria-hidden="true">image-20220508154029860</figcaption></figure><p><span class="math inline">\(D\)</span>：只包含正确三元组的训练集；<span class="math inline">\(N(tp)\)</span>：从tp生成的一组错误的三元组；<span class="math inline">\(s^c\)</span>：tp的正确率；<span class="math inline">\((1-s^c{’})\)</span></p><p>表示错误三元组<span class="math inline">\(tp^{’}\)</span>的负概率</p><p>注：使用确定性策略的表示学习对于文本编码KGC相当重要</p><ol start="3" type="1"><li>三元组对比目标：通过空间结构学习得到的基于距离的分数<span class="math inline">\(s^d\)</span>，还是用对比目标来训练编码器。对比目标考虑了正确三元组和错误三元组之间的成对排序，错误三元组因为负采样和正确三元组不同。</li></ol><p><span class="math inline">\(s^d\)</span>表示从一个正三元组<span class="math inline">\(tp\)</span>得到的分数，<span class="math inline">\(s^{d'}\)</span>表示从一个负三元组<span class="math inline">\(tp^{'}\)</span>得到的分数，损失函数为：</p><figure><img src="\images\typora-user-images\image-20220509145245013.png" alt="image-20220509145245013"><figcaption aria-hidden="true">image-20220509145245013</figcaption></figure><p>实验解释了结构学习对于减少错误的负样本和消除实体歧义的重要性，并推动我们的模型产生更可靠的排名分数。</p><ol start="4" type="1"><li>训练和推理策略</li></ol><p>总损失函数：(<span class="math inline">\(γ\)</span>为权重)</p><figure><img src="\images\typora-user-images\image-20220509145448691.png" alt="image-20220509145448691"><figcaption aria-hidden="true">image-20220509145448691</figcaption></figure><ol start="5" type="1"><li>模型效率</li></ol><p>2.自适应集成方案(Self-Adaptive Ensemble Scheme)</p><p>StAR使用了结构学习改进了文本编码方式，减少了过度自信但错误肯定的预测，并缓解了实体模糊性的问题。但是存在实体歧义问题。</p><p>解决方案：将文本编码和图嵌入方法结合。</p><p>理由：文本编码方法在k稍大(k&gt;5)的时候召回率较高；而图嵌入方法可以从k个候选中准确分配一个。</p><p>对这两种范式进行简单的平均就可以显著提高性能(说明是有效的)，于是开发了一种自适应的方案</p><p>步骤：</p><p>给一个不完整的三元组<span class="math inline">\((h,r,?)\)</span>，我们的目标是学习一个权重<span class="math inline">\(α \in[0,1]\)</span>，去生成最终的三元组特定分数：</p><figure><img src="\images\typora-user-images\image-20220509150537634.png" alt="image-20220509150537634"><figcaption aria-hidden="true">image-20220509150537634</figcaption></figure><p>其中，<span class="math inline">\(s^{(tc)}\)</span>来源于StAR，<span class="math inline">\(s^{(tc)}=s^c\ in [0,1]\)</span>；<span class="math inline">\(s^{(ge)}\)</span>是由RotatE得到的，通过重新调整所有候选的RotatE的分数为<span class="math inline">\([0,1]\)</span>以获得<span class="math inline">\(s^{(ge)}\)</span>。</p><p>具体来说，对于一个不完整的三元组，按照StAR选取排序top-k的候选，并从两个模型中获取他们的分数。</p><p>如果在不完整的三元组中存在一个不可见的实体/关系，则设置一个unseenindicator强制<span class="math inline">\(α=1\)</span>.</p><p>为了学习三元组特定的<span class="math inline">\(α\)</span>，基于两种特征构建了一个MLP：</p><p>模糊度(ambiguity degree) <span class="math inline">\(x^{(ad)}\triangleq[Std(V);Mean(M)]\)</span></p><p>分数一致性(score consistency) <span class="math inline">\(x^{(sc)}\triangleq[|s^{(sc)}-s^{(ge)}|,s^{(sc)}+s^{(ge)},s^{(tc)},s^{(ge)}]\)</span>.</p><p>最后，将特征传递到MLP中激活<span class="math inline">\(\sigma\)</span>.</p><figure><img src="\images\typora-user-images\image-20220509152033471.png" alt="image-20220509152033471"><figcaption aria-hidden="true">image-20220509152033471</figcaption></figure><p>训练过程中，固定模型和RotatE的参数，只通过铰链损失优化<span class="math inline">\(\theta^{(\alpha)}\)</span>。</p><p>推理过程中，用得到的<span class="math inline">\(s^{(sa)}\)</span>对top-k的候选重新排序，且保持其他候选不变。</p><p>两种变体：</p><ol type="1"><li><p>StAR(Ensemble): <span class="math inline">\(k \leftarrow\infty,\alpha \leftarrow 0.5\)</span>(相当于平均分数，作为整体基线)</p></li><li><p>StAR(Self-Adp): <span class="math inline">\(k \leftarrow1000,\alpha\)</span>可学习</p></li></ol><p>3.与之前基于文本的方法相比</p><p>(1)独立嵌入(Stand-aloneEmbedding)：直接将嵌入图中的实体/关系替换为文本表示，对文本应用浅层编码器，不考虑实体和关系之间的上下文信息。</p><p>(2)缝合嵌入(Joint Embedding)：</p><p>① 使用文本嵌入来表示实体/关系，将异构表示对齐到同一个空间</p><p>② 使用包含实体共现的大规模原始语料库来丰富图嵌入</p><p>缺点：没有深层的语境知识</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Open-World Knowledge Graph Completion</title>
      <link href="/2023/03/17/open-world-knowledge-graph-completion/"/>
      <url>/2023/03/17/open-world-knowledge-graph-completion/</url>
      
        <content type="html"><![CDATA[<center><strong>Open-World Knowledge Graph Completion</strong></center><center>开放世界知识图谱补全</center><hr><h4 id="abstract">Abstract</h4><p>引入了一个名为ConMask的开放世界KGC模型。该模型学习实体名及其部分文本描述的嵌入，以将看不见的实体连接到KG。为了减少嘈杂的文本描述，ConMask使用依赖关系的内容掩蔽(masking)来提取相关片段，然后训练完整的卷积神经网络将提取的片段与KG中的实体一起使用。</p><h4 id="introduction">Introduction</h4><p>KG缺点：有噪声且不完整。</p><p>封闭世界假设：KG中所有的实体和关系都不能发生改变，只能被发现。封闭世界KGC模型在很大程度上依赖于现有KG的连通性，并且最能够预测现有的、连接良好的实体之间的关系。不幸的是，由于它们严格依赖于现有KG的连通性，封闭世界KGC模型无法预测连接不良(poorly)或新实体之间的关系。因此，我们评估封闭世界KGC最适合固定或缓慢演变的KG.</p><p>本文使用了概率数据库文献中开放世界假设的思想，并放松封闭世界假设，开发一个开放的世界知识图谱补全模型，该模型能够预测涉及不可见实体或只有少量连接的实体的关系。我们正式将开放世界KGC任务定义如下：</p><p>给定一个不完整的知识图谱<span class="math inline">\(\mathcal{G}\)</span>，通过在不完整的知识图谱<span class="math inline">\(\mathcal{G}\)</span>中找到一组缺失的三元组补全<span class="math inline">\(\mathcal{G}\)</span>：<span class="math inline">\(T^{'}={\{\langle{h,r,t}\rangle|\langle{h,r,t}\rangle}\notin{T},h\in{E^i},t\in{E^i},r\in{R}\}\)</span>.<br>其中，<span class="math inline">\(E^{i}\)</span>是一个实体超集(superset).</p><p>在以上的定义中，放松了对三元组集合<span class="math inline">\(T^{'}\)</span>的约束，使得在<span class="math inline">\(T^{'}\)</span>中的三元组可以包含原始实体集<span class="math inline">\(E\)</span>中不存在的实体.</p><p>封闭世界KGC模型通过基于KG拓扑(topology)更新初始随机向量来学习实体和关系嵌入向量。因此，对于任意三元组<span class="math inline">\(\langle{h,r,t}\rangle\in{T^{'}}\)</span>，仅能使用它的初始随机向量来表示，因为它的缺失不允许任何推理函数的更新。为了预测看不见实体的缺失连接，有必要开发<u>替代特征</u>来替换封闭世界模型使用的拓扑特征。</p><p>文本内容是断开连接或新添加实体的缺失拓扑特征的自然替代。事实上，大多数KG都是直接从文本中提取的，或者是与一些底层文本描述并行构建的。然而，开放世界KGC不同于标准的信息提取任务，因为：<br>(1)开放世界KGC的目标不是从大型文本语料库中提取三元组，而是发现缺失的关系；<br>(2)开放世界KGC是一个整体任务，作为单一模型运行。</p><p>虽然简单地将实体描述包含到现有KGC模型中似乎很直观，但我们发现从非结构化文本中学习有用的向量嵌入比在封闭世界任务中学习拓扑嵌入更具挑战性：<br>(1)在封闭世界KGC模型中，每个实体都有一个唯一的嵌入，该嵌入是从其直接连接的邻居处学习的；而开放世界的KGC模型必须将实体嵌入和实体描述中的单词嵌入融合在一起。这些单词嵌入必须由共享相同单词的实体更新，而不管其连接状态如何。<br>(2)由于包含非结构化内容，开放世界模型可能会包含噪音或冗余信息。</p><p>贡献：<br>(1)描述了一个开放世界的KGC模型，称为ConMask，该模型使用关系相关的内容掩蔽(masking)来减少给定实体描述中的噪声，并使用完全卷积神经网络(FCN)将相关文本融合到关系相关的实体嵌入中。<br>(2)我们发布了由DBPedia和Wikipedia构建的两个新的知识图补全数据集，用于封闭世界和开放世界的KGC评估。</p><p><strong>Closed-World Knowledge Graph Completion</strong></p><p><strong>ConMask：开放世界KGC的内容掩蔽(ContentMasking)模型</strong></p><p>将缺失的实体(三元组的头部或尾部)作为目标，将推理过程分解为三个步骤：<br>(1)查找与任务相关的信息<br>(2)基于上下文和相关文本的隐式推理<br>(3)将相关文本解析为适当的目标实体.</p><p>ConMask模型为了模拟上述过程，由三个部分组成：<br>(1)依赖关系的内容掩蔽：突出显示与任务相关的单词<br>(2)目标融合：从相关文本中提取目标实体的嵌入<br>(3)目标实体解析：通过计算KG中目标实体候选、提取的实体嵌入和其他文本特征之间的相似性分数来选择目标实体。</p><p>ConMask从相关文本中选择与给定关系相关的单词，以减少不相关和嘈杂的单词。然后使用完全卷积网络(FCN)提取基于单词的嵌入。最后，将提取的嵌入与KG中的现有实体进行比较，以解析目标实体的排序列表。</p><figure><img src="\images\typora-user-images\image-20211129151418195.png" alt="image-20211129151418195"><figcaption aria-hidden="true">image-20211129151418195</figcaption></figure><h5 id="relationship-dependent-content-masking">Relationship-DependentContent Masking</h5><p>从文本中提取有用信息以推断KG中的新关系。</p><p>在提出的ConMask模型中，我们开发了一种称为关系相关内容屏蔽的替代方法。<br>目标是预处理输入文本，以便根据给定的关系选择相关的小片段，从而掩盖不相关的文本。</p><p>在ConMask中，我们使用与RNN中注意力机制类似的想法来选择给定关系中最相关的词，并通过为给定实体描述中的词分配依赖关系的相似性分数来屏蔽不相关的词。我们将依赖关系的内容屏蔽正式定义为：</p><figure><img src="\images\typora-user-images\image-20211129151910369.png" alt="image-20211129151910369"><figcaption aria-hidden="true">image-20211129151910369</figcaption></figure><p>其中，<span class="math inline">\(\phi\)</span>和<span class="math inline">\(\psi\)</span>代表描述和名称映射函数，分别返回表示实体描述或关系名称的词向量。<span class="math inline">\(W_{\phi(e)}\in{\mathbb{R}^{|\phi(e)|\times{k}}}\)</span>是<span class="math inline">\(e\)</span>的描述矩阵，其中每行表示一个词按<span class="math inline">\(\phi(e)\)</span>顺序的k维嵌入；<span class="math inline">\(W_{\psi(r)}\in{\mathbb{R}^{|\psi(r)|\times{k}}}\)</span>是<span class="math inline">\(r\)</span>的名称矩阵，其中每行表示一个词按关系标题<span class="math inline">\(\psi(r)\)</span>顺序的k维嵌入； <span class="math inline">\({\circ}\)</span>代表行积(row-wiseproduct)，计算每行的屏蔽权重(如在<span class="math inline">\(W_{\phi(e)}\)</span>中每个单词的嵌入)</p><p>生成这些权重的最简单方法是计算实体描述<span class="math inline">\(\phi(e)\)</span>中的每个单词与关系名称<span class="math inline">\(\psi(r)\)</span>中的单词之间的相似性分数。我们将此简单函数称为最大单词关系权重(MWRW)，并将其定义为：</p><figure><img src="\images\typora-user-images\image-20211129153046660.png" alt="image-20211129153046660"><figcaption aria-hidden="true">image-20211129153046660</figcaption></figure><p>此函数为与给定关系不相关的单词分配较低的权重，并为出现在关系中或语义上与关系相似的单词分配较高的分数。</p><p>注：得分最高的词并不总是代表实际的目标，而是经常代表与关系名称本身相似的词。我们称具有高MWRW权重的单词为指示词(indicator)，因为正确的目标词通常位于附近。</p><p>为了给目标单词分配正确的权重，我们通过使用最大上下文关系权重(MCRW)来改进内容掩蔽，以根据每个单词的上下文调整其权重：</p><figure><img src="\images\typora-user-images\image-20211129155641808.png" alt="image-20211129155641808"><figcaption aria-hidden="true">image-20211129155641808</figcaption></figure><p>其中，<span class="math inline">\(\phi(e)\)</span>中第<span class="math inline">\(i\)</span>个单词的权重等于第<span class="math inline">\(i\)</span>个单词本身和前<span class="math inline">\(k_m\)</span>个单词的最大MWRW分数。</p><p>综上所述，本文描述的依赖关系的内容屏蔽过程基于每个单词的上下文和给定关系之间的相似性为实体描述中的单词分配重要性权重。非相关内容被屏蔽后，模型需要从屏蔽内容矩阵中学习单个嵌入向量，与候选目标实体的嵌入进行比较。</p><figure><img src="\images\typora-user-images\image-20211129160230233.png" alt="image-20211129160230233"><figcaption aria-hidden="true">image-20211129160230233</figcaption></figure><h5 id="target-fusion">Target Fusion</h5><p>这里我们描述ConMask如何提取基于单词的实体嵌入。我们将此过程称为目标融合函数<span class="math inline">\(ξ\)</span>，它使用公式3的输出提取嵌入。</p><p>在这项工作中，我们决定使用完全卷积神经网络(FCN)作为目标融合结构。基于CNN的结构以其使用卷积和池捕获峰值的能力而闻名。因此，FCN非常适合从加权内容矩阵中提取有用信息。我们对FCNs的改编产生了目标融合函数<span class="math inline">\(ξ\)</span>，该函数使用内容掩蔽的输出生成一个<span class="math inline">\(k\)</span>维嵌入。</p><figure><img src="\images\typora-user-images\image-20211129183640839.png" alt="image-20211129183640839"><figcaption aria-hidden="true">image-20211129183640839</figcaption></figure><p>图3显示了目标融合过程及其相关内容屏蔽过程的总体架构。目标融合过程有三个FCN层。在每一层中，我们首先使用两个1-D卷积算子来执行仿射变换，然后对卷积输出应用sigmoid激活函数，然后进行批量归一化和最大池化。最后一个FCN层使用平均池而不是最大池，以确保目标融合层的输出始终返回单<span class="math inline">\(k\)</span>维嵌入。</p><p>目标融合的目标是提取给定关系的嵌入，在每个FCN层之后，我们将嵌入的数量减少一半，但不增加通道的数量，也就是嵌入大小。这是因为输入加权矩阵是一个具有大部分零值的稀疏矩阵，因此我们基本上是将输入矩阵的峰值融合到表示目标实体的单个嵌入中。</p><h5 id="semantic-averaging">Semantic Averaging</h5><p>尽管可以使用目标融合生成ConMask中使用的所有实体嵌入，但这样的过程会产生大量参数。此外，由于目标融合函数是一个提取函数，因此在不需要提取的情况下，将其应用于实体名称是很奇怪的。我们还使用了一个简单的平均函数结合单词嵌入来表示实体名称和生成其他文本特征的背景表示：</p><figure><img src="\images\typora-user-images\image-20211129190105642.png" alt="image-20211129190105642"><figcaption aria-hidden="true">image-20211129190105642</figcaption></figure><p>其中，<span class="math inline">\(W\in{\mathcal{R}^{k_l\times{k}}}\)</span>是来自实体描述<span class="math inline">\(\phi(\cdot)\)</span>或实体或关系名称<span class="math inline">\(\psi(\cdot)\)</span>的输入嵌入矩阵。</p><p>总而言之：在模型中，我们已经通过内容屏蔽和目标融合操作生成了实体嵌入。下一步是定义一个损失函数，在KG中查找与生成的嵌入最匹配的一个或多个实体。</p><h5 id="loss-function">Loss Function</h5><p>设计了一个部分列表式排名损失函数，该函数具有正向和负向目标抽样：</p><figure><img src="\images\typora-user-images\image-20211129220014982.png" alt="image-20211129220014982"><figcaption aria-hidden="true">image-20211129220014982</figcaption></figure><p>其中，<span class="math inline">\(p_c\)</span>是基于均匀分布<span class="math inline">\(U[0,1]\)</span>的损坏(corruption)概率。当<span class="math inline">\(p_c&gt;0.5\)</span>时，我们保留输入尾部实体<span class="math inline">\(t\)</span>，但对头部实体进行正采样和负采样。当<span class="math inline">\(p_c\le0.5\)</span>时，我们保持输入头部实体完整，并对尾部实体进行采样。<span class="math inline">\(E^+\)</span>和<span class="math inline">\(E^-\)</span>是分别从正负目标分布<span class="math inline">\(P_+\)</span>和<span class="math inline">\(P_{-}\)</span>中提取的采样正负实体集。虽然类型约束或基于频率的分布可能会产生更好的结果，但在这里，我们遵循惯例，简单地对<span class="math inline">\(P_+\)</span>和<span class="math inline">\(P_{-}\)</span>应用简单的均匀分布。 <br>当<span class="math inline">\(p_c\le0.5\)</span>时，<span class="math inline">\(P_+\)</span>是一个在<span class="math inline">\(\{t_+|{\langle{h,r,t_+}\rangle\}\in{T}}\)</span>中统一分布的实体，而<span class="math inline">\(P_-\)</span>是一个在<span class="math inline">\(\{t_-|{\langle{h,r,t_-}\rangle\}\notin{T}}\)</span>中统一分布的实体。<br>当<span class="math inline">\(p_c&gt;0.5\)</span>时，<span class="math inline">\(P_+\)</span>是一个在<span class="math inline">\(\{h_+|{\langle{h_+,r,t}\rangle\}\in{T}}\)</span>中统一分布的实体，而<span class="math inline">\(P_-\)</span>是一个在<span class="math inline">\(\{h_-|{\langle{h_-,r,t}\rangle\}\notin{T}}\)</span>中统一分布的实体。</p><p>等式6中的函数<span class="math inline">\(S\)</span>是ConMask的softmax归一化输出：</p><figure><img src="\images\typora-user-images\image-20211129223625913.png" alt="image-20211129223625913"><figcaption aria-hidden="true">image-20211129223625913</figcaption></figure><p>注意，等式6实际上是大多数现有KGC模型使用的抽样过程的一般形式。当<span class="math inline">\(|E_+|=1\)</span>和<span class="math inline">\(|E_-|=1\)</span>时，式6中描述的抽样方法与TransE等和许多其他封闭世界KGC模型使用的三元组损坏相同。当<span class="math inline">\(|E_+|=|\{t|{\langle{h,r,t}\rangle\}\in{T}\}}|\)</span>时，这是给定部分三元组<span class="math inline">\(\langle{h,r,?}\rangle\)</span>的所有真三元组的数目，公式6与ProjE_listwise相同。</p><p>==源码==： https://github.com/bxshi/ConMask</p><h4 id="conclusion-and-future-work">Conclusion and Future Work</h4><p>在目前的工作中，我们引入了一个新的开放世界知识图完成模型ConMask，该模型使用关系相关内容掩蔽、完全卷积神经网络和语义平均从KGs中实体和关系的文本特征中提取关系相关嵌入。在开放世界和封闭世界KGC任务上的实验表明，ConMask模型在这两种任务中都具有良好的性能。由于在标准KGC数据集中发现的问题，我们还发布了两个新的DBPedia数据集，用于KGC研究和开发。ConMask模型是一种提取模型，目前只有在实体描述中表达了必要的信息时才能预测关系。未来工作的目标是扩展ConMask，使其能够发现新的或隐含的关系。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KBGAN Adversarial Learning for Knowledge Graph Embeddings</title>
      <link href="/2023/03/17/adversarial-learning-for-knowledge-graph-embeddings/"/>
      <url>/2023/03/17/adversarial-learning-for-knowledge-graph-embeddings/</url>
      
        <content type="html"><![CDATA[<center><strong>KBGAN: Adversarial Learning for Knowledge GraphEmbeddings</strong></center><center>知识图谱嵌入的对抗式学习</center><hr><h4 id="abstract">Abstract</h4><p>KG中通常只包含positive事实，因此，采样有用的negative训练实例式一项非常重要的任务。用统一随机选择的实体替换事实的头部或尾部实体是生成negative事实的常规方法，但是生成的大多数negative事实可以很容易地与positive事实区分开来，并且对训练几乎没有帮助。</p><p>受生成性对抗网络的启发，我们使用一个知识图嵌入模型作为负样本生成器来帮助训练我们所需的模型，该模型在GAN中充当鉴别器。</p><p>该框架独立于生成器和鉴别器的具体形式，因此可以利用各种知识图嵌入模型作为其构建块。</p><h4 id="introduction">1 Introduction</h4><p>使用KG的离散(discrete)表示的一个主要挑战是缺乏访问不同实体和关系之间相似性的能力。<br>KGE的主要思想是在向量空间中表示实体和关系，并且可以使用机器学习技术来学习潜在空间中知识图的连续表示。</p><p>对于空间效率(spaceefficiency),大多数KG在默认情况下仅存储beliefs，而不存储disbeliefs然而，在训练嵌入模型时，只有正面示例的自然存在。要使用负面示例，常用的方法是删除正确的尾部实体，并从均匀分布中随机采样。<br>缺点：这种方法并不理想，因为抽样实体(尾实体)可能与头实体与关系完全无关，因此随机生成的负面示例的质量通常很差。</p><p>其他方法可能利用==外部本体约束==(external ontologicalconstraints)(如实体类型等)生成负面示例，但此类资源并不总是存在或可访问。</p><p>在这项工作中，我们提供了一个通用的解决方案，以改进各种知识图嵌入模型的训练。本文提出了一种新的对抗性学习框架，即KBGAN，用于生成更好的负面示例来训练知识图嵌入模型。更具体地，我们考虑基于概率的(probability-based)log-loss嵌入模型作为生成器来提供更好质量的负面示例，并使用基于距离的(distance-based)margin-loss嵌入模型作为鉴别器来生成最终的知识图嵌入。<br>然后，我们考虑一步强化学习设置，并使用方差缩减(variance-reduction)强化(REINFORCE)方法来实现这一目标。</p><p>贡献：<br>(1)我们是第一个考虑对抗学习产生有用的negative训练实例的改进的知识图谱嵌入。<br>(2)这种对抗性学习框架适用于广泛的KGE模型，无需外部本体约束。<br>(3)我们的方法在三个常用的KGE数据集上显示了一致的性能增益。</p><h4 id="related-work">2 Related Work</h4><h5 id="knowledge-graph-embeddings">2.1 Knowledge Graph Embeddings</h5><h5 id="generative-adversarial-networks-and-its-variants">2.2 GenerativeAdversarial Networks and its Variants</h5><p>框架依赖于==策略梯度==来训练生成器，该生成器提供离散的负三元组。</p><h4 id="our-approaches">3 Our Approaches</h4><h5 id="训练目标的类型">3.1 训练目标的类型</h5><p><span class="math inline">\(\mathcal{T}\)</span>为真实的三元组集合。</p><p>根据对得分的解释不同，导致了不同的训练目标。<br>(1)Marginal lossfunction(边缘损失函数)：用于基于翻译的(translation-based)模型，得分函数为点/向量之间的距离，如TransE等。在这些模型中，较小的距离表示真实的可能性较高，其损失函数为：</p><figure><img src="\images\typora-user-images\image-20211126212149315.png" alt="image-20211126212149315"><figcaption aria-hidden="true">image-20211126212149315</figcaption></figure><p>其中，负三元组是通过在知识图谱中使用随机实体替换正三元组的头(尾)实体生成的。</p><p>(2)Log-softmax lossfunction(对数最大损耗函数)：用于得分函数有概率解释的模型，如RESCAL,DistMult,ComplEx.<br>对于一组给定的三元组分数应用softmax函数，可以得出三元组成为最好的一个概率：</p><figure><img src="\images\typora-user-images\image-20211126212523372.png" alt="image-20211126212523372"><figcaption aria-hidden="true">image-20211126212523372</figcaption></figure><p>损失函数是该概率模型的负对数似然：</p><figure><img src="\images\typora-user-images\image-20211126212552036.png" alt="image-20211126212552036"><figcaption aria-hidden="true">image-20211126212552036</figcaption></figure><p>注：softmax函数给出了一组三元组上的概率分布，这是生成器从中采样所必需的。</p><h5 id="均匀负采样的缺点">3.2 均匀负采样的缺点</h5><p>将正三元组的头或尾实体替换为<span class="math inline">\(\mathcal{E}\)</span>中的任意一个实体，所有实体的概率相等。以这种方式生成的大多数负三元组对学习有效嵌入贡献甚微，因为它们==显然==是错误的。</p><p>不满足类型约束→满足类型约束，如果不详细了解就无法证明他是错的</p><p>如果一个KGE模型被提供了大多数“过于简单”的负面示例，那么它可能只会学习表示类型，而不会学习底层语义。</p><p>对于使用log-softmax损失函数的模型，问题不那么严重，因为它们通常在每次迭代中为一个正三元组采样数十个或数百个负三元组，并且其中可能有一些有用的负三元组(比如100:1的负/正比例可能会获得最佳性能)。然而，对于正负比始终为1:1的marginal损失函数，均匀采样负片的低质量会严重损害其性能。</p><h5 id="知识图谱嵌入模型的生成性对抗训练">3.3知识图谱嵌入模型的生成性对抗训练</h5><p>KBGAN使用具有softmax概率的KGE模型为训练目标为marginal损失函数的KGE模型的训练提供高质量的负样本。该框架独立于这两个模型的得分函数，因此具有一定的通用性。</p><figure><img src="\images\typora-user-images\image-20211126213706034.png" alt="image-20211126213706034"><figcaption aria-hidden="true">image-20211126213706034</figcaption></figure><p>1.将softmax概率模型作为生成器，因为它可以模拟离散GAN概率分布过程中的“采样”。</p><p>任务目标：产生一个好的鉴别器(不是一个分类器)从而能让他训练一个好的生成器。</p><p>直观地说，鉴别器应该为高质量的负样本分配相对较小的距离。<br>为了鼓励生成器生成有用的负样本，生成器的目标是最小化鉴别器为其生成的三元组提供的距离(使高质量负样本距离最小化)。就像普通的训练过程一样，鉴别器的目标是最小化正三元组和产生的负三元组之间的marginal损失。在对抗性训练环境中，生成器和鉴别器交替地朝着各自的目标进行训练。</p><p>假设生成器在给定正三元组<span class="math inline">\((h,r,t)\)</span>的情况下，生成负三元组<span class="math inline">\(p_G(h^{'},r,t^{'}|h,r,t)\)</span>的概率分布，并通过在该分布中采样生成负三元组<span class="math inline">\((h^{'},r,t^{'})\)</span>.<br><span class="math inline">\(f_D(h,r,t)\)</span>是鉴别器的得分函数，鉴别器的目标可表述为最小化以下marginal损失函数：</p><figure><img src="\images\typora-user-images\image-20211126214850708.png" alt="image-20211126214850708"><figcaption aria-hidden="true">image-20211126214850708</figcaption></figure><p>该损失函数与公式1之间的唯一区别在于，它使用了来自生成器的负样本。</p><p>生成器的目标可以表述为最大化以下负距离期望：</p><figure><img src="\images\typora-user-images\image-20211126214949514.png" alt="image-20211126214949514"><figcaption aria-hidden="true">image-20211126214949514</figcaption></figure><p><span class="math inline">\(R_G\)</span>涉及离散采样步骤，因此，我们无法通过简单的区分来确定等级。我们使用策略梯度定理(PolicyGradient Theorem)的一个简单特例来获得<span class="math inline">\(R_G\)</span>相对于生成器参数的梯度：</p><figure><img src="\images\typora-user-images\image-20211126215346594.png" alt="image-20211126215346594"><figcaption aria-hidden="true">image-20211126215346594</figcaption></figure><p>其中，第二个近似等式意味着我们在实践中通过抽样来近似期望值。现在，我们可以计算<span class="math inline">\(R_G\)</span>的梯度并使用基于梯度的算法对其进行优化。</p><p>策略梯度定理起源于强化学习(RL)，所以我们想在我们的模型和RL模型之间做一个类比。生成器可以被视为智能体(agent)，通过执行操作(actions)与环境(environment)交互，并通过最大化环境(environments)对其操作的回报(reward)来改进自身。相应地，鉴别器可以被视为环境。<br>使用强化学习的术语,<span class="math inline">\((h,r,t)\)</span>是状态(state)，决定参与者(actor)可以采取什么操作(actions)，<span class="math inline">\(p_G(h^{'},r,t^{'}|h,r,t)\)</span>是策略(policy)(参与者(actor)如何选择操作(actions))，<span class="math inline">\((h^{'},r,t^{'})\)</span>是操作(action)，<span class="math inline">\(-f_D(h^{'},r,t^{'})\)</span>是回报(reward).上述优化算法在强化学习中称为REINFORCE算法。</p><p>我们的模型是RL的一个简单特例，称为单步(one-step)RL。在典型的RL设置中，智能体(agent)执行的每个操作(actions)都将改变其状态，智能体(agent)将执行一系列操作(actions)(称为一个epoch)，直到达到特定状态或操作(actions)数量达到特定限制。然而，在上面的类比中，操作(actions)并不影响状态，在每个操作(actions)之后，我们用另一个不相关的状态重新开始，因此每个epoch只包含一个操作(actions)。</p><p>为了减少REINFORCE算法的方差，通常从奖励中减去baseline，这是一个仅取决于状态的任意数字，不影响梯度的期望。</p><p>在我们的情况下，我们替换<span class="math inline">\(-f_D(h^{'},r,t^{'})\)</span>为<span class="math inline">\(-f_D(h^{'},r,t^{'})-b(h,r,t)\)</span>在上述等式中引入基线,为了避免引入新参数，我们只需设定一个常数<span class="math inline">\(b\)</span>，即整个训练集的平均奖励，实际上，b近似于最近产生的负三元组的平均奖励。</p><p>生成器的得分函数<span class="math inline">\(f_G(h,r,t)\)</span>，给定一组候选的负三元组<span class="math inline">\(Neg(h,r,t)\)</span>,概率分布<span class="math inline">\(p_G\)</span>建模为：</p><figure><img src="\images\typora-user-images\image-20211126222554802.png" alt="image-20211126222554802"><figcaption aria-hidden="true">image-20211126222554802</figcaption></figure><p>理想情况下，<span class="math inline">\(Neg(h,r,t)\)</span>应该包含所有可能的负三元组。然而，知识图通常是高度不完整的，因此“hardest”的负三元组很可能是假的负三元组（真实的事实）。为了解决这个问题，我们通过从<span class="math inline">\(\mathcal{E}\)</span>中对<span class="math inline">\(N_s\)</span>个实体(与所有可能的负三元组相比，这是一个很小的数字)进行均匀采样来替代<span class="math inline">\(h\)</span>或<span class="math inline">\(t\)</span>来生成<span class="math inline">\(Neg(h,r,t)\)</span>。因为在现实世界的知识图中，真负三元组通常远大于假负三元组，所以这样的集合不太可能包含任何假负三元组，并且生成器选择的负三元组可能是真负三元组。使用一个小的<span class="math inline">\(Neg(h,r,t)\)</span>也可以显著降低计算复杂度。</p><p>此外，我们采用了“bern”抽样技术，该技术以更高的概率替换了“1-to-N”和“N-to-1”关系中的“1”侧，以进一步减少假负三元组。</p><p>生成器和鉴别器都需要预训练过程，与传统的用均匀负采样训练单个KBE模型相同。<br>从形式上讲，可以通过最小化等式（1）中定义的损失函数来预训练生成器，并通过最小化等式（2）中定义的损失函数来预训练鉴别器。</p><p>算法中的第14行假设我们使用vanilla梯度下降作为优化方法，但显然可以用任何基于梯度的优化算法来代替它。</p><figure><img src="\images\typora-user-images\image-20211126223625432.png" alt="image-20211126223625432"><figcaption aria-hidden="true">image-20211126223625432</figcaption></figure><h4 id="experiments">4 Experiments</h4><p>生成器(probability-based)：DistMult和ComplEx</p><p>鉴别器(translation-based)：TransE和TransD</p><h4 id="conclusions">5 Conclusions</h4><p>我们提出了一种新的对抗式学习方法，用于改进广泛的知识图嵌入模型。我们设计了一个带有双KGE组件的生成器-鉴别器框架。与随机均匀采样不同，生成器模型生成更高质量的负面示例，这使鉴别器模型能够更好地学习。为了实现错误的反向传播，我们引入了一种单步增强(REINFORCE)方法来无缝集成这两个模块。通过实验，我们在三个数据集上使用四种常用的KGE模型对所提出的想法进行了测试，结果表明，对抗式学习框架在不同的环境下对各种KGE模型都有一致的改进。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cognitive Knowledge Graph Reasoning for One-shot Relational Learning</title>
      <link href="/2023/03/17/cognitive-knowledge-graph-reasoning-for-one-shot-relational-learning/"/>
      <url>/2023/03/17/cognitive-knowledge-graph-reasoning-for-one-shot-relational-learning/</url>
      
        <content type="html"><![CDATA[<center><strong>Cognitive Knowledge Graph Reasoning for One-shot RelationalLearning</strong></center><center>小样本关系学习的知识图谱推理</center><hr><h4 id="abstract">Abstract</h4><p>关注只给出一个或几个训练实例的情况下，研究原始KG中unseen的关系类型。</p><p>提出了CogKR用于小样本知识图谱推理，通过两个模块解决：<br>(1)SummaryModule：总结给定实例的基本关系<br>(2)ReasoningModule：据此推断出正确答案。</p><p>Reasoning Module构建认知图(cognitivegraph)过程：<br>(1)迭代协调检索(系统1，直观地收集相关证据)<br>(2)推理(系统2，对收集的信息进行关系推理)</p><p>认知图提供的结构信息使我们的模型能够聚合来自多个推理路径的证据，并以图形方式解释推理过程。</p><h4 id="introduction">1 Introduction</h4><p>小样本学习在很大程度上依赖于从以前的课程中学习到的强大的先验知识，因为单个课程的训练集变得很少。先验知识的形式表示学习算法的归纳偏差。</p><p>人类的推理系统：<br>(1)通过隐式和无意识系统（系统1）检索相关信息<br>(2)通过显式、有意识和可控的推理过程（系统2）对收集到的信息进行推理</p><p>在本文中，我们提出了认知KG推理(CogKR)，其中一个summary模块和一个reasoning模块共同解决小样本KG推理问题。<br>在summary模块中，收集有关训练实例中实体的知识，并将其底层关系表示为连续向量；在reasoning模块中，基于关系向量和KG推断出关系的新事实。</p><p>具体地说，我们设计了一种新的方法来==解释==给定头实体的关系中缺失的尾实体。</p><p>在每一步中，查询相关(query-relevant)实体和关系都会从邻域中检索出来，并组织成认知图(cognitivegraph)。然后在图上进行关系推理以更新节点的表示。重复上述过程，直到找到所有相关证据。然后根据推理结果预测最终答案。</p><h4 id="problem-formulation">2 Problem Formulation</h4><p>小样本知识推理任务：给定对于一个unseen关系类型<span class="math inline">\(\hat{r}\)</span>的几个实体对<span class="math inline">\(\{(h_\hat{r}^{k},t_\hat{r}^{k})\}_{k=1}^m\)</span>,我们想预测缺失三元组<span class="math inline">\((\hat{h},\hat{r},?)\)</span>中的尾实体<span class="math inline">\(\hat{t}\)</span>.<br>本文中，我们主要关注只给出一个对<span class="math inline">\((h_\hat{r},t_\hat{r})\)</span>的情况(<span class="math inline">\(m=1\)</span>)</p><p>定义在实体集合<span class="math inline">\(\mathcal{E}\)</span>上的概率<span class="math inline">\(p_\theta(\cdot|\hat{h},(h_r,t_r))\)</span>,表示给定关系r和查询头实体<span class="math inline">\(\hat{h}\)</span>的支持对<span class="math inline">\((h_r,t_r)\)</span>，实体成为正确答案的概率。<span class="math inline">\(\theta\)</span>为参数中的模型，代表从现有事实中学到的先验知识。</p><p>给定基本事实<span class="math inline">\(\hat{t}\)</span>，训练目标应该最大化<span class="math inline">\(p_\theta(\hat{t}|\hat{h},(h_r,t_r))\)</span>：</p><figure><img src="\images\typora-user-images\image-20211123183737391.png" alt="image-20211123183737391"><figcaption aria-hidden="true">image-20211123183737391</figcaption></figure><p>其中，<span class="math inline">\(D_r={(h,t)|(h,r,t)\in{G}}\)</span>,是关系<span class="math inline">\(r\)</span>的实体对集合。</p><h4 id="approach">3 Approach</h4><p>(1)Summary Module：将实体对<span class="math inline">\((h_r,t_r)\)</span>映射到其潜在关系的连续表示<span class="math inline">\(\omega_{h_r,t_r}\)</span>.对于查询关系，只要给出一个训练实例，神经网络学习的映射就比直接优化具有更好的泛化能力。</p><p>(2)Reasoning Module：通过给出的表示<span class="math inline">\(\omega_{h_r,t_r}\)</span>和头实体<span class="math inline">\(\hat{h}\)</span>，预测正确的尾部实体<span class="math inline">\(\hat{t}\)</span>.推理模块通过在认知图上迭代扩展和推理，将隐式检索和显式推理结合。</p><figure><img src="\images\typora-user-images\image-20211123190125595.png" alt="image-20211123190125595"><figcaption aria-hidden="true">image-20211123190125595</figcaption></figure><h5 id="summary-module">3.1 Summary Module</h5><p>在summary模块中，我们收集关于给定实例中实体的信息，并总结它们之间的关系。以前的工作表明，两个实体之间的关系可以从连接它们的路径推断出来。但是，连接两个实体的路径数量可以随着路径长度的增加而呈指数增长。在只给出一个实体对的情况下，利用先验知识无法有效减少搜索空间。因此，我们应用图神经网络(GNN)生成的向量表示，推断实体对的关系。<br>给予一个实体<span class="math inline">\(e\)</span>，GNN根据实体的嵌入和其邻居集生成实体向量<span class="math inline">\(\omega_e\)</span>.</p><figure><img src="\images\typora-user-images\image-20211123191159350.png" alt="image-20211123191159350"><figcaption aria-hidden="true">image-20211123191159350</figcaption></figure><p>其中，<span class="math inline">\(\mathcal{N}_e=\{(r_k,e_k)|(e,r_k,e_k)\in\mathcal{G}\}\)</span>是实体<span class="math inline">\(e\)</span>在<span class="math inline">\(\mathcal{G}\)</span>中的输出边集合。<br>实体嵌入<span class="math inline">\(\boldsymbol{v}_e\)</span>和关系嵌入<span class="math inline">\(\boldsymbol{r}_e\)</span>可以使用现有的KG嵌入方法进行预训练。<br></p><p>给定一个实体对<span class="math inline">\((h_r,t_r)\)</span>的向量表示<span class="math inline">\(\omega_{h_r},\omega_{t_r}\)</span>,我们可以得到他们的基本关系表示：</p><figure><img src="\images\typora-user-images\image-20211123191811251.png" alt="image-20211123191811251"><figcaption aria-hidden="true">image-20211123191811251</figcaption></figure><h5 id="reasoning-module">3.2 Reasoning Module</h5><p>(1)Cognitive Graph：</p><p>推理模块由两个迭代过程构成：<br>(1)从KG中检索信息(System1)<br>(2)对收集的信息进行推理(System 2)</p><p>Cognitive Graph：存储检索到的信息和推理结果，为<span class="math inline">\(\mathcal{G}\)</span>的子图，其节点具有隐藏表示。隐藏的表示代表了G中所有实体的理解(understanding)。</p><p><span class="math inline">\(G=(V,E,X)\)</span>，其中<span class="math inline">\(V\subseteq{\mathcal{E}},E\subseteq{\mathcal{G}},X\in{\mathbb{R}^{|V|\times{d}}}\)</span>.节点<span class="math inline">\(e\)</span>的隐藏表示为<span class="math inline">\(X[e]\)</span>，在一开始，<span class="math inline">\(G\)</span>仅仅包含查询实体<span class="math inline">\(\hat{h}\)</span>，被标记为unexplored.与以往基于路径的推理方法相比，认知图具有两处优势:<br>(1)图结构允许更灵活的信息流<br>(2)如果将搜索结果组织为图形而不是路径，则搜索正确答案的效率会更高。</p><p><strong>System 1</strong></p><p>为了从<span class="math inline">\(\mathcal{G}\)</span>中检索有关证据，在每一个阶段<span class="math inline">\(i\)</span>，从子图中选择一个unexplored节点<span class="math inline">\(e_i\)</span>.用<span class="math inline">\(e_i\)</span>的部分输出扩展<span class="math inline">\(G\)</span>，并将<span class="math inline">\(e_i\)</span>标记为已探测(explored)。给定当前实体<span class="math inline">\(e_i\)</span>，可能动作<span class="math inline">\(A_i\)</span>的集合由<span class="math inline">\(e_i\)</span>在<span class="math inline">\(G\)</span>的输出边组成。具体地<span class="math inline">\(A_i={(r,e)|(e_i,r,e)\in{\mathcal{G}}}\)</span>.<br>在这之后，我们用反向链接<span class="math inline">\((t,r^{-1},h)\)</span>并将实体的最大输出边通过一个阈值<span class="math inline">\(\eta\)</span>剪切。为了给agent不从<span class="math inline">\(e_i\)</span>扩展的选项，我们添加了一个表示无操作的特定操作。行为<span class="math inline">\(a_i\)</span>从多样式分布<span class="math inline">\(Mult(n,p_i)\)</span>中抽样。<span class="math inline">\(n\)</span>是表示行为预算的超参数，<span class="math inline">\(p_i\)</span>是<span class="math inline">\(A_i\)</span>的概率，预测为：</p><figure><img src="\images\typora-user-images\image-20211126111635058.png" alt="image-20211126111635058"><figcaption aria-hidden="true">image-20211126111635058</figcaption></figure><p>其中，<span class="math inline">\(\boldsymbol{A}_i\)</span>为候选矩阵，用于堆叠<span class="math inline">\(A_i\)</span>中所有动作的连结嵌入，输出边<span class="math inline">\((r,e)\)</span>的嵌入是实体嵌入<span class="math inline">\(v_e\)</span>，关系嵌入<span class="math inline">\(v_r\)</span>和实体隐藏表示<span class="math inline">\(X[e]\)</span>的连结。在<span class="math inline">\(a_i\)</span>中选择的边将添加到<span class="math inline">\(E\)</span>.<br>与选定边相关但不属于<span class="math inline">\(G\)</span>的节点将添加到<span class="math inline">\(V\)</span>并标记为未探测。为了限制<span class="math inline">\(G\)</span>的大小，在<span class="math inline">\(|V|\)</span>达到预定义的最大节点数<span class="math inline">\(λ\)</span>后，我们将不添加新节点。</p><p><strong>System 2</strong></p><p>在本文中，我们将深度学习应用于关系推理，这比基于规则的KG推理具有更好的泛化能力。在每一个图扩展步骤之后，相关节点的隐藏表示将根据它们在<span class="math inline">\(G\)</span>中的邻居进行更新。对于一个节点<span class="math inline">\(e\)</span>，隐藏表示的更新公式<span class="math inline">\(X[e]\)</span>为：</p><figure><img src="\images\typora-user-images\image-20211126141459877.png" alt="image-20211126141459877"><figcaption aria-hidden="true">image-20211126141459877</figcaption></figure><p>其中，<span class="math inline">\(E_e={(r^{'},e^{'})|(e^{'},r^{'},e)\in{E}}\)</span>是实体<span class="math inline">\(e\)</span>在<span class="math inline">\(G\)</span>中的ingoing边集集合。<br>这个公式可以看作是GNN的一个变体：节点的表示是将其自身信息和其邻居信息的聚合计算出来的。但是，与传统的GNN不同，当前表示层是从前一层计算的，所有表示都在同一层中，但按顺序计算。它还可以被视为路径RNN的扩展，通过为中间节点聚合来自多条路径的信息而得到增强。在所有节点标记为explored以后，我们终止推理过程，并根据其隐藏表示预测节点成为正确答案的概率：</p><figure><img src="\images\typora-user-images\image-20211126142023957.png" alt="image-20211126142023957"><figcaption aria-hidden="true">image-20211126142023957</figcaption></figure><figure><img src="\images\typora-user-images\image-20211126142047725.png" alt="image-20211126142047725"><figcaption aria-hidden="true">image-20211126142047725</figcaption></figure><h5 id="optimization">3.3 Optimization</h5><p>概率：</p><figure><img src="\images\typora-user-images\image-20211126142137540.png" alt="image-20211126142137540"><figcaption aria-hidden="true">image-20211126142137540</figcaption></figure><p>其中，<span class="math inline">\(\pi(\hat{h},(h_r,t_r))\)</span>是一种构建<span class="math inline">\(G\)</span>的随机策略。我们将这种概率优化分为两部分<span class="math inline">\(\pi(\hat{h},(h_r,t_r))\)</span>和<span class="math inline">\(q(\hat{t}|G,(h_r,t_r))\)</span>分开优化。<br>直接优化<span class="math inline">\(\pi(\hat{h},(h_r,t_r))\)</span>需要通过随机样本进行反向传播(很难处理)。相反，我们使用强化学习对图形构建进行建模，终极奖励为：<span class="math inline">\(r(G)=\mathbb{I}(t\in{G})q(\hat{t}|G,(h_r,t_r))\)</span>.在<span class="math inline">\(r(G)\)</span>的后半部分依赖于<span class="math inline">\(\theta\)</span>，在实践中，我们发现它会在训练过程中造成严重的不稳定性，所以我们最后通过设置<span class="math inline">\(r(G)=\mathbb{I}(t\in{G})\)</span>.我们采用了增强(REINFORCE)算法，去通过随机梯度更新<span class="math inline">\(\theta\)</span>：<span class="math inline">\(\bigtriangledown{\theta_{graph}=r(G)\bigtriangledown_{\theta}\log{\pi_{\theta}(G)}}\)</span>.<br>优化<span class="math inline">\(q(\hat{t}|G,(h_r,t_r))\)</span>使得正确答案的预测概率最大化。使用交叉熵损失，并更新<span class="math inline">\(\theta\)</span>通过：<span class="math inline">\(\bigtriangledown{\theta_{predict}=\mathbb{I}(t\in{G})\bigtriangledown_{\theta}\log{q(\hat{t}|G,(h_r,t_r))}}\)</span></p><p>在训练过程中，我们将梯度叠加在一起，并使用随机梯度下降来逼近整个数据集上的梯度下降。</p><h5 id="complexity-analysis">3.4 Complexity Analysis</h5><p>CogKR采用不依赖于实体编号的恒定时间，并且可以更容易地扩展到大KG。</p><h4 id="experiment">4 Experiment</h4><h4 id="related-work">5 Related Work</h4><h4 id="conclusion">6 Conclusion</h4><p>我们提出了一个新的框架CogKR来解决大规模的小样本KG推理问题。通过两个模块的组合解决一次性关系学习问题，Summary模块总结给定支support对的潜在关系，Reasoning模块根据总结找到正确答案。在认知科学双过程理论的启发下，我们用认知图组织推理过程，获得了比以往基于路径的方法更强大的推理能力。实验结果证明了该框架的优越性。我们还发现我们的方法受到KGs的非连通性的影响。因此，在未来的工作中，我们打算通过允许扩展未连接的节点来改进System1。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Knowledge Graph Attention Network for Recommendation</title>
      <link href="/2023/03/17/knowledge-graph-attention-network-for-recommendation/"/>
      <url>/2023/03/17/knowledge-graph-attention-network-for-recommendation/</url>
      
        <content type="html"><![CDATA[<center><strong>KGAT: Knowledge Graph Attention Network forRecommendation</strong></center><center>KGAT：用于推荐的知识图谱注意网络</center><hr><h4 id="abstract">Abstract</h4><p>问题：忽略了实例或项目之间的关系，这些方法不足以从用户的集体行为中提取协作信号。</p><p>工作：我们研究了知识图谱(KG)的效用，它通过将项目与其属性联系起来，打破了独立交互的假设。我们认为，在KG和用户项目(user-item)图的这种混合结构中，高阶关系——用一个或多个链接属性连接两个项目——是成功推荐的关键因素。</p><p>KGAT：以端到端的方式显式地对KG中的高阶连通性(high-orderconnectivities)进行建模。它递归地从节点的邻居（可以是用户、项目或属性）传播嵌入以细化节点的嵌入，并使用注意机制来区分邻居的重要性。</p><p>==源码==：https://github.com/xiangwang1223/knowledge_graph_attention_network</p><h4 id="introduction">1 Introduction</h4><figure><img src="\images\typora-user-images\image-20211120095752935.png" alt="image-20211120095752935"><figcaption aria-hidden="true">image-20211120095752935</figcaption></figure><p>使用高阶信息带来的挑战：<br>(1)与目标用户具有高阶关系的节点随着阶数的增加而急剧增加，这给模型带来了计算负担;(2)高阶关系对预测的贡献是不平等的，这需要模型仔细地对它们进行加权(或选择)</p><p>两种CKG结构进行推荐的方法：<br>(1)基于路径的方法：提取携带高阶信息的路径，并将其输入预测模型。为了处理两个节点之间的大量路径，他们要么应用路径选择算法来选择突出的路径，要么定义元路径模式来约束路径。<br>(2)基于正则化的方法：设计额外的损失项，捕获KG结构，以正则化推荐模型学习。</p><p>KGAT:<br>(1)递归嵌入传播，它基于节点邻居的嵌入更新节点的嵌入，并递归地执行这种嵌入传播以捕获线性时间复杂度中的高阶连通性；<br>(2)基于注意的聚集，利用神经注意机制学习传播过程中每个邻居的权重，这样级联传播的注意权重可以揭示高阶连通性的重要性。</p><p>KGAT优点：<br>(1)与基于路径的方法相比，它避免了物化路径(materializingpaths)的劳动密集型(laborintensive)过程，这样使用起来更高效、更方便<br>(2)与基于正则化的方法相比，它直接将高阶关系引入预测模型，因此所有相关参数都是为优化推荐目标而定制的。</p><p>贡献：<br>(1)我们强调了在协作知识图谱(CKG)中显式建模高阶关系的重要性，以提供更好的项目侧信息推荐；<br>(2)开发了一种新的方法KGAT，它在图形神经网络框架下以显式和端到端的方式实现高阶关系建模；<br>(3)在三个公共基准上进行了广泛的实验，证明了KGAT的有效性及其在理解高阶关系重要性方面的可解释性。</p><h4 id="task-formulation">2 TASK FORMULATION</h4><h5 id="user-item-bipartite-graph二部图">User-Item BipartiteGraph(二部图)</h5><p>user-item历史交互数据(点击或购买记录)→user-item bipartite graph <span class="math inline">\(\mathcal{G}_1\)</span>,其中<span class="math inline">\(\mathcal{G}_1=\{(u,y_{ui},i)|u\in\mathcal{U},i\in\mathcal{I}\}\)</span>，<span class="math inline">\(\mathcal{U}\)</span>和<span class="math inline">\(\mathcal{I}\)</span>表示用户集和项目集，<span class="math inline">\(y_{ui}=1\)</span>表示用户和项目之间存在可观察到的交互。</p><h5 id="knowledge-graph">Knowledge Graph</h5><p>辅助信息(项目属性和外部知识)→Knowledge Graph <span class="math inline">\(\mathcal{G}_2\)</span>(由subject-property-object三元组事实组成的有向图)，其中<span class="math inline">\(\mathcal{G}_2=\{(h,r,t)|h,r\in\mathcal{E},r\in\mathcal{R}\}\)</span>.<br>item-entityalignments(项目实体对齐)：<span class="math inline">\(\mathcal{A}=\{(i,e)|i\in\mathcal{I},e\in\mathcal{E}\}\)</span>，<span class="math inline">\((i,e)\)</span>表示项目<span class="math inline">\(i\)</span>可以与KG中的实体<span class="math inline">\(e\)</span>对齐。</p><h5 id="collaborative-knowledge-graph">Collaborative KnowledgeGraph</h5><p>将用户行为和项目知识编码为一个统一的关系图。<br>首先将每个用户行为表示为三元组<span class="math inline">\((u,Interact,i)\)</span>，<span class="math inline">\(y_{ui}=1\)</span>表示user和item中存在附加关系<span class="math inline">\(Interact\)</span>.<br>然后基于项目实体对齐集，user-item图可以与KG无缝整合成为一个统一的图<span class="math inline">\(\mathcal{G}=\{(h,r,t)|h,r\in\mathcal{E^{'}},r\in\mathcal{R^{'}}\}\)</span>，其中<span class="math inline">\(\mathcal{E^{'}}=\mathcal{E}\cup\mathcal{U}\)</span>，<span class="math inline">\(\mathcal{R^{'}}=\mathcal{R}\cup\{Interact\}\)</span>.</p><h5 id="任务描述">任务描述</h5><p><strong>输入</strong>：协作知识图谱(KGC)<span class="math inline">\(\mathcal{G}\)</span> (包含user-item二部图<span class="math inline">\(\mathcal{G}_1\)</span>和知识图谱<span class="math inline">\(\mathcal{G}_2\)</span>)</p><p><strong>输出</strong>：预测函数：能够预测用户<span class="math inline">\(u\)</span>采用项目<span class="math inline">\(i\)</span>的可能性<span class="math inline">\(\hat{y}_{ui}\)</span></p><h5 id="high-order-connectivity高阶连通性">High-OrderConnectivity(高阶连通性)</h5><p>利用高阶连接性对于执行高质量推荐非常重要。形式上，我们将节点之间的L阶连续性定义为多跳关系路径：<span class="math inline">\({e_0}\stackrel{r_{1}}\longrightarrow{e_1}\stackrel{r_{2}}\longrightarrow...\stackrel{r_{L}}\longrightarrow{e_L}\)</span>，其中<span class="math inline">\(e_l\in\mathcal{E^{'}}\)</span>，<span class="math inline">\(r_l\in\mathcal{R^{'}}\)</span>，<span class="math inline">\((e_{l-1},r_l,e_l)\)</span>表示第<span class="math inline">\(l\)</span>个三元组，<span class="math inline">\(L\)</span>为序列的长度。<br>为了推断用户的偏好，CF方法基于用户之间的行为相似性——更具体地说，相似的用户会在项目上表现出相似的偏好。表示：<span class="math inline">\({u_1}\stackrel{r_{1}}\longrightarrow{i_1}\stackrel{-r_{1}}\longrightarrow{u_2}\stackrel{r_{1}}\longrightarrow{i_2}\)</span>，说明<span class="math inline">\(u_1\)</span>可能更偏爱<span class="math inline">\(i_2\)</span>，因为与<span class="math inline">\(u_1\)</span>相同的用户<span class="math inline">\(u_2\)</span>采用了<span class="math inline">\(i_2\)</span>.<br>SL模型侧重于基于属性的连接性，假设用户倾向于采用具有相似属性的项。例如<span class="math inline">\({u_1}\stackrel{r_{1}}\longrightarrow{i_1}\stackrel{r_{2}}\longrightarrow{e_1}\stackrel{-r_{2}}\longrightarrow{i_2}\)</span>解释为<span class="math inline">\(u_1\)</span>将采用<span class="math inline">\(i_2\)</span>，因为<span class="math inline">\(i_2\)</span>有和<span class="math inline">\(u_1\)</span>以前喜欢的<span class="math inline">\(i_1\)</span>有着相同的导演<span class="math inline">\(e_1\)</span>，但这种方法将实体视为单个特征字段的值，无法揭示字段和相关实例之间的相关性。(不具有高阶连通性)</p><h4 id="methodology">3 Methodology</h4><figure><img src="\images\typora-user-images\image-20211120142226699.png" alt="image-20211120142226699"><figcaption aria-hidden="true">image-20211120142226699</figcaption></figure><p>模型主要由三个部分组成：<br>(1)嵌入层：通过保留CKG的结构将每个节点参数化为一个向量。<br>(2)注意力嵌入传播层：该层递归地传播来自节点邻居的嵌入以更新其表示，并利用知识感知注意机制在传播过程中学习每个邻居的权重。<br>(3)预测层：该层聚合来自所有传播层的用户和项目的表示，并输出预测的匹配分数。</p><h5 id="嵌入层">3.1 嵌入层</h5><p>TransR：<img src="\images\typora-user-images\image-20211120142656307.png" alt="image-20211120142656307"></p><p><span class="math inline">\(g(h,r,t)\)</span>的分数越低，说明三元组更可能是真的。</p><p>损失函数：<img src="\images\typora-user-images\image-20211120143102468.png" alt="image-20211120143102468"></p><p>该层在三元组的粒度上对实体和关系进行建模，充当正则化器并将直接连接注入表示中，从而提高了模型表示能力。</p><h5 id="注意嵌入传播层">3.2 注意嵌入传播层</h5><p>采用基于图卷积网络的体系结构，沿着高阶连通性递归传播嵌入；此外，通过利用图注意网络的思想，生成级联传播的注意权重，以揭示这种连通性的重要性。该层由三个组件组成：信息传播(<em>informationpropagation</em>),知识感知注意力(<em>knowledge-awareattention</em>),信息聚合(<em>informationaggregation</em>)。然后再将其推广到多个层</p><h6 id="information-propagation">Information Propagation</h6><p>一个实体可以参与多个三元组，充当连接两个三元组和传播信息的桥梁。</p><p>考虑一个实体<span class="math inline">\(h\)</span>，我们使用<span class="math inline">\(\mathcal{N}_h=\{(h,r,t)|(h,r,t)\in\mathcal{G}\}\)</span>去表示头实体<span class="math inline">\(h\)</span>所在的一组三元组，称为ego-network.为了表征实体<span class="math inline">\(h\)</span>的一阶连接性结构，我们计算了<span class="math inline">\(h\)</span>的ego-network的线性组合：</p><figure><img src="\images\typora-user-images\image-20211120144135101.png" alt="image-20211120144135101"><figcaption aria-hidden="true">image-20211120144135101</figcaption></figure><p>其中，<span class="math inline">\(\pi(h,r,t)\)</span>控制边<span class="math inline">\((h,r,t)\)</span>上每个传播的衰减因子，指示从<span class="math inline">\(t\)</span>到<span class="math inline">\(h\)</span>传播到关系<span class="math inline">\(r\)</span>的信息有多少。</p><h6 id="knowledge-aware-attention">Knowledge-aware Attention</h6><p>我们通过关系注意机制实现<span class="math inline">\(\pi(h,r,t)\)</span>，其公式如下：</p><figure><img src="\images\typora-user-images\image-20211120144613379.png" alt="image-20211120144613379"><figcaption aria-hidden="true">image-20211120144613379</figcaption></figure><p>这使得注意力得分取决于关系<span class="math inline">\(r\)</span>空间中<span class="math inline">\(e_h\)</span>和<span class="math inline">\(e_t\)</span>之间的距离。</p><p>此后，我们采用softmax函数对与<span class="math inline">\(h\)</span>连接的所有三元组的系数进行标准化：</p><figure><img src="\images\typora-user-images\image-20211120144834046.png" alt="image-20211120144834046"><figcaption aria-hidden="true">image-20211120144834046</figcaption></figure><p>因此，最终的注意分数能够建议应该给予哪些邻居节点更多的注意来捕获协作信号。当执行向前传播时，注意流(attentionflow)建议关注部分数据，这可以被视为推荐背后的解释。</p><p>我们的模型不仅利用了图的邻近结构，而且指定了不同重要性的邻居。此外，与仅将节点表示作为输入的图注意网络不同，我们对<span class="math inline">\(e_h\)</span>和<span class="math inline">\(e_t\)</span>之间的关系<span class="math inline">\(r\)</span>进行建模，在传播过程中编码更多信息。</p><h6 id="information-aggregation">Information Aggregation</h6><p>最后一个阶段是聚合实体表示<span class="math inline">\(\boldsymbol{e}_h\)</span>和他的ego-network表示<span class="math inline">\(\boldsymbol{e}_{\mathcal{N}_h}\)</span>用以作为实体<span class="math inline">\(h\)</span>的新代表，表示为：<span class="math inline">\(\boldsymbol{e}^{(1)}_h=f(\boldsymbol{e}_h,\boldsymbol{e}_{\mathcal{N}_h})\)</span>.使用下面三种类型的聚合器表示<span class="math inline">\(f(·)\)</span></p><p>(1)GCN Aggregator：将两种表示相加并应用非线性变换。</p><figure><img src="\images\typora-user-images\image-20211120151225941.png" alt="image-20211120151225941"><figcaption aria-hidden="true">image-20211120151225941</figcaption></figure><p>(2)GraphSageAggregator：连接(concatenate)两个表示，然后进行非线性变换。</p><figure><img src="\images\typora-user-images\image-20211120151356469.png" alt="image-20211120151356469"><figcaption aria-hidden="true">image-20211120151356469</figcaption></figure><p>(3)Bi-Interaction Aggregator：考虑<span class="math inline">\(\boldsymbol{e}_h\)</span>和<span class="math inline">\(\boldsymbol{e}_{\mathcal{N}_h}\)</span>的两种特征交互。</p><figure><img src="\images\typora-user-images\image-20211120151539902.png" alt="image-20211120151539902"><figcaption aria-hidden="true">image-20211120151539902</figcaption></figure><p>使传播的信息对<span class="math inline">\(\boldsymbol{e}_h\)</span>和<span class="math inline">\(\boldsymbol{e}_{\mathcal{N}_h}\)</span>之间的关联敏感(从类似实体传递更多的信息)</p><p>总之，嵌入传播层的优势在于显式地利用一阶连接性信息来关联用户、项目和知识实体表示。</p><h6 id="high-order-propagation">High-order Propagation</h6><p>我们可以进一步堆叠更多的传播层来探索高阶连通性信息，收集从高跳邻居传播的信息。更正式地说，在第<span class="math inline">\(l\)</span>步中，我们递归地将实体表示为：</p><figure><img src="\images\typora-user-images\image-20211120151914318.png" alt="image-20211120151914318"><figcaption aria-hidden="true">image-20211120151914318</figcaption></figure><p>实体<span class="math inline">\(h\)</span>的<span class="math inline">\(l\)</span>层ego-network内传播的信息定义如下：</p><figure><img src="\images\typora-user-images\image-20211120152036033.png" alt="image-20211120152036033"><figcaption aria-hidden="true">image-20211120152036033</figcaption></figure><p>其中，<span class="math inline">\(\boldsymbol{e}_t^{(l-1)}\)</span>为从先前的信息传播步骤生成的实体t的表示，存储来自其<span class="math inline">\((l-1)\)</span>跳邻居的信息。高阶嵌入传播将基于属性的协作信号无缝地注入到表示学习过程中。</p><h5 id="模型预测">3.3 模型预测</h5><p>在执行了<span class="math inline">\(L\)</span>层之后，我们获得了用户节点<span class="math inline">\(u\)</span>的多个表示，<span class="math inline">\(u=\{\boldsymbol{e}^{(1)}_h...\boldsymbol{e}^{(L)}_h\}\)</span>.类似于项目节点<span class="math inline">\(i\)</span>，<span class="math inline">\(i=\{\boldsymbol{e}^{(1)}_i...\boldsymbol{e}^{(L)}_i\}\)</span>.</p><p>如图1所示，第<span class="math inline">\(l\)</span>层的输出是<span class="math inline">\(u\)</span>或者<span class="math inline">\(i\)</span>在树结构深度<span class="math inline">\(l\)</span>的消息聚合，因此不同层的输出强调不同顺序的连接信息。因此，我们采用层聚合机制将每一步的表示连接到一个向量中。</p><figure><img src="\images\typora-user-images\image-20211120154339737.png" alt="image-20211120154339737"><figcaption aria-hidden="true">image-20211120154339737</figcaption></figure><p>通过这样做，我们不仅可以通过执行嵌入传播操作来丰富初始嵌入，还可以通过调整<span class="math inline">\(L\)</span>来控制传播的强度。最后，我们通过对用户表示和项目表示进行内积，预测他们的匹配分数：</p><figure><img src="\images\typora-user-images\image-20211120155730202.png" alt="image-20211120155730202"><figcaption aria-hidden="true">image-20211120155730202</figcaption></figure><h5 id="优化">3.4 优化</h5><p>BPR损失，它假设观察到的交互（表示更多的用户偏好）应该比未观察到的交互分配更高的预测值得分：</p><figure><img src="\images\typora-user-images\image-20211120155855865.png" alt="image-20211120155855865"><figcaption aria-hidden="true">image-20211120155855865</figcaption></figure><p>训练集：<span class="math inline">\(\mathcal{O}=\{(u,i,j)|(u,i)\in\mathcal{R}^{+},(u,j)\in\mathcal{R^{-}}\}\)</span>.其中，<span class="math inline">\(\mathcal{R}^{+}\)</span>表示在用户<span class="math inline">\(u\)</span>和项目<span class="math inline">\(j\)</span>之间观测到的交互集。</p><p>最后，我们有一个目标函数，如下所示：</p><figure><img src="\images\typora-user-images\image-20211120160225238.png" alt="image-20211120160225238"><figcaption aria-hidden="true">image-20211120160225238</figcaption></figure><h6 id="训练">3.4.1 训练</h6><p>我们交替优化<span class="math inline">\(\mathcal{L}_{KG}\)</span>和<span class="math inline">\(\mathcal{L}_{CF}\)</span>，其中采用mini-batchAdam优化嵌入损失和预测损失。特别地，对于一批随机抽样的节点<span class="math inline">\((h,r,t,t^{'})\)</span>，我们更新所有节点的嵌入；此后，我们随机抽取一批<span class="math inline">\((u,i,j)\)</span>样本，在传播第<span class="math inline">\(L\)</span>步后检索它们的表示，然后使用预测损失的梯度更新模型参数。</p><h6 id="时间复杂度分析">3.4.2 时间复杂度分析</h6><p>KGAT的总体训练复杂性为<span class="math inline">\(O(|\mathcal{G}_2|d^2+\sum_{l=1}^{L}|\mathcal{G}|d_ld_{l-1}+|\mathcal{G}|d_l)\)</span>.</p><h5 id="experiments">4 Experiments</h5><h5 id="conclusion-and-future-work">5 Conclusion and Future Work</h5><p>在这项工作中，我们探索了CKG中语义关系的高阶连通性，以实现知识感知推荐。我们设计了一个新的框架KGAT，它以端到端的方式显式地模拟CKG中的高阶连接性。其核心是关注嵌入传播层，该层自适应地传播来自节点邻居的嵌入，以更新节点的表示。在三个真实数据集上的大量实验证明了KGAT的合理性和有效性。</p><p>这项工作探索了图形神经网络在推荐中的潜力，并代表了利用信息传播机制开发结构知识的初步尝试。除了知识图之外，许多其他结构信息确实存在于现实世界场景中，例如社交网络和项目上下文。例如，通过将社交网络与CKG相结合，我们可以研究社会影响如何影响推荐。另一个令人兴奋的方向是信息传播和决策过程的集成，这为解释性推荐的研究开辟了可能性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Relational Learning with Gated and Attentive Neighbor Aggregator for Few-Shot Knowledge Graph Completion</title>
      <link href="/2023/03/17/relational-learning-with-gated-and-attentive-neighbor-aggregator-for-few-shot-knowledge-graph-completion/"/>
      <url>/2023/03/17/relational-learning-with-gated-and-attentive-neighbor-aggregator-for-few-shot-knowledge-graph-completion/</url>
      
        <content type="html"><![CDATA[<center><strong>Relational Learning with Gated and Attentive Neighbor Aggregatorfor Few-Shot Knowledge Graph Completion</strong></center><center>基于门控和注意邻居聚合器的关系学习</center><hr><h4 id="abstract">Abstract</h4><p>我们提出了几种基于全局-局部(global-local)框架的关系学习方法来解决上述问题。<br>在全局阶段，构建了一个新的门控式、关注式邻居聚合器，用于准确地集成少数镜头关系的邻居的语义，这有助于过滤噪声邻居，即使KG包含非常稀疏的邻居。<br>在局部阶段，设计了一种基于元学习的TransH(MTransH)方法来建模复杂关系，并以小样本学习方式训练我们的模型。</p><h4 id="introduction">1 Introduction</h4><p>我们提出利用有价值的邻居信息来表示每个小样本关系，然后根据KGE模型使用表示来推断缺失的事实。这样的框架更容易优化，并且可以使用更多上下文语义来更好地处理复杂关系。然而，仍然存在一些挑战：</p><p>(1)稀疏邻域：稀疏邻域意味着只有少数关系实体对(邻居)存在于小样本关系的头部或尾部实体的邻域中。当任何一个邻居不能表示小样本关系时，它会引入噪声信息。</p><p>(2)复杂关系：复杂的关系有不同的类型1-N, N-1,和N-N。训练这些模型需要大量的实例，这些实例对于小样本的情况是不可用的。因此，这些KGE模型很难在我们的环境中直接使用。尽管TransH、TransR和其他一些具有更高复杂性的KGE方法可以处理复杂的关系，但这些模型中的参数是通过大量实例学习的。因此，这些KGE模型很难在小样本场景中立即使用。</p><p>为了应对上述挑战，我们提出了一种基于门控和关注邻居聚合器的小样本关系学习模型，以及FKGC的MTransH。具体来说，我们通过门控和关注邻居聚合器对一个小样本关系邻域进行编码，以获得小样本关系的一般表示。为了消除由于稀疏邻域而产生的噪声邻域信息，将与小样本关系及其邻域相关联的头部和尾部实体组合起来。门控机制可以确定邻域表示的重要性，以表示一些小样本关系。我们还将元学习引入到KGE模型TransH(MTransH)中，通过学习小样本场景中特定于关系的超平面参数，有利于对复杂关系进行建模。</p><p>贡献：</p><p>1.第一个提出门控和关注邻居聚合器的人，该聚合器通过门控机制将来自头部和尾部实体以及实体邻域的信息结合起来，以捕获小样本关系中最有价值的上下文语义。</p><p>2.第一个将MAML与TransH结合起来进行FKGC，并且自然地同时考虑了1-N、N-1和N-N的复杂关系。</p><p>3.实验结果表明，我们提出的模型优于其他KGC方法，包括现有的FKGC模型。</p><p>==源码==：https://github.com/ngl567/GANA-FewShotKGC</p><h4 id="related-work">2 Related Work</h4><h5 id="传统知识图谱补全">2.1 传统知识图谱补全</h5><h5 id="小样本知识图谱补全">2.2 小样本知识图谱补全</h5><p>(1)基于度量的模型：GMatching、FSRL、</p><p>(2)基于元学习的模型：MetaR、Meta-KGR</p><p>(3)基于双过程理论模型：CogKR</p><h4 id="problem-formulation">3 Problem Formulation</h4><ol type="1"><li>背景知识图谱<img src="\images\typora-user-images\image-20211109201557708.png" alt="image-20211109201557708">：一组与所有高频关系相关的三元组。</li><li>小样本关系r的邻居：<img src="\images\typora-user-images\image-20211109201741598.png" alt="image-20211109201741598">，<img src="\images\typora-user-images\image-20211109202001767.png" alt="image-20211109202001767">是围绕实体h和t的一跳邻居集，可以从背景知识图生成。<img src="\images\typora-user-images\image-20211109202134510.png" alt="image-20211109202134510">或<img src="\images\typora-user-images\image-20211109202145614.png" alt="image-20211109202145614">中的邻居由传出关系和与实体h或t相关联的尾部实体组成。特别是，我们将邻域中所有朝向h和t的传入关系反转为传出关系。</li></ol><h4 id="methodology">4 Methodology</h4><p>目标：</p><p>(1)通过利用邻居信息和消除噪声邻居来表示小样本关系(挑战1)</p><p>(2)在小样本场景中推断复杂关系也应该得到解决(挑战2)</p><figure><img src="\images\typora-user-images\image-20211109202744607.png" alt="image-20211109202744607"><figcaption aria-hidden="true">image-20211109202744607</figcaption></figure><p>the global stage：小样本关系r对应的三元组<img src="\images\typora-user-images\image-20211109202934847.png" alt="image-20211109202934847">，所设计的门控注意邻域聚合器首先将头部和尾部实体与其邻域进行编码，以生成少数镜头关系r的邻域表示<img src="\images\typora-user-images\image-20211109203048565.png" alt="image-20211109203048565">.<br>受RNN聚合节点嵌入成功的启发，所有的来自support集的邻居表示<img src="\images\typora-user-images\image-20211109203229124.png" alt="image-20211109203229124">通过注意的(attentive)Bi-LSTM进行集成，学习小样本关系的一般表示。</p><p>在the globalstage阶段，我们能够从背景知识图谱中学习关系表示的良好初始化。为了进一步使表示适应support集，并导出与support集中提供的演示一致的表示，我们进一步使用基于MAML的方法MTransH在本地阶段调整表示。<br>即对应于关系r的超平面参数表示为<img src="\images\typora-user-images\image-20211109203745984.png" alt="image-20211109203745984">，投影实体嵌入表示为<img src="\images\typora-user-images\image-20211109203801523.png" alt="image-20211109203801523">.更新的关系表示<img src="\images\typora-user-images\image-20211109204009754.png" alt="image-20211109204009754">和超平面参数<img src="\images\typora-user-images\image-20211109204020116.png" alt="image-20211109204020116">可通过MTransH获得。<br>最后，通过将更新后的关系表示和超平面参数从support集转移到query集来学习所有参数。</p><h5 id="global-stage一般表示">4.1 Global Stage：一般表示</h5><h6 id="门控和注意邻居聚合器">4.1.1 门控和注意邻居聚合器</h6><p>受图注意力网络(GAT)的启发，它可以捕获邻居的不同影响以改进实体嵌入，我们的目标是使用基于GAT的邻居编码器来合并关系的邻居信息来表示它。然而，编码一个稀疏的邻域甚至可能在表示几个样本关系的过程中引入噪声。因此，我们开发了一种新型的门控式、注意力集中的邻居聚集器，用于自动捕获最有价值的邻居信息，以学习小样本关系表示，并过滤邻居的噪声信息。</p><p>实体e的一个邻居<img src="\images\typora-user-images\image-20211109214629877.png" alt="image-20211109214629877">编码如下：</p><figure><img src="\images\typora-user-images\image-20211109214659556.png" alt="image-20211109214659556"><figcaption aria-hidden="true">image-20211109214659556</figcaption></figure><p><img src="\images\typora-user-images\image-20211109214839452.png" alt="image-20211109214839452">和<img src="\images\typora-user-images\image-20211109214848813.png" alt="image-20211109214848813">是关系及其链接尾部实体在实体e邻居的嵌入，<img src="\images\typora-user-images\image-20211109214913277.png" alt="image-20211109214913277">是邻居<img src="\images\typora-user-images\image-20211109214928652.png" alt="image-20211109214928652">的表示<br></p><p><img src="\images\typora-user-images\image-20211109214949500.png" alt="image-20211109214949500">是一个线性变化矩阵，<img src="\images\typora-user-images\image-20211109215009863.png" alt="image-20211109215009863">表示权重矩阵，<img src="\images\typora-user-images\image-20211109215129340.png" alt="image-20211109215129340">表示第i个邻居的绝对注意力值。</p><p>为了获取每个邻居对应的注意力值，对<img src="\images\typora-user-images\image-20211109215129340.png" alt="image-20211109215129340">应用<em>softmax</em>函数：</p><figure><img src="\images\typora-user-images\image-20211109215302780.png" alt="image-20211109215302780"><figcaption aria-hidden="true">image-20211109215302780</figcaption></figure><p>为了消除由于稀疏邻域而产生的噪声邻域，有必要使用门值g来自动确定激活实体e的邻域的程度，以表示小样本关系</p><figure><img src="\images\typora-user-images\image-20211109215600556.png" alt="image-20211109215600556"><figcaption aria-hidden="true">image-20211109215600556</figcaption></figure><p>g通过权重向量<img src="\images\typora-user-images\image-20211109215654411.png" alt="image-20211109215654411">和标量偏差参数<img src="\images\typora-user-images\image-20211109215809395.png" alt="image-20211109215809395">参数化的线性变换获得。</p><p>通过门控机制，通过将头部或尾部实体e的邻域表示与其实体嵌入相结合，获得小样本关系r的半邻域表示：</p><figure><img src="\images\typora-user-images\image-20211109220020147.png" alt="image-20211109220020147"><figcaption aria-hidden="true">image-20211109220020147</figcaption></figure><p><img src="\images\typora-user-images\image-20211109220041827.png" alt="image-20211109220041827">表示小样本关系的邻域表示的一半，<img src="\images\typora-user-images\image-20211109220112931.png" alt="image-20211109220112931">表示权重矩阵，<img src="\images\typora-user-images\image-20211109220138692.png" alt="image-20211109220138692">表示偏差的向量参数.</p><p>两个邻域表示<img src="\images\typora-user-images\image-20211109220756338.png" alt="image-20211109220756338">和<img src="\images\typora-user-images\image-20211109220809138.png" alt="image-20211109220809138">对应于头部实体h和尾部实体t，通过↑式计算得来，然后将他们连接在一起：</p><figure><img src="\images\typora-user-images\image-20211109220908586.png" alt="image-20211109220908586"><figcaption aria-hidden="true">image-20211109220908586</figcaption></figure><p><img src="\images\typora-user-images\image-20211109221513762.png" alt="image-20211109221513762">是support集三元组中小样本关系的邻域表示。</p><h6 id="生成小样本关系表示">4.1.2 生成小样本关系表示</h6><p>一种专注的Bi-LSTM编码器，用于集成support集中少数镜头关系的多个邻域表示，该编码器可用于学习少数镜头关系的一般表示。具体来说，邻域表示<img src="\images\typora-user-images\image-20211110210903090.png" alt="image-20211110210903090">被依次送入一个注意的Bi-LSTM中(K为support集的大小)。注意的Bi-LSTM在正向和反向的隐藏状态通过以下公式计算：</p><figure><img src="\images\typora-user-images\image-20211110211053297.png" alt="image-20211110211053297"><figcaption aria-hidden="true">image-20211110211053297</figcaption></figure><p>在第i步，正向的和反向的最终隐藏状态被作为一个整体向量<img src="\images\typora-user-images\image-20211110211422942.png" alt="image-20211110211422942">连接，被编码成<img src="\images\typora-user-images\image-20211110211443568.png" alt="image-20211110211443568">：</p><figure><img src="\images\typora-user-images\image-20211110211452832.png" alt="image-20211110211452832"><figcaption aria-hidden="true">image-20211110211452832</figcaption></figure><p>然后，通过注意力机制计算每个最终隐藏状态的权重：</p><figure><img src="\images\typora-user-images\image-20211110211523375.png" alt="image-20211110211523375"><figcaption aria-hidden="true">image-20211110211523375</figcaption></figure><p><img src="\images\typora-user-images\image-20211110211601576.png" alt="image-20211110211601576">表示表示第i个邻域表示的权重，用于学习小样本关系的一般表示。</p><p>Bi-LSTM的最终隐藏状态按权重求和：</p><figure><img src="\images\typora-user-images\image-20211110211813648.png" alt="image-20211110211813648"><figcaption aria-hidden="true">image-20211110211813648</figcaption></figure><p><img src="\images\typora-user-images\image-20211110211843744.png" alt="image-20211110211843744">通过集成支持集中K个三元组的所有邻域表示，表示小样本关系r的一般表示。</p><h5 id="local-stagemtransh">4.2 Local Stage:MTransH</h5><p>我们的目标是在考虑1-N、N-1和N-N的复杂关系的同时，在局部阶段更新小样本关系的表示。受典型的KGE模型TransH的启发，该模型可以模拟复杂的关系，分数函数涉及三元组<img src="\images\typora-user-images\image-20211110212111789.png" alt="image-20211110212111789">设计为：</p><figure><img src="\images\typora-user-images\image-20211110212123511.png" alt="image-20211110212123511"><figcaption aria-hidden="true">image-20211110212123511</figcaption></figure><p><img src="\images\typora-user-images\image-20211110212154623.png" alt="image-20211110212154623">是在预训练时学习的头部和尾部嵌入，<img src="\images\typora-user-images\image-20211110212229935.png" alt="image-20211110212229935">是关系r超平面的法向量，<img src="\images\typora-user-images\image-20211110212245582.png" alt="image-20211110212245582">是小样本关系的一般表示.损失函数：</p><figure><img src="\images\typora-user-images\image-20211110212325822.png" alt="image-20211110212325822"><figcaption aria-hidden="true">image-20211110212325822</figcaption></figure><p><img src="\images\typora-user-images\image-20211110212342422.png" alt="image-20211110212342422">为负样本集合<img src="\images\typora-user-images\image-20211110212359990.png" alt="image-20211110212359990">中的三元组(由与三元组<img src="\images\typora-user-images\image-20211110212438606.png" alt="image-20211110212438606">采样相对应的负采样生成)</p><p>此外，我们还计算了关系表示<img src="\images\typora-user-images\image-20211110212245582.png" alt="image-20211110212245582">的梯度：</p><figure><img src="\images\typora-user-images\image-20211110212556739.png" alt="image-20211110212556739"><figcaption aria-hidden="true">image-20211110212556739</figcaption></figure><p>然后，关系表示可以在随机梯度下降后更新，如下所示：</p><figure><img src="\images\typora-user-images\image-20211110212610702.png" alt="image-20211110212610702"><figcaption aria-hidden="true">image-20211110212610702</figcaption></figure><p><img src="\images\typora-user-images\image-20211110212633302.png" alt="image-20211110212633302">表示更新关系表示时的学习速率。</p><p>我们利用模型不可知元学习(MAML)方法通过初始化良好的超平面参数<img src="\images\typora-user-images\image-20211110212800638.png" alt="image-20211110212800638">来学习对于每个小样本关系的超平面参数<img src="\images\typora-user-images\image-20211110212711782.png" alt="image-20211110212711782">.</p><p>对于在任务<img src="\images\typora-user-images\image-20211110212942524.png" alt="image-20211110212942524">中的超平面参数<img src="\images\typora-user-images\image-20211110212711782.png" alt="image-20211110212711782">，在适应新任务时，超平面参数将变为<img src="\images\typora-user-images\image-20211110213019630.png" alt="image-20211110213019630">.在MAML之后，更新的参数<img src="\images\typora-user-images\image-20211110213019630.png" alt="image-20211110213019630">通过当前任务<img src="\images\typora-user-images\image-20211110213102975.png" alt="image-20211110213102975">的支持集上的梯度下降更新计算。例如，参数<img src="\images\typora-user-images\image-20211110212711782.png" alt="image-20211110212711782">可以通过单个梯度步骤更新，学习率<img src="\images\typora-user-images\image-20211110213639585.png" alt="image-20211110213639585">如下所示：</p><figure><img src="\images\typora-user-images\image-20211110213651366.png" alt="image-20211110213651366"><figcaption aria-hidden="true">image-20211110213651366</figcaption></figure><p>当我们在当前任务上获得更新的关系表示和超平面参数时，我们将它们转移到查询集<img src="\images\typora-user-images\image-20211110213741157.png" alt="image-20211110213741157">中.按照支持集上相同的方法，查询集上的分数和损失可通过以下方式获得：</p><figure><img src="\images\typora-user-images\image-20211110213812782.png" alt="image-20211110213812782"><figcaption aria-hidden="true">image-20211110213812782</figcaption></figure><p><img src="\images\typora-user-images\image-20211110213831662.png" alt="image-20211110213831662">为查询集<img src="\images\typora-user-images\image-20211110213849565.png" alt="image-20211110213849565">中的三元组.<img src="\images\typora-user-images\image-20211110213903693.png" alt="image-20211110213903693">为训练整个模型的优化目标.<img src="\images\typora-user-images\image-20211110213939013.png" alt="image-20211110213939013">为负样本集合中的负三元组.</p><p>此外，我们还可以计算在查询集上任务<img src="\images\typora-user-images\image-20211110214041018.png" alt="image-20211110214041018">更新后的超平面参数<img src="\images\typora-user-images\image-20211110213019630.png" alt="image-20211110213019630">，同时，初始化良好的超平面参数<img src="\images\typora-user-images\image-20211110212800638.png" alt="image-20211110212800638">也可以被如下计算：</p><figure><img src="\images\typora-user-images\image-20211110214116917.png" alt="image-20211110214116917"><figcaption aria-hidden="true">image-20211110214116917</figcaption></figure><p>模型的训练过程：</p><figure><img src="\images\typora-user-images\image-20211110214132030.png" alt="image-20211110214132030"><figcaption aria-hidden="true">image-20211110214132030</figcaption></figure><p>==未来工作==：</p><p>(1)我们将考虑更多的外部知识，如关系和实体的文本描述，以增强关系和实体的表示。</p><p>(2)在FKGC任务中，将同时考虑小样本实体和关系</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Generative Adversarial Zero-Shot Relational Learning for Knowledge Graphs</title>
      <link href="/2023/03/17/generative-adversarial-zero-shot-relational-learning-for-knowledge-graphs/"/>
      <url>/2023/03/17/generative-adversarial-zero-shot-relational-learning-for-knowledge-graphs/</url>
      
        <content type="html"><![CDATA[<center><strong>Generative Adversarial Zero-Shot Relational Learning forKnowledge Graphs</strong></center><center>知识图谱的生成性对抗零样本关系学习</center><hr><h4 id="abstract">Abstract</h4><p>在本文中，我们考虑一个新方法，零样本学习。对于新添加的关系，我们试图从它们的文本描述中学习它们的语义特征，从而==在没有看到示例的情况下==识别出看不见的关系的事实。为此，我们利用生成性对抗网络(GAN)建立文本和知识图谱之间的联系：<br>生成器(generator)仅通过嘈杂的文本描述学习生成合理的关系嵌入。在此设置下，零样本学习自然转化为传统的有监督分类任务。从经验上看，我们的方法是模型无关的，可以潜在地应用于任何版本的KG嵌入。</p><h4 id="introduction">Introduction</h4><p>新类的语义特征可以==通过它们的文本描述来反映，而不是从实例中学习==。此外，文本描述包含丰富而明确的信息，可以从字典、百科全书文章或各种在线资源中轻松访问，这对于大规模识别任务至关重要。</p><p>==零样本学习的目标==：在训练阶段看不到任何实例的情况下识别出新的class(unseenclass).</p><p>==通过文本描述来提取语义特征，而不是从实例中学习。==</p><p>本文提出了一种知识图谱的零样本关系学习方法。我们将零样本学习转化为==知识转移(knowledgetransfer)==问题。我们关注如何==仅从文本描述中为看不见的关系生成合理的关系嵌入==。一旦确定，该系统就能够为任意关系生成关系嵌入，而无需微调。通过这些关系嵌入，可以简单地通过余弦相似性识别不可见关系的事实。</p><p>==知识转移(knowledgetransfer)==：将从一个模型学到的知识压缩到另一个模型中。</p><p>为了满足这些需求，第一个挑战是如何==建立从文本语义空间到知识图谱语义空间的有效知识转移过程==。我们利用条件GANs从文本描述生成貌似有理的(plausible)关系嵌入，并为不可见的关系提供类间多样性。<br>第二个挑战是==文本描述的噪声抑制==。人类的语言表达通常包括不相关的词(如虚词(functionwords))来识别目标关系。因此，不加区分的单词权重将导致较差的性能。针对这个问题，我们采用了==基于单词嵌入的简单词袋(bag-of-words)模型==；同时，我们计算TF-IDF特征，以降低相关性较低的单词对零样本学习的重要性。</p><figure><img src="\images\typora-user-images\image-20211107214004298.png" alt="image-20211107214004298"><figcaption aria-hidden="true">image-20211107214004298</figcaption></figure><p>贡献：</p><ol type="1"><li>首先考虑零样本学习的知识图谱补全，并提出一个生成的对抗框架，仅仅使用文本描述为不可见的关系产生合理的关系嵌入；</li><li>我们的方法是模型无关的(model-agnostic)，并且可以潜在地应用于KG嵌入的任何版本；</li><li>我们给出了两个新构造的zero-shot知识图谱补全数据集，表明我们的方法比各种基于嵌入的方法具有更好的性能.</li></ol><h4 id="related-work">Related Work</h4><ol type="1"><li>==KBGAN==：采用对抗式训练，通过选择高质量的负样本来学习更好的鉴别器，但它仍然关注现有关系的链接预测。</li><li>==零样本学习(zero-shotlearning，ZSL)==的核心是实现可见类和不可见类之间的==知识共享(knowledgesharing)和归纳迁移(inductivetransfer)==，常见的解决方案是找到一个中间语义表示。</li><li>ZSL框架：利用条件GANs模型实现图像分类任务的零样本学习。目前，ZSL的大部分研究工作都来自计算机视觉领域。在自然语言处理领域，Artetxe和Schwenk使用一个句子编码器，仅通过在一种语言上训练目标模型来完成多语言任务。</li></ol><h4 id="background">Background</h4><h5 id="零样本学习设置">零样本学习设置</h5><p>seen relation set：<img src="\images\typora-user-images\image-20211107221408935.png" alt="image-20211107221408935"><br>unseen relation set：<img src="\images\typora-user-images\image-20211107221434169.png" alt="image-20211107221434169"><br><img src="\images\typora-user-images\image-20211107221459265.png" alt="image-20211107221459265"></p><p>背景知识图谱<img src="\images\typora-user-images\image-20211108123441390.png" alt="image-20211108123441390">，收集了大量的三元组，在零样本训练阶段可用。<br>利用这个知识图谱，为可见关系建立了训练集<img src="\images\typora-user-images\image-20211108123545501.png" alt="image-20211108123545501">，<img src="\images\typora-user-images\image-20211108123633566.png" alt="image-20211108123633566"><br>在测试过程中，所提出的模型用于预测不可见关系的关系事实，<img src="\images\typora-user-images\image-20211108123710613.png" alt="image-20211108123710613"></p><p>对于文本描述，我们自动为<img src="\images\typora-user-images\image-20211108123814725.png" alt="image-20211108123814725">中的每个关系提取一个在线文本描述T<br>考虑到可行性，我们只考虑一组封闭的实体；更具体地说，出现在测试三元组中的每个实体仍然在实体集合E中.<br>测试集：<img src="\images\typora-user-images\image-20211108124037741.png" alt="image-20211108124037741"><img src="\images\typora-user-images\image-20211108123947038.png" alt="image-20211108123947038">.</p><p>与训练过程的要求相同，需要通过将<img src="\images\typora-user-images\image-20211108124155916.png" alt="image-20211108124155916">与候选尾实体<img src="\images\typora-user-images\image-20211108124225053.png" alt="image-20211108124225053">进行排序来正确识别ground-truth尾实体<img src="\images\typora-user-images\image-20211108124155916.png" alt="image-20211108124155916">.</p><p>通过删除验证关系的所有训练实例，我们省略了<img src="\images\typora-user-images\image-20211108124441636.png" alt="image-20211108124441636">的子集作为验证集<img src="\images\typora-user-images\image-20211108124454702.png" alt="image-20211108124454702">.</p><h5 id="生成对抗模型">生成对抗模型</h5><p>生成器(generator)的目的是从随机变量中合成合理的伪数据；<br>鉴别器(discriminator)的目的是将它们与真实数据区分开来。</p><h4 id="methodology">Methodology</h4><figure><img src="\images\typora-user-images\image-20211108141723530.png" alt="image-20211108141723530"><figcaption aria-hidden="true">image-20211108141723530</figcaption></figure><p>核心：设计一个条件生成模型，从原始文本描述中学习合格的关系嵌入。</p><p>生成器(generator)：以文本表示为输入，生成合理的关系嵌入，反映知识图谱特征空间中相应的关系语义信息。在此基础上，将不可见关系的预测转化为一个简单的有监督分类任务。</p><p>鉴别器(discriminator)：试图将假数据从真实数据分布中分离出来，并识别关系类型。</p><p>对于真实数据的表示，我们利用==特征编码器==从KG嵌入生成合理的真实数据分布。特征编码器从训练集中提前训练，并在对抗性训练过程中固定。</p><h5 id="特征编码器">特征编码器</h5><p>在训练期间，传统的KG嵌入完全符合相关事实；然而，最优零样本特征表示应该为可见和不可见的关系事实提供簇结构(cluster-structure)分布。因此，我们设计了一个特征编码器，从预训练的KG嵌入和一跳结构中学习更好的数据分布。</p><h6 id="网络体系结构">网络体系结构</h6><figure><img src="\images\typora-user-images\image-20211108142339418.png" alt="image-20211108142339418"><figcaption aria-hidden="true">image-20211108142339418</figcaption></figure><p>特征编码器由两个子编码器组成，==相邻编码器==和==实体编码器==。</p><p>对于每个实体e，我们只考虑其一跳邻居<img src="\images\typora-user-images\image-20211108142252023.png" alt="image-20211108142252023">.因此，我们采用相邻编码器来生成结构表示。<br>给出了一个维数为d的KG嵌入矩阵，我们首先利用嵌入层查找相应的邻居实体<img src="\images\typora-user-images\image-20211108142442713.png" alt="image-20211108142442713">和关系嵌入<img src="\images\typora-user-images\image-20211108142517502.png" alt="image-20211108142517502">.然后，计算实体e的基于结构的表示<img src="\images\typora-user-images\image-20211108143109336.png" alt="image-20211108143109336">:</p><figure><img src="\images\typora-user-images\image-20211108143143856.png" alt="image-20211108143143856"><figcaption aria-hidden="true">image-20211108143143856</figcaption></figure><p>考虑到可伸缩性，我们设置了邻居数量的上限。</p><p>此外，我们还使用一个简单的前馈(feed-forward)层作为实体编码器，从实体对<img src="\images\typora-user-images\image-20211108143429061.png" alt="image-20211108143429061">本身提取信息.</p><figure><img src="\images\typora-user-images\image-20211108143443960.png" alt="image-20211108143443960"><figcaption aria-hidden="true">image-20211108143443960</figcaption></figure><p>关系事实表示形式为相邻嵌入<img src="\images\typora-user-images\image-20211108143557403.png" alt="image-20211108143557403">和实体对嵌入<img src="\images\typora-user-images\image-20211108143542336.png" alt="image-20211108143542336">的连结(concatenation)：</p><figure><img src="\images\typora-user-images\image-20211108143642142.png" alt="image-20211108143642142"><figcaption aria-hidden="true">image-20211108143642142</figcaption></figure><p>可学习参数：<img src="\images\typora-user-images\image-20211108143702424.png" alt="image-20211108143702424">.</p><h6 id="预训练策略">预训练策略</h6><p>核心：学习反映较高类内的(intra-class)相似性和相对较低类间的(inter-class)相似性的簇结构数据分布。</p><p>传统的基于交叉熵损失的监督方法给类间带来了太多的惩罚，对于不可见的类是不可行的。因此，我们通过边缘排名损失(marginranking loss)采用有效的匹配方式.</p><p>对于每个关系<img src="\images\typora-user-images\image-20211108144434444.png" alt="image-20211108144434444">，在一个训练步骤，我们首先随机从训练集抽取k个reference三元组<img src="\images\typora-user-images\image-20211108144652206.png" alt="image-20211108144652206">，从其余训练集中抽取一批正三元组<img src="\images\typora-user-images\image-20211108144721487.png" alt="image-20211108144721487">，以及一批负三元组<img src="\images\typora-user-images\image-20211108144737225.png" alt="image-20211108144737225">.</p><p>然后使用特征编码器生成reference嵌入<img src="\images\typora-user-images\image-20211108144934311.png" alt="image-20211108144934311">，并分别以<img src="\images\typora-user-images\image-20211108144947680.png" alt="image-20211108144947680">和<img src="\images\typora-user-images\image-20211108145000467.png" alt="image-20211108145000467">作为<img src="\images\typora-user-images\image-20211108145022502.png" alt="image-20211108145022502">和<img src="\images\typora-user-images\image-20211108145042894.png" alt="image-20211108145042894">计算其余弦相似度。因此，边缘排名损失可描述如下：</p><figure><img src="\images\typora-user-images\image-20211108145109238.png" alt="image-20211108145109238"><figcaption aria-hidden="true">image-20211108145109238</figcaption></figure><p>要学习的参数集：<img src="\images\typora-user-images\image-20211108145132462.png" alt="image-20211108145132462">.</p><h5 id="生成对抗模型-1">生成对抗模型</h5><h6 id="生成器">生成器</h6><p>生成器将从文本描述生成貌似可信的关系嵌入。<br>首先，对于文本表示，我们简单地采用词袋(bag-of-words)方法，即使用预先训练的单词嵌入对单词进行编码。为了抑制噪声信息，我们首先去除停止词和标点符号，然后通过TF-IDF特征评估其余单词的重要性。因此，文本嵌入<img src="\images\typora-user-images\image-20211108150206536.png" alt="image-20211108150206536">是由TF-IDF值加权的单词嵌入的向量和。为了满足GANs的要求，我们将每个文本嵌入与从高斯分布<img src="\images\typora-user-images\image-20211108150414880.png" alt="image-20211108150414880">中采样的随机向量<img src="\images\typora-user-images\image-20211108150359126.png" alt="image-20211108150359126">连接起来。</p><p>知识转移过程由两个全连接层和一个层规范化操作完成。因此，关系嵌入<img src="\images\typora-user-images\image-20211108150737942.png" alt="image-20211108150737942">由生成器<img src="\images\typora-user-images\image-20211108150749209.png" alt="image-20211108150749209">与参数θ生成。为了避免模式崩溃和提高多样性，我们采用了Wasserstein损失和额外的分类损失(边缘排名损失).</p><p>簇中心<img src="\images\typora-user-images\image-20211108151141788.png" alt="image-20211108151141788">被视为真实关系表示，其中<img src="\images\typora-user-images\image-20211108151207613.png" alt="image-20211108151207613">是关系r的事实数量。因此，从<img src="\images\typora-user-images\image-20211108151236539.png" alt="image-20211108151236539">和<img src="\images\typora-user-images\image-20211108151251869.png" alt="image-20211108151251869">计算出正分数；负面分数由<img src="\images\typora-user-images\image-20211108151236539.png" alt="image-20211108151236539">和负面事实表示计算得出，其中负面事实由污染尾部实体生成。</p><p>此外，视觉轴正则化(visual pivot regularization)<img src="\images\typora-user-images\image-20211108151351985.png" alt="image-20211108151351985">也用于提供足够的类间区分:</p><figure><img src="\images\typora-user-images\image-20211108151526010.png" alt="image-20211108151526010"><figcaption aria-hidden="true">image-20211108151526010</figcaption></figure><h6 id="鉴别器">鉴别器</h6><p>鉴别器试图==区分输入==是真实数据<img src="\images\typora-user-images\image-20211108151634394.png" alt="image-20211108151634394">还是虚假数据<img src="\images\typora-user-images\image-20211108151642411.png" alt="image-20211108151642411">.此外，还需要正确==识别==它们对应的==关系类型==。输入特性首先通过一个全连接层(LeakyReLU)进行转换。接下来，有两个网络分支。第一个分支是一个FC层，它作为一个二元分类器来分离真实数据和虚假数据，我们还利用了Wasserstein损失。另一个分支是分类性能。为了稳定训练行为和消除模式崩溃，我们还采用了梯度惩罚(gradientpenalty)<img src="\images\typora-user-images\image-20211108151912955.png" alt="image-20211108151912955">来强化Lipschitz约束。如果梯度范数偏离其目标范数值1，则会惩罚模型。<br>鉴别器的损失函数公式如下：</p><figure><img src="\images\typora-user-images\image-20211108152040744.png" alt="image-20211108152040744"><figcaption aria-hidden="true">image-20211108152040744</figcaption></figure><h5 id="预测不可见关系">预测不可见关系</h5><p>经过对抗性训练，给定关系文本描述<img src="\images\typora-user-images\image-20211108152346626.png" alt="image-20211108152346626">，生成器可以生成貌似正确的关系嵌入<img src="\images\typora-user-images\image-20211108152417450.png" alt="image-20211108152417450">。对于查询元组<img src="\images\typora-user-images\image-20211108152428675.png" alt="image-20211108152428675">，相似度排序值得分<img src="\images\typora-user-images\image-20211108152445147.png" alt="image-20211108152445147">可以通过<img src="\images\typora-user-images\image-20211108152453684.png" alt="image-20211108152453684">和<img src="\images\typora-user-images\image-20211108152503805.png" alt="image-20211108152503805">之间的余弦相似度来计算。由于z可以无限期采样，我们可以生成任意数量的<img src="\images\typora-user-images\image-20211108152532556.png" alt="image-20211108152532556">个生成的关系嵌入<img src="\images\typora-user-images\image-20211108152607354.png" alt="image-20211108152607354">.<br>为了获得更好的泛化能力，我们使用平均余弦相似度值作为最终排名分数：</p><figure><img src="\images\typora-user-images\image-20211108152635841.png" alt="image-20211108152635841"><figcaption aria-hidden="true">image-20211108152635841</figcaption></figure><figure><img src="\images\typora-user-images\image-20211108152735780.png" alt="image-20211108152735780"><figcaption aria-hidden="true">image-20211108152735780</figcaption></figure><p>未来工作：<br>1.词袋模型存在语义多样性不足的问题，尤其是当关系类型的理解需要在文本描述中考虑词序列信息时。<br>2.零样本设置基于统一的实体集。它可以理解为通过在现有实体节点之间添加看不见的关系边来扩展当前的大规模知识图。必须进一步考虑不可见的实体。</p><p>问题：</p><p>1.零样本学习的设置：通过文本描述提取出关系特征，而不是直接通过实例来进行学习，做文本描述的过程是?(提取上下文语义关系)，他直接提取了关系和实体之间的属性。<br>而我做的是通过邻居编码器提取他周围实体之间的属性了</p><ol start="2" type="1"><li>centroid_matrix：对训练集中的每种关系形成了一个簇(提取关系和头尾实体的特征，然后求平均)，代表每种关系和实体之间的属性(是不是用这个地方就可以代表零样本了)==和词袋模型有关==</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Few-Shot Adaptation of Generative Adversarial Networks</title>
      <link href="/2023/03/17/few-shot-adaptation-of-generative-adversarial-networks/"/>
      <url>/2023/03/17/few-shot-adaptation-of-generative-adversarial-networks/</url>
      
        <content type="html"><![CDATA[<center><strong>Few-Shot Adaptation of Generative Adversarial Networks</strong></center><center>生成性对抗网络的小样本适应</center><hr><h4 id="abstract">Abstract</h4><p>生成性对抗网络在图像合成任务中表现出显著的性能，但通常需要大量的训练样本才能实现高质量的合成。本文提出了一种简单有效的方法，即小样本GAN(FSGAN)，用于在小样本设置(少于100幅图像)中调整GAN。</p><p>Few-shotGAN(<strong>==FSGAN==</strong>)：重新利用组件分析技术，并学习在冻结相应奇异向量的同时调整预训练权重的奇异值。这为自适应提供了一个高度表达的参数空间，同时限制对预训练权重的更改。</p><p>==源码==：https://github.com/e-271/few-shot-gan</p><h4 id="introduction">1 Introduction</h4><p>GAN存在的问题：<br>(1)训练这些模型通常需要目标视觉域中的大型、多样的数据集。虽然在提高训练稳定性方面取得了重大进展，但对抗性优化仍然具有挑战性，因为最佳解决方案位于鞍点(saddlepoints)，而不是损失函数的最小值。<br>(2)基于GAN的模型可能会受到训练数据中罕见模式生成不足的影响，因为它们优化了模型搜索(model-seeking)损失，而不是标准似然最大化的覆盖损失模型(mode-covering)。当训练实例数量不足时，GANs训练的这些困难变得更加严重。<br>(3)在低数据(low-data)区(例如，少于1000个样本)，GANs经常遭受记忆(memorization)或不稳定(instability)，导致缺乏多样性或视觉质量差。</p><p>在本文中，我们提出了一种方法，用于调整预训练的GAN，以从新的目标域生成具有少量训练图像的新颖、高质量的样本图像。为了实现这一点，我们将可训练参数的空间限制为少数高度表达的参数，这些参数调节预先训练的权重空间的正交特征。</p><p>步骤：<br>(1)将奇异值分解(SVD)应用于预训练GAN(生成器+鉴别器)的网络权重。<br>(2)使用<em>fixed</em>的左/右奇异向量，在目标小样本域上使用GAN优化(optimization)来调整奇异值。</p><p>本文证明了在保持自然结构的同时，权重空间中变化的奇异值对应于合成图像的语义有意义的变化。还强调了低样本GAN环境中标准评估实践的问题。</p><h4 id="background">2 Background</h4><h5 id="生成性对抗网络gans">生成性对抗网络(GANs)</h5><p>GANs使用对抗性训练学习随机噪声到图像数据集分布的映射，允许对新图像进行采样。GANs优化了一个竞争目标，其中生成器(generator)<img src="\images\typora-user-images\image-20211106162103128.png" alt="image-20211106162103128">最大化了被训练用于区分真实数据<img src="\images\typora-user-images\image-20211106162138972.png" alt="image-20211106162138972">和虚假数据<img src="\images\typora-user-images\image-20211106162159713.png" alt="image-20211106162159713">的鉴别器<img src="\images\typora-user-images\image-20211106162219945.png" alt="image-20211106162219945">的分类误差。(Eq.1)</p><figure><img src="\images\typora-user-images\image-20211106162345049.png" alt="image-20211106162345049"><figcaption aria-hidden="true">image-20211106162345049</figcaption></figure><h5 id="高采样率的图像合成">高采样率的图像合成</h5><p>样本高效的图像合成方法鼓励在低数据状态下进行多样化和高质量的生成，最常见的是通过预训练或对大型图像数据集进行同步训练。这些方法之间的主要区别在于选择用于自适应的可学习参数。我们的方法使用了一组更小但更具表现力的参数，从而产生了更自然的适应样本。</p><figure><img src="\images\typora-user-images\image-20211106162632497.png" alt="image-20211106162632497"><figcaption aria-hidden="true">image-20211106162632497</figcaption></figure><h5 id="单样本图像再合成re-synthesis">单样本图像再合成(Re-synthesis)</h5><p>将外部知识从预训练的GAN转移到一个新的领域，因此，可以生成更加多样化的样本。</p><h5 id="奇异值分解svd">奇异值分解(SVD)</h5><p>将任何矩阵<img src="\images\typora-user-images\image-20211106163017544.png" alt="image-20211106163017544">转换为酋矩阵<img src="\images\typora-user-images\image-20211106163046551.png" alt="image-20211106163046551">和对角矩阵<img src="\images\typora-user-images\image-20211106163119262.png" alt="image-20211106163119262">，能得到：</p><figure><img src="\images\typora-user-images\image-20211106163145272.png" alt="image-20211106163145272"><figcaption aria-hidden="true">image-20211106163145272</figcaption></figure><p><img src="\images\typora-user-images\image-20211106163225175.png" alt="image-20211106163225175">：分别包含左奇异向量和右奇异向量.<br><img src="\images\typora-user-images\image-20211106163119262.png" alt="image-20211106163119262">：包含沿对角线条目的奇异值.</p><p>SVD可以解释为线性变换的分解：<img src="\images\typora-user-images\image-20211106163513645.png" alt="image-20211106163513645">转换为三个独立的变换：<br>旋转/反射(rotation/reflection)<em>U</em>，尺度转变(rescaling)<em>∑</em>，另一个旋转/反射<em>V</em>.</p><p>转换(transformation)：由最大奇异值<img src="\images\typora-user-images\image-20211106163832844.png" alt="image-20211106163832844">及其对应的归一化奇异向量，表示矩阵<em>M</em>中的最大变化轴。<br>我们的工作在GAN的权重空间上执行SVD，以发现域适应的有意义方向。</p><h4 id="few-shot-gan">3 Few-Shot GAN</h4><h5 id="综述">3.1 综述</h5><p>目标：通过发现一个更有效且受约束的参数空间来调整预训练权重，从而改进小图像域上的GAN微调。具体来说，我们将奇异值分解应用于预训练权重，并揭示了表示权重空间中最大方差正交方向的基。</p><p>改变奇异值对应于输出图像中自然和语义上有意义的变化。改变奇异值可以解释为改变数据中正交变化因子(奇异向量)之间的纠缠，提供一个预训练权重的表达性参数化，我们利用它进行自适应。</p><h5 id="自适应程序">3.2 自适应程序</h5><p>(1)对预训练GAN的生成器和鉴别器执行SVD，并使用标准GAN训练目标将奇异值调整到新的域。<br>对生成器<img src="\images\typora-user-images\image-20211106172414264.png" alt="image-20211106172414264">和鉴别器<img src="\images\typora-user-images\image-20211106172426659.png" alt="image-20211106172426659">得每一层应用SVD<br>生成器层<img src="\images\typora-user-images\image-20211106172414264.png" alt="image-20211106172414264">或鉴别器层<img src="\images\typora-user-images\image-20211106172426659.png" alt="image-20211106172426659">可由以下部分组成：<br><img src="\images\typora-user-images\image-20211106172509169.png" alt="image-20211106172509169">全连接(full-connected)权重<br><img src="\images\typora-user-images\image-20211106172531601.png" alt="image-20211106172531601">卷积滤波器(convolutionalfilter)权重.<br></p><p>(2)描述单层预训练权重<img src="\images\typora-user-images\image-20211106193137079.png" alt="image-20211106193137079">的分解过程:<br>对于全连接层<img src="\images\typora-user-images\image-20211106193208634.png" alt="image-20211106193208634">，可以直接在权重矩阵上应用SVD；<br>对于4D卷积权重<img src="\images\typora-user-images\image-20211106193641121.png" alt="image-20211106193641121">是不可行的，因为SVD仅在2D矩阵上运行。<br>因此，在执行SVD之前，我们通过在空间和输入特征通道上展平来重塑4D张量以获得2D矩阵<img src="\images\typora-user-images\image-20211106194027737.png" alt="image-20211106194027737">.</p><p>在适应过程中，预训练模型中的空间特征关系应该保持不变。我们将奇异值分解应用于每一组平坦(flattened)卷积权值或完全(fully)卷积权值来获得分解：</p><figure><img src="\images\typora-user-images\image-20211106194143686.png" alt="image-20211106194143686"><figcaption aria-hidden="true">image-20211106194143686</figcaption></figure><p>(3)在分解预训练权重之后，我们通过冻结<img src="\images\typora-user-images\image-20211106195430502.png" alt="image-20211106195430502">中预训练的左/右奇异向量来执行域自适应并且使用标准GAN目标优化奇异值<img src="\images\typora-user-images\image-20211106195639182.png" alt="image-20211106195639182">以获得转移权重：</p><figure><img src="\images\typora-user-images\image-20211106195718639.png" alt="image-20211106195718639"><figcaption aria-hidden="true">image-20211106195718639</figcaption></figure><p>我们的GAN域自适应目标是在预训练模型的每一层中找到一组新的奇异值，以便生成的输出与目标域的分布相匹配。</p><p>在前向传播过程中，在应用操作之前，我们使用生成器和鉴别器的每个卷积或完全连接层上的微调奇异值重构权重<img src="\images\typora-user-images\image-20211107123931321.png" alt="image-20211107123931321">.</p><h5 id="训练推理">3.3 训练&amp;推理</h5><p>实验使用StyleGAN2训练框架，该框架使用潜在空间梯度正则化和鉴别器梯度惩罚优化logisticGAN损失(Eq.1)。</p><p>我们将奇异值∑重新训练为固定的时间步数(20K图像或16K 5-shot图像)。我们发现，限制训练时间对于低样本环境中的质量和多样性至关重要，因为长时间的训练通常会导致过度拟合或质量下降（图4&amp;7中的示例）。</p><p>在推理过程中使用了截断技巧，但我们的方法适用于限制性较小的截断参数<img src="\images\typora-user-images\image-20211107124717004.png" alt="image-20211107124717004">，这使得生成的图像更加多样化。</p><h5 id="小样本合成中的评估">3.4 小样本合成中的评估</h5><p>在小样本图像生成中，一个常见的不利结果是过度拟合目标集，因此所有生成的图像看起来都类似于训练数据。评估指标应该反映生成图像的多样性，这样记忆就会受到惩罚。先前小样本GAN适应工作中使用的标准评估实践是使用1K+图像的大型保持(held-out)测试集估计FID，从中对小样本训练集进行采样。</p><p>标准GAN评估通常针对训练集测量FID，但在小样本设置中，这是不可取的，因为生成器可能只是简单地记忆训练集。然而，我们发现，即使在测量FID时，该评估仍然有利于拟合过度或质量较差的模型。</p><p>真假图像之间的FID计算为感知特征<img src="\images\typora-user-images\image-20211107153309136.png" alt="image-20211107153309136">和<img src="\images\typora-user-images\image-20211107153331175.png" alt="image-20211107153331175">之间的Frechet距离：</p><figure><img src="\images\typora-user-images\image-20211107153355609.png" alt="image-20211107153355609"><figcaption aria-hidden="true">image-20211107153355609</figcaption></figure><p>假设特征为高斯分布，<img src="\images\typora-user-images\image-20211107153442259.png" alt="image-20211107153442259">，在小样本设置中，我们的n-shot训练集<img src="\images\typora-user-images\image-20211107153640211.png" alt="image-20211107153640211">从测试集<img src="\images\typora-user-images\image-20211107153650445.png" alt="image-20211107153650445">中取样.</p><p>假设T是随机选择的，其样本均值和方差<img src="\images\typora-user-images\image-20211107153758491.png" alt="image-20211107153758491">是<img src="\images\typora-user-images\image-20211107153808858.png" alt="image-20211107153808858">的无偏差估计量。因此，如果生成器记忆T，则其统计数据近似于<img src="\images\typora-user-images\image-20211107163511584.png" alt="image-20211107163511584">.</p><p>因此，我们建议FID应补充额外的指标，并在小样本设置下获得广泛的定性结果。在大量数据设置中，需要大量参数来记忆图像，因此不太可能发生此问题。基于这些观察，在整个评估过程中，我们限制了训练时间步(timesteps)，而不是选择具有最佳FID的步骤，因为我们发现后一种方法给出的定性结果更差。</p><h4 id="实验">4 实验</h4><h5 id="设置">4.1 设置</h5><p>我们仅使用5-100个目标图像将预训练模型适应新的目标域，因为我们关注的场景比标准数据高效的GAN适应方法少1-2个训练样本数量。我们发现，由于过度拟合偏差，FID分数不适用于小样本状态。然而，为了完整性，我们仍然报告了我们实验的FID分数。此外，我们还报告了其他质量指标和广泛的定性结果。</p><h6 id="适应方法">适应方法</h6>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Task-Agnostic Meta-Learning for Few-shot Learning</title>
      <link href="/2023/03/17/task-agnostic-meta-learning-for-few-shot-learning/"/>
      <url>/2023/03/17/task-agnostic-meta-learning-for-few-shot-learning/</url>
      
        <content type="html"><![CDATA[<center><strong>Task-Agnostic Meta-Learning for Few-shot Learning</strong></center><center>用于小样本学习的任务不可知元学习</center><hr><h4 id="abstract">Abstract</h4><p>通常情况，元学习者(meta-learner)在各种各样的任务中被训练，以使其能普遍适应于新的任务。然而，元学习者在元训练阶段==被现有任务的过度训练==，使其对新任务的概括能力变得脆弱。换句话说，元学习者的初始模型可能==过于偏向于现有的任务==以适应新的任务，特别是当只有很少的例子可用于更新模型。</p><p>为了避免有偏差的元学习，提高其泛化能力，本文提出了一种新的任务不可知元学习(TAML)算法。</p><p>具体来说，文章提出了一种==基于熵==(entropy-based)的方法，元学习一个无偏差的初始模型与最大的不确定性输出标签，防止它在分类任务执行过度。</p><p>另外，提出了一种更普遍的==不等式最小化==(inequality-minimization)TAML用于更普遍的场景，在可以确定合适损失的情况下，直接将初始损失的不等式最小化，超出分类任务范围。</p><p>在基准数据集上的实验表明，无论是在小样本分类还是在强化学习任务上，提出的方法都优于元学习算法。</p><h4 id="introduction">1 Introduction</h4><p>元学习模型通常包含两个部分——==初始模型==(initialmodel)和==更新策略==(updating strategy)</p><p>元学习的目标：自动元学习通用于各种任务，具有最佳参数的初始模型和更新策略。</p><p>元学习存在的问题：初始模型可能偏向于某些任务，特别是那些在元训练阶段采样的任务。这种有偏差的初始模型可能无法很好地推广到与元训练任务有很大偏差的看不见的(unseen)任务，特别是新任务上几乎没有例子可用的情况下。</p><p>策略：提出了两种新的TAML算法范式——==基于熵的TAML算法==(anentropy-basedTAML)和==基于TAML的不等式最小化算法==(inequality-minimization measuresbased TAML)。</p><p>基于熵的方法的思想：最大化初始模型预测的标签的熵，以防止它在某些任务上执行过度。然而，基于熵的方法仅限于模型的离散输出(discreteoutputs)，使其更适合于分类任务。</p><p>基于TAML的不等式最小化算法：通过元训练一个初始模型，使它能够直接最小化各种任务初始模型的损失的不平等(theinequality oflosses)。同时，任何形式的损失都可以被采纳为==与其他任务有关的任务==(involvedtask)，而不必依赖于离散的输出。这使得这种算法在许多超越分类任务的场景中更加普遍。</p><h4 id="approach">2 Approach</h4><p>目标：训练一个任务不可知的模型，以防止初始模型或者学习者在特定的任务上过度执行。</p><h5 id="与任务无关的元学习">2.1 与任务无关的元学习</h5><p>学习者(alearner)在元学习阶段接受各种采样任务的训练，以便学习新的任务；<br>元学习者(ameta-learner)训练学习者(learner)，负责学习更新规则和初始模型。</p><p>面对问题：<br>(1)初始模型或学习者可能偏向于元训练阶段的某些任务，特别是当测试阶段的未来任务可能与训练阶段的任务存在差异时。(避免初始模型在某些任务上执行过度)<br>(2)执行过度的初始模型也会防止元学习者学习一个更好的，在任务之间具有一致的性能的更新规则。</p><p>解决问题：<br>在初始模型上加了一个==无偏差的任务不可知的先验==(anunbiased task-agnosticprior)，通过防止它在某些任务上执行过度，使元学习者可以实现一个更具竞争力(competitive)的更新规则。<br>任务不可知的先验是许多元学习算法广泛适用的原则，本文主要使用==模型不可知元学习方法==(MAML)作为一个例子来展示这个想法。</p><p>本文将通过提出两种任务不可知元学习(TAML)算法的范例来描述这一思想：<br>==熵最大化/熵减(entropy-maximization/reduction)TAML==<br>==不等式最小化(inequality-minimization)TAML==</p><h6 id="熵最大化熵减taml">2.1.1 熵最大化/熵减TAML</h6><p>模型表示：一个参数为θ的函数<img src="\images\typora-user-images\image-20211104225054285.png" alt="image-20211104225054285">.</p><p>元训练阶段：<br>从一个任务分布<img src="\images\typora-user-images\image-20211104225233696.png" alt="image-20211104225233696">中抽取一批任务(均为K-shotN-way任务)<br>K:训练样本的数量 N:根据问题设置表示类的数量</p><p>在==MAML==中，使用K个例子在任务<img src="\images\typora-user-images\image-20211104225602820.png" alt="image-20211104225602820">上训练模型，然后在此任务的几个新例子<img src="\images\typora-user-images\image-20211104225629573.png" alt="image-20211104225629573">上进行测试。</p><p>模型有初始化参数θ，当模型在任务<img src="\images\typora-user-images\image-20211104225602820.png" alt="image-20211104225602820">上训练时，它的参数按照更新规则从θ更新到<img src="\images\typora-user-images\image-20211104225941157.png" alt="image-20211104225941157">.</p><p>让模型以相同的概率随机猜测==过度预测==(overpredicted)的标签，这样它就不会偏差于任务。这可以表示为θ上的最大熵先验值(maximum-entropyprior)，因此初始模型在来自任务<img src="\images\typora-user-images\image-20211104225602820.png" alt="image-20211104225602820">的样本上的预测标签上应有较大的熵.</p><p>任务<img src="\images\typora-user-images\image-20211104225602820.png" alt="image-20211104225602820">的熵是通过在<img src="\images\typora-user-images\image-20211104231115680.png" alt="image-20211104231115680">中采样<img src="\images\typora-user-images\image-20211104231121825.png" alt="image-20211104231121825">，在N个预测标签的输出概率<img src="\images\typora-user-images\image-20211104231031487.png" alt="image-20211104231031487">上来计算的：</p><figure><img src="\images\typora-user-images\image-20211105214040601.png" alt="image-20211105214040601"><figcaption aria-hidden="true">image-20211105214040601</figcaption></figure><p><img src="\images\typora-user-images\image-20211105214121136.png" alt="image-20211105214121136">是通过<img src="\images\typora-user-images\image-20211105214200312.png" alt="image-20211105214200312">的预测，在分类任务中softmax层的一个输出.</p><p>在初始模型参数更新前，不仅可以最大化熵，而且可以使更新后的熵最小。<br>总的来说，最大化每个任务的熵减(entropyreduction):<img src="\images\typora-user-images\image-20211105214534544.png" alt="image-20211105214534544"><br>将<img src="\images\typora-user-images\image-20211105214638998.png" alt="image-20211105214638998">降低到最小意味着在更新参数θ到θi之后，模型可以更加确定标签，并具有更高的置信度.</p><p>该熵项可以与典型的元训练目标项相结合，作为一个调节器(regularizer)来寻找最优解θ:</p><figure><img src="\images\typora-user-images\image-20211105214848219.png" alt="image-20211105214848219"><figcaption aria-hidden="true">image-20211105214848219</figcaption></figure><p>λ：正平衡系数；第一项是更新模型<img src="\images\typora-user-images\image-20211104225054285.png" alt="image-20211104225054285">的预期损失.</p><p>熵减算法(entropy-reduction algorithm)</p><figure><img src="\images\typora-user-images\image-20211105215159773.png" alt="image-20211105215159773"><figcaption aria-hidden="true">image-20211105215159773</figcaption></figure><p>基于熵的TAML算法受到一个关键的限制——在分类任务中，只有离散的标签才应该计算熵。相比之下，许多其他的学习问题，例如回归和强化学习问题，它通常是通过直接最小化某些损失或错误函数来训练的，而不需要显式地访问特定形式的输出，例如离散标签。为了使TAML广泛适用，我们需要定义一个替代的度量标准来度量和最小化任务之间的偏差。</p><h6 id="不等式最小化taml">2.1.2 不等式最小化TAML</h6><p>想法：在每个任务<img src="\images\typora-user-images\image-20211104225602820.png" alt="image-20211104225602820">上初始模型的loss被视为该任务的income，然后对于TAML模型，通过最小化多任务loss的不平等性，使得元学习者的任务不可知。</p><p>具体来说，在元训练过程中，通过最小化一批采样任务的损失的不平等性，最小化初始模型对任意特定任务的偏差。因此，在测试阶段给定一个看不见的任务，通过从一个无偏差的初始模型进行更新，并使用很少的示例，可以在新任务上获得更好的泛化性能。</p><p>和熵最大化/熵减TAML的区别：对于熵，我们一次只考虑一个任务，通过计算其输出标签的熵。此外，熵取决于输出函数的特定形式或解释，例如，SoftMax输出。相反，不平等(inequality)只取决于损失，因此它更加普遍。</p><p>不平等度量(Inequality Measures)算法</p><figure><img src="\images\typora-user-images\image-20211105220443346.png" alt="image-20211105220443346"><figcaption aria-hidden="true">image-20211105220443346</figcaption></figure><p>考虑==一批==抽样任务<img src="\images\typora-user-images\image-20211105220640957.png" alt="image-20211105220640957">及其==损失==<img src="\images\typora-user-images\image-20211105220653957.png" alt="image-20211105220653957">的初始模型<img src="\images\typora-user-images\image-20211105220724793.png" alt="image-20211105220724793">，可以用<img src="\images\typora-user-images\image-20211105220759415.png" alt="image-20211105220759415">计算不等式度量。然后通过梯度下降法最小化以下目标，对初始模型参数θ进行元学习</p><figure><img src="\images\typora-user-images\image-20211105220901654.png" alt="image-20211105220901654"><figcaption aria-hidden="true">image-20211105220901654</figcaption></figure><p>第一项是更新后模型<img src="\images\typora-user-images\image-20211105221109096.png" alt="image-20211105221109096">的期望损失，第二项是更新前最初模型<img src="\images\typora-user-images\image-20211105221142222.png" alt="image-20211105221142222">的损失不等式。<br>这两项都是初始模型参数θ的函数(因为θi是由θ更新而来的)</p><h5 id="不平等度量">2.2 不平等度量</h5><p>任务<img src="\images\typora-user-images\image-20211105221532701.png" alt="image-20211105221532701">的损失：<img src="\images\typora-user-images\image-20211105221517711.png" alt="image-20211105221517711"><br>抽样任务中损失的平均值：<img src="\images\typora-user-images\image-20211105221620662.png" alt="image-20211105221620662"><br>单个批处理任务的数量：<img src="\images\typora-user-images\image-20211105221713102.png" alt="image-20211105221713102"></p><h6 id="theil-index">Theil Index</h6><h6 id="generalized-entropy-index">Generalized Entropy Index</h6><h6 id="atkinson-index">Atkinson Index</h6><h6 id="gini-coefficient">Gini-Coefficient</h6><h6 id="variance-of-logarithms">Variance of Logarithms</h6><p>用到了以上内容，具体公式可以去论文里看一下</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Adaptive Attentional Network for Few-Shot Knowledge Graph Completion</title>
      <link href="/2023/03/17/adaptive-attentional-network-for-few-shot-knowledge-graph-completion/"/>
      <url>/2023/03/17/adaptive-attentional-network-for-few-shot-knowledge-graph-completion/</url>
      
        <content type="html"><![CDATA[<center><strong>Adaptive Attentional Network for Few-Shot Knowledge GraphCompletion</strong></center><center>小样本知识图谱自适应注意力网络</center><hr><h4 id="abstract">Abstract</h4><ol type="1"><li>实体的动态属性：entity可能在任务关系中表现出不同的角色，reference可能对query做出不同的贡献.</li><li>提出了一种通过学习自适应entity和reference特征的自适应注意力网络来完成小样本知识图谱补全工作.</li><li>entity通过自适应邻居编码器建模以识别面向任务的角色；<br>reference通过自适应查询感知聚合器建模以区分它们的贡献.</li><li>注意力机制：使entity和reference都可以捕捉到细粒度(fine-grainedsemantic)的语义，从而呈现出更多的表达形式.</li></ol><p>==源码==：https://github.com/JiaweiSheng/FAAN.</p><h4 id="introduction">Introduction</h4><ol type="1"><li><p>GMatching：假设所有邻居对实体嵌入的贡献相同(邻居的权重相同)；<br>FSRL:使用注意力机制给相邻任务分配不同的权重，但权重在所有任务关系中无变化<br>将静态权值赋予相邻任务，在涉及不同任务关系时通过静态实体表示.</p></li><li><p>(1)实体邻居可能对不同的任务关系产生不同的影响；<br>(2)任务关系具有多义性，在不同的实体对中表现出不同的语义.</p><figure><img src="\images\typora-user-images\image-20211103213803357.png" alt="image-20211103213803357"><figcaption aria-hidden="true">image-20211103213803357</figcaption></figure><p>​ (a)一个实体在不同的任务中有不同的角色；<br>(b)reference展示了对特定的query有独特的贡献.</p></li><li><p><strong>FAAN</strong>:给予一个任务关系及其reference/query三元组，通过自适应注意力邻居编码器，对单跳实体邻居的实体表示进行建模。</p><p>(a)在假设翻译(translationassumption)下，允许注意力分数动态适应任务关系。<br>这将通过邻居的不同影响，捕捉实体的不同角色；</p><p>(b)给出了增强的实体表示，<strong>FAAN</strong>采用一个转换块堆栈(Transformerblocks)作为reference/query三元组来捕获任务关系的多重意义.</p><p>(c)<strong>FAAN</strong>通过自适应聚合reference，进一步区分他们对不同query的贡献，得到一个通用的reference表示。因此，entity和reference都可以捕获其细粒度的语义.</p></li><li><p>贡献：</p><p>(1)在小样本知识图谱补全中提出动态特征(dynamicproperties)的概念，不同于以往的范例，研究entity和reference的动态性质的小样本情景.</p><p>(2)设计了一个新的自适应注意网络模型来学习动态表征。采用==自适应邻居编码器==对entity表示进行调整以适应不同的任务。使用==转换编码器==和==基于注意力的聚合器==来适应不同query的reference表示。</p><p>(3)在NELL和Wiki-data的基准上对<strong>FAAN</strong>进行了小样本链接预测。实验结果表明，采用不同的样本数量，<strong>FAAN</strong>可以得到最新的结果。</p></li></ol><h4 id="related-work">Related Work</h4><ol type="1"><li><p>KG embedding</p></li><li><p>Dynamic properties</p></li></ol><h4 id="background">Background</h4><p>few-shot reference entity pairs:<img src="\images\typora-user-images\image-20211103222108535.png" alt="image-20211103222108535">(仅包含K-shot reference实体对<img src="\images\typora-user-images\image-20211103222410889.png" alt="image-20211103222410889">)</p><p>training task:<img src="\images\typora-user-images\image-20211103222235642.png" alt="image-20211103222235642"></p><p><img src="\images\typora-user-images\image-20211103222426233.png" alt="image-20211103222426233">包含所有的query，其中包含正确的尾实体<img src="\images\typora-user-images\image-20211103222525770.png" alt="image-20211103222525770">和相应的候选对<img src="\images\typora-user-images\image-20211103222559897.png" alt="image-20211103222559897">（候选实体是基于实体类型约束被选出的实体)</p><p><em>meta-training</em> set:<img src="\images\typora-user-images\image-20211103222808730.png" alt="image-20211103222808730"></p><p>testing task:<img src="\images\typora-user-images\image-20211103222904449.png" alt="image-20211103222904449"></p><p><em>meta-testing</em> set:<img src="\images\typora-user-images\image-20211103222950056.png" alt="image-20211103222950056"></p><h4 id="our-approach">Our Approach</h4><p><strong>FAAN</strong>目的：通过将输入query与给定的reference进行比较来学习预测的度量函数。</p><p><strong>FAAN</strong>组成：</p><p>​ (1)自适应邻居编码器学习自适应实体表示<br>(2)转换编码器学习实体对的关系表示<br>(3)自适应匹配处理器将query与给定的reference进行比较</p><p><strong>FAAN</strong>框架：</p><figure><img src="\images\typora-user-images\image-20211103223450832.png" alt="image-20211103223450832"><figcaption aria-hidden="true">image-20211103223450832</figcaption></figure><h5 id="实体自适应邻居编码器">实体自适应邻居编码器</h5><ol type="1"><li><p>以头实体<em>h</em>为目标，表示其一跳(one-hop)邻居：<img src="\images\typora-user-images\image-20211104154207238.png" alt="image-20211104154207238"></p></li><li><p>目的：通过<img src="\images\typora-user-images\image-20211104154351488.png" alt="image-20211104154351488">获得不同的实体表示，以展示它们在不同的任务关系中的不同角色。</p></li><li><p>翻译假设下，给定实体对<em>(h,t)</em>，可以得到小样本任务关系r的嵌入：<img src="\images\typora-user-images\image-20211104154855633.png" alt="image-20211104154855633"></p></li><li><p>==未来工作==：使用其他KG嵌入方法替换翻译模型(TransE)</p></li><li><p>根据任务关系<em>r</em>和邻居关系<img src="\images\typora-user-images\image-20211104155312802.png" alt="image-20211104155312802">之间的关联性来区分<em>h</em>的角色。<br>定义度量函数<img src="\images\typora-user-images\image-20211104155405712.png" alt="image-20211104155405712">，通过双线性点积计算任务关系和邻居关系的相关性得分：</p><figure><img src="\images\typora-user-images\image-20211104155504905.png" alt="image-20211104155504905"><figcaption aria-hidden="true">image-20211104155504905</figcaption></figure><p>通过考虑<em>h</em>的不同角色，我们获得了一个角色感知的邻居嵌入<img src="\images\typora-user-images\image-20211104155723464.png" alt="image-20211104155723464">：</p><figure><img src="\images\typora-user-images\image-20211104155749066.png" alt="image-20211104155749066"><figcaption aria-hidden="true">image-20211104155749066</figcaption></figure><p>当任务关系和邻居关系更相关时，<img src="\images\typora-user-images\image-20211104155958973.png" alt="image-20211104155958973">将会更高并且在邻居嵌入中相应的邻居实体将发挥更重要的作用.</p></li><li><p>为了加强实体嵌入，同时耦合预训练的实体嵌入<strong><em>h</em></strong>和它的角色感知邻居嵌入<img src="\images\typora-user-images\image-20211104155723464.png" alt="image-20211104155723464">.<em>h</em>可表述为：<img src="\images\typora-user-images\image-20211104160339510.png" alt="image-20211104160339510"></p><p>以这种方式获得的实体表示：<br> (1)保留当前嵌入模型的个别属性；<br>(2)拥有不同的角色以适应不同的任务.</p></li></ol><h5 id="实体对转换编码器">实体对转换编码器</h5><ol type="1"><li>在<em>r</em>的任务中给出一个实体对<em>(h,t)</em>，把每个任务关系的实体对作为一个序列：<img src="\images\typora-user-images\image-20211104161243446.png" alt="image-20211104161243446">(第一个/最后一个元素是头/尾实体，中间是任务关系)<br>对<em>X</em>中的每一个元素<img src="\images\typora-user-images\image-20211104161423294.png" alt="image-20211104161423294">，构造其输入表示：<img src="\images\typora-user-images\image-20211104161502041.png" alt="image-20211104161502041">.<br><img src="\images\typora-user-images\image-20211104161543304.png" alt="image-20211104161543304">表示元素嵌入(element embedding);<img src="\images\typora-user-images\image-20211104161616057.png" alt="image-20211104161616057">表示位置嵌入(position embedding).<img src="\images\typora-user-images\image-20211104161710640.png" alt="image-20211104161710640">和<img src="\images\typora-user-images\image-20211104161722039.png" alt="image-20211104161722039">都从自适应邻居编码器中获得.</li><li>将输入表示送入L转换块堆栈(Transformerblocks)去编码<em>X</em>并获得：<br><img src="\images\typora-user-images\image-20211104191144977.png" alt="image-20211104191144977">:经过第l层之后<img src="\images\typora-user-images\image-20211104191310441.png" alt="image-20211104191310441">的隐藏状态<br><img src="\images\typora-user-images\image-20211104191109638.png" alt="image-20211104191109638"><br>Transformer采用多头自注意力机制，每个块允许每个元素参与到序列中不同权重的所有元素中.</li><li>为了完成小样本KG补全任务，我们仅将掩码(mask)限制为任务关系r(如<img src="\images\typora-user-images\image-20211104191851741.png" alt="image-20211104191851741">)，以获得有意义的实体对嵌入<br>最后的隐藏状态<img src="\images\typora-user-images\image-20211104192033774.png" alt="image-20211104192033774">作为<img src="\images\typora-user-images\image-20211104192107111.png" alt="image-20211104192107111">中实体对的所需表示.<br>这种表示方法对每个实体的语义角色进行编码，从而帮助识别与不同实体对相关的任务关系的细粒度含义.</li></ol><h5 id="自适应匹配处理器">自适应匹配处理器</h5><ol type="1"><li><p>考虑到任务关系的各种含义，定义一个度量函数<img src="\images\typora-user-images\image-20211104192405380.png" alt="image-20211104192405380">:用来测量<img src="\images\typora-user-images\image-20211104192455855.png" alt="image-20211104192455855">(query)和<img src="\images\typora-user-images\image-20211104192528808.png" alt="image-20211104192528808">(reference)三元组的语义相似度.</p><figure><img src="\images\typora-user-images\image-20211104192559353.png" alt="image-20211104192559353"><figcaption aria-hidden="true">image-20211104192559353</figcaption></figure></li><li><p>与现有的小样本关系学习模型在预测不同查询时学习静态表示不同，我们采用注意机制来获得一个适应query的通用reference表示<img src="\images\typora-user-images\image-20211104192829237.png" alt="image-20211104192829237"></p><figure><img src="\images\typora-user-images\image-20211104192853176.png" alt="image-20211104192853176"><figcaption aria-hidden="true">image-20211104192853176</figcaption></figure><p><img src="\images\typora-user-images\image-20211104193001943.png" alt="image-20211104193001943">表示reference的注意力分数;</p><p><img src="\images\typora-user-images\image-20211104193035601.png" alt="image-20211104193035601">表示任务<em>r</em>的第<em>k</em>个reference;</p><p><img src="\images\typora-user-images\image-20211104193202895.png" alt="image-20211104193202895">表示在<img src="\images\typora-user-images\image-20211104193232135.png" alt="image-20211104193232135">中query的嵌入.</p><p><img src="\images\typora-user-images\image-20211104194032983.png" alt="image-20211104194032983">和<img src="\images\typora-user-images\image-20211104193202895.png" alt="image-20211104193202895">都是通过<img src="\images\typora-user-images\image-20211104191109638.png" alt="image-20211104191109638">计算得来的，用以捕捉其细粒度含义的.</p></li><li><p>为了做出预测，设定了一个度量函数<img src="\images\typora-user-images\image-20211104194250884.png" alt="image-20211104194250884">来度量<img src="\images\typora-user-images\image-20211104194336718.png" alt="image-20211104194336718">和<img src="\images\typora-user-images\image-20211104194346966.png" alt="image-20211104194346966">的语义相似度：</p><figure><img src="\images\typora-user-images\image-20211104194405967.png" alt="image-20211104194405967"><figcaption aria-hidden="true">image-20211104194405967</figcaption></figure></li></ol><h5 id="模型训练">模型训练</h5><p>1.元训练集<img src="\images\typora-user-images\image-20211104194535440.png" alt="image-20211104194535440">的组成：</p><p>对于每个小样本关系<em>r</em>，从<em>T</em>中随机抽取K个正实体对作为reference集<img src="\images\typora-user-images\image-20211104194813580.png" alt="image-20211104194813580">，<br>剩余的实体对用作正query集<img src="\images\typora-user-images\image-20211104194854287.png" alt="image-20211104194854287">；<br>接着，通过随机污染尾部实体构造负query集<img src="\images\typora-user-images\image-20211104195016279.png" alt="image-20211104195016279"></p><p>总Loss:<img src="\images\typora-user-images\image-20211104195131349.png" alt="image-20211104195131349"><br></p><p>最小化Loss:把每个在元训练集中的关系作为一个任务，采用了一个基于批量抽样的元训练过程(FSRL中使用的)</p><p>==未来工作==：考虑其他先进的方法来建模小样本关系，并利用更多的上下文信息，如文本描述来增强实体嵌入。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>One-Shot Relational Learning for Knowledge Graphs</title>
      <link href="/2023/03/17/one-shot-relational-learning-for-knowledge-graphs/"/>
      <url>/2023/03/17/one-shot-relational-learning-for-knowledge-graphs/</url>
      
        <content type="html"><![CDATA[<center><strong>One-Shot Relational Learning for Knowledge Graphs</strong></center><center>知识图谱的小样本关系学习</center><h4 id="abstract">Abstract</h4><p>在只有一个训练实例可用的具有挑战性的环境下预测新的事实。提出了一个单样本关系学习框架，该框架利用嵌入模型提取的知识，通过考虑学习到的嵌入和一跳图结构来学习匹配度量。</p><h4 id="introduction">1 Introduction</h4><p>提出了一种只依赖于实体嵌入和局部图结构的模型。我们的模型旨在学习一个匹配度量，该度量可用于在给定一个参考三元组的情况下发现更多类似的三元组。可学习度量模型基于一个置换不变网络，该网络有效地编码实体的一跳邻居，以及一个允许多步匹配的递归神经网络。一旦训练，模型将能够对任何关系进行预测。</p><p>贡献：</p><p>1.在链接预测任务中，我们首先考虑长尾关系，并将问题归结为少样本关系学习；</p><p>2.提出了一个为关系数据有效的单样本学习框架，它比各种基于嵌入的方法具有更好的性能；</p><p>3.我们还提出了两个新构建的数据集，用于单样本知识图谱补全任务。</p><h4 id="related-work">2 Related Work</h4><h5 id="embedding-models-for-relational-learning">Embedding Models forRelational Learning</h5><h5 id="few-shot-learning">Few-Shot Learning</h5><p>(1)基于度量的方法</p><p>(2)基于元学习的方法</p><h4 id="background">3 Background</h4><h5 id="问题表述">3.1 问题表述</h5><p>知识图谱补全的任务：预测两个现有实体之间不可见的关系或者通过给出头部实体和关系预测尾部实体。<br>本文目标：在仅有一个实例三元组<span class="math display">\[(h_0,r,t_0)\]</span>的情况下，让真正的尾部实体<span class="math display">\[t_{true}\]</span>的排名高于其他候选实体<span class="math display">\[t\in{C_{h,r}}\]</span>的排名。<br>其中，候选集使用实体类型约束(entitytype constraint)构造。</p><p>当我们预测一种关系<span class="math display">\[r\]</span>的新事实时，我们仅考虑一组封闭的实体(test过程中没有不可见实体)</p><p>==未来工作==：使用实体的文本描述(在测试期间可能出现新的实体的开放世界设置)</p><h5 id="单样本学习设置">3.2 单样本学习设置</h5><p>目标：学习一个度量，可以通过单样本示例预测新的事实。</p><p><em>meta-training</em> set(<span class="math display">\[\mathbb{T}_{meta-train}\]</span>)：每个训练任务对应==一个知识图谱关系==<span class="math display">\[r\in{R}\]</span>，并且他有自己的训练/测试三元组：<span class="math inline">\(T_r=\{D^{train}_{r},D^{test}_{r}\}\)</span></p><p>评估过程：在<span class="math inline">\(D^{train}_{r}\)</span>中仅有一个三元组<span class="math inline">\((h_0,r,t_0)\)</span>，<span class="math inline">\(D^{test}_{r}=\{(h_i,r,t_i,C_{h_i,r})\}\)</span>由<span class="math inline">\(r\)</span>的测试三元组组成，每个query<span class="math inline">\((h_i,r)\)</span>带有真实的(ground-truth)尾部实体<span class="math inline">\(t_i\)</span>以及对应的尾部候选实体<span class="math inline">\(C_{h_i,r}=\{t_{ij}\}\)</span>，每个<span class="math inline">\(t_{ij}\)</span>是<span class="math inline">\(G\)</span>中的一个实体。</p><p>因此，在给定测试query<span class="math inline">\((h_i,r)\)</span>和<span class="math inline">\(D^{train}_{r}\)</span>中的标记三元组的情况下，通过对候选集<span class="math inline">\(C_{h_i,r}\)</span>进行排序，可以在此集合上测试度量模型。</p><p>损失函数：<span class="math inline">\(l_{\theta}(h_i,r,t_i|C_{h_i,r},D^{train}_{r})\)</span>，<span class="math inline">\(\theta\)</span>表示度量模型的参数。</p><p>此损失函数表示度量模型在元组<span class="math inline">\((h_i,r,t_i,C_{h_i,r})\)</span>上的工作情况，同时只观察<span class="math inline">\(D^{train}_{r}\)</span>中的单样本数据。</p><p>度量模型的训练目标(元训练目标)：</p><figure><img src="\images\typora-user-images\image-20211113230507602.png" alt="image-20211113230507602"><figcaption aria-hidden="true">image-20211113230507602</figcaption></figure><p><span class="math inline">\(T_r\)</span>是从<em>meta-training</em>set(<span class="math display">\[\mathbb{T}_{meta-train}\]</span>)中取样得来的，<span class="math inline">\(|D^{test}_{r}|\)</span>表示<span class="math inline">\(D^{test}_{r}\)</span>中的元组数。</p><p><em>meta-testing</em> set(<span class="math display">\[\mathbb{T}_{meta-test}\]</span>)：预测新关系<span class="math inline">\(r^{'}\in R^{'}\)</span>，其中这些<span class="math inline">\(r^{'}\)</span>是在<em>meta-training</em>中不可见的(<span class="math inline">\(R^{'}\cap R=\empty\)</span>)，每一个<span class="math inline">\(r^{'}\)</span>也有自己的单样本训练数据<span class="math inline">\(D^{train}_{r^{'}}\)</span>和测试数据<span class="math inline">\(D^{test}_{r^{'}}\)</span>(定义方式和<em>meta-training</em>相同)</p><p><em>meta-validation</em> set(<span class="math display">\[\mathbb{T}_{meta-validation}\]</span>)：从<span class="math display">\[\mathbb{T}_{meta-train}\]</span>中去掉一部分关系。</p><h4 id="model">4 Model</h4><p>模型核心：相似函数<span class="math inline">\(\mathcal{M}((h,t),(h^{'},t^{'})|\mathcal{G}^{'})\)</span>.对于一个已知的事实<span class="math inline">\((h_0,r,t_0)\)</span>，模型可以预测测试三元组<span class="math inline">\(\{(h_i,r,t_{ij})|t_{ij}\in{C_{h_i,r}}\}\)</span>的可能性(通过计算每个<span class="math inline">\((h_i,t_{ij})\)</span>与<span class="math inline">\((h_0,t_0)\)</span>的匹配得分).</p><p>存在问题：<br>(1)实体对的表示<br>(2)实体对之间的比较函数</p><figure><img src="\images\typora-user-images\image-20211121143817595.png" alt="image-20211121143817595"><figcaption aria-hidden="true">image-20211121143817595</figcaption></figure><p>1.Neighborencoder：旨在利用局部图结构更好地表示实体。通过这种方式，模型可以利用KG为实体对中的每个实体提供的更多信息。</p><p>2.Matchingprocessor：从邻居编码器获取任意两个实体对的向量表示；然后在两个实体对之间执行多步匹配，并输出一个标量作为相似性分数。</p><h5 id="neighbor-encoder">4.1 Neighbor Encoder</h5><p>目的：增强知识图谱中每个实体和其局部连接的表示。</p><p>注：只考虑实体的一跳(one-hop)邻居。</p><p>对于任意给定实体<span class="math inline">\(e\)</span>，其本地连接组成了一组<span class="math inline">\((relation,entity)\)</span>元组，我们把这个邻居集称为<span class="math inline">\(\mathcal{N}_e=\{(r_k,e_k)|(e,r_k,e_k)\in{\mathcal{G}^{'}}\}\)</span>.<br>邻居编码器的目的：编码<span class="math inline">\(\mathcal{N}_e\)</span>并输出一个向量作为实体<span class="math inline">\(e\)</span>的潜在表示。</p><p>编码要求：<br>(1)置换不变量；<br>(2)对邻居集的大小不敏感。</p><p>根据要求，使用以下函数<span class="math inline">\(f\)</span>：</p><figure><img src="\images\typora-user-images\image-20211121144816770.png" alt="image-20211121144816770"><figcaption aria-hidden="true">image-20211121144816770</figcaption></figure><p>其中，<span class="math inline">\(C_{r_k,e_k}\)</span>为关系-实体对<span class="math inline">\((r_k,e_k)\)</span>的特征表示。</p><p>1.为了把每个元组<span class="math inline">\((r_k,e_k)\in{\mathcal{N}_e}\)</span>编码为<span class="math inline">\(C_{r_k,e_k}\)</span>，首先使用一个维度为<span class="math inline">\(d\)</span>的嵌入层<strong>emb</strong>(使用现有基于嵌入的模型对其进行预训练)去获得<span class="math inline">\(r_k\)</span>和<span class="math inline">\(e_k\)</span>的向量表示：(TransE等模型预训练嵌入步骤)</p><figure><img src="\images\typora-user-images\image-20211121145257133.png" alt="image-20211121145257133"><figcaption aria-hidden="true">image-20211121145257133</figcaption></figure><p>上述步骤还使用了dropout以获得更好的泛化能力。</p><p>2.使用一个前馈(feed-forward)层对该元组的交互进行编码：</p><figure><img src="\images\typora-user-images\image-20211121145442214.png" alt="image-20211121145442214"><figcaption aria-hidden="true">image-20211121145442214</figcaption></figure><p>为了在训练期间启用批处理，我们手动指定邻居的最大数量(max_neighbor)，并使用所有零向量作为“虚拟”邻居。尽管不同的实体有不同的度(degree)（邻居的数量），度分布通常非常集中，如图3所示。我们可以很容易地找到一组实体的最大邻居数。</p><figure><img src="\images\typora-user-images\image-20211121145929993.png" alt="image-20211121145929993"><figcaption aria-hidden="true">image-20211121145929993</figcaption></figure><p>邻居编码器的模型类似于关系图卷积网络(RGCN),我们使用了共享的内核<span class="math inline">\(\{W_c,b_c\}\)</span>对不同的实体的邻居进行编码。但是与他们的模型不同，我们只对实体的局部图进行编码并执行进一步传播(使我们能够轻松地将模型应用于大规模KG)。</p><h5 id="matching-processor">4.2 Matching Processor</h5><p>通过对reference实体对<span class="math inline">\((h_0,t_0)\)</span>和所有的query实体对<span class="math inline">\((h_i,t_{ij})\)</span>，我们得到了两个邻居向量：<span class="math inline">\([f(\mathcal{N}_{h_0});f(\mathcal{N}_{t_0})]\)</span>和<span class="math inline">\([f(\mathcal{N}_{h_i});f(\mathcal{N}_{t_{ij}})]\)</span>。为了得到一个可用于在其他候选集中对<span class="math inline">\((h_i,t_{ij})\)</span>进行排名的相似性分数，我们可以将每对中的<span class="math inline">\(f(\mathcal{N}_{h})\)</span>和<span class="math inline">\(f(\mathcal{N}_{t})\)</span>连接起来，形成一个单对表示向量，并计算对之间的余弦相似性。</p><p>为了扩大模型的容量，利用基于LSTM的循环处理块执行多步匹配：</p><figure><img src="\images\typora-user-images\image-20211121153952055.png" alt="image-20211121153952055"><figcaption aria-hidden="true">image-20211121153952055</figcaption></figure><p>其中，reference对 <span class="math inline">\(s=f(\mathcal{N}_{h_0})\oplus{f(\mathcal{N}_{t_0})}\)</span>，query对<span class="math inline">\(q=f(\mathcal{N}_{h_i})\oplus{f(\mathcal{N}_{t_{ij}})}\)</span>.</p><p>在<span class="math inline">\(K\)</span>个处理步骤之后，我们使用<span class="math inline">\(score_K\)</span>作为query和support实体之间最终的相似性得分。对于每个实体<span class="math inline">\((h_i,r,?)\)</span>，通过比较<span class="math inline">\((h_i,t_{ij})\)</span>和<span class="math inline">\((h_0,t_{0})\)</span>，我们可以得到每个<span class="math inline">\(t_{ij}\in{C_{h_i,r}}\)</span>的相似性得分。</p><h5 id="loss-function-and-training">4.3 Loss Function and Training</h5><p>对于一个query关系<span class="math inline">\(r\)</span>和他的reference/training三元组<span class="math inline">\((h_0,r,t_{0})\)</span>，我们收集他的正样本query三元组<span class="math inline">\(\{(h_i,r,t_i^+)|(h_i,r,t_i^+)\in\mathcal{G}\}\)</span>，并且构造另一组负样本query三元组(通过污染尾实体)<span class="math inline">\(\{(h_i,r,t_i^-)|(h_i,r,t_i^-)\notin\mathcal{G}\}\)</span>，使用hinge损失函数来优化模型：</p><figure><img src="\images\typora-user-images\image-20211121154827959.png" alt="image-20211121154827959"><figcaption aria-hidden="true">image-20211121154827959</figcaption></figure><p>对于每一次训练，我们首先在meta-training集中对一个任务/关系<span class="math inline">\(T_r\)</span>进行抽样，然后从<span class="math inline">\(T_r\)</span>中所有已知三元组，我们选取一个三元组作为reference/training三元组<span class="math inline">\(D_r^{train}\)</span>和一组其他的三元组作为正样本query/test三元组<span class="math inline">\(D_r^{test}\)</span>.</p><figure><img src="\images\typora-user-images\image-20211121155123768.png" alt="image-20211121155123768"><figcaption aria-hidden="true">image-20211121155123768</figcaption></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
